// Code generated by protoc-gen-go. DO NOT EDIT.
// source: pkg/webview/log.proto

package webview

import (
	fmt "fmt"
	math "math"

	proto "github.com/golang/protobuf/proto"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type LogLevel int32

const (
	// For backwards-compatibility, the int value doesn't say
	// anything about relative severity.
	LogLevel_NONE    LogLevel = 0
	LogLevel_INFO    LogLevel = 1
	LogLevel_VERBOSE LogLevel = 2
	LogLevel_DEBUG   LogLevel = 3
	LogLevel_WARN    LogLevel = 4
	LogLevel_ERROR   LogLevel = 5
)

var LogLevel_name = map[int32]string{
	0: "NONE",
	1: "INFO",
	2: "VERBOSE",
	3: "DEBUG",
	4: "WARN",
	5: "ERROR",
}

var LogLevel_value = map[string]int32{
	"NONE":    0,
	"INFO":    1,
	"VERBOSE": 2,
	"DEBUG":   3,
	"WARN":    4,
	"ERROR":   5,
}

func (x LogLevel) String() string {
	return proto.EnumName(LogLevel_name, int32(x))
}

func (LogLevel) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3da405ef8c289d22, []int{0}
}

type LogSegment struct {
	SpanId string               `protobuf:"bytes,1,opt,name=span_id,json=spanId,proto3" json:"span_id,omitempty"`
	Time   *timestamp.Timestamp `protobuf:"bytes,2,opt,name=time,proto3" json:"time,omitempty"`
	Text   string               `protobuf:"bytes,3,opt,name=text,proto3" json:"text,omitempty"`
	Level  LogLevel             `protobuf:"varint,4,opt,name=level,proto3,enum=webview.LogLevel" json:"level,omitempty"`
	// When we store warnings in the LogStore, we break them up into lines and
	// store them as a series of line segments. 'anchor' marks the beginning of a
	// series of logs that should be kept together.
	//
	// Anchor warning1, line1
	//        warning1, line2
	// Anchor warning2, line1
	Anchor bool `protobuf:"varint,5,opt,name=anchor,proto3" json:"anchor,omitempty"`
	// Context-specific optional fields for a log segment.
	// Used for experimenting with new types of log metadata.
	Fields               map[string]string `protobuf:"bytes,6,rep,name=fields,proto3" json:"fields,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *LogSegment) Reset()         { *m = LogSegment{} }
func (m *LogSegment) String() string { return proto.CompactTextString(m) }
func (*LogSegment) ProtoMessage()    {}
func (*LogSegment) Descriptor() ([]byte, []int) {
	return fileDescriptor_3da405ef8c289d22, []int{0}
}

func (m *LogSegment) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LogSegment.Unmarshal(m, b)
}
func (m *LogSegment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LogSegment.Marshal(b, m, deterministic)
}
func (m *LogSegment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogSegment.Merge(m, src)
}
func (m *LogSegment) XXX_Size() int {
	return xxx_messageInfo_LogSegment.Size(m)
}
func (m *LogSegment) XXX_DiscardUnknown() {
	xxx_messageInfo_LogSegment.DiscardUnknown(m)
}

var xxx_messageInfo_LogSegment proto.InternalMessageInfo

func (m *LogSegment) GetSpanId() string {
	if m != nil {
		return m.SpanId
	}
	return ""
}

func (m *LogSegment) GetTime() *timestamp.Timestamp {
	if m != nil {
		return m.Time
	}
	return nil
}

func (m *LogSegment) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *LogSegment) GetLevel() LogLevel {
	if m != nil {
		return m.Level
	}
	return LogLevel_NONE
}

func (m *LogSegment) GetAnchor() bool {
	if m != nil {
		return m.Anchor
	}
	return false
}

func (m *LogSegment) GetFields() map[string]string {
	if m != nil {
		return m.Fields
	}
	return nil
}

type LogSpan struct {
	ManifestName         string   `protobuf:"bytes,1,opt,name=manifest_name,json=manifestName,proto3" json:"manifest_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LogSpan) Reset()         { *m = LogSpan{} }
func (m *LogSpan) String() string { return proto.CompactTextString(m) }
func (*LogSpan) ProtoMessage()    {}
func (*LogSpan) Descriptor() ([]byte, []int) {
	return fileDescriptor_3da405ef8c289d22, []int{1}
}

func (m *LogSpan) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LogSpan.Unmarshal(m, b)
}
func (m *LogSpan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LogSpan.Marshal(b, m, deterministic)
}
func (m *LogSpan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogSpan.Merge(m, src)
}
func (m *LogSpan) XXX_Size() int {
	return xxx_messageInfo_LogSpan.Size(m)
}
func (m *LogSpan) XXX_DiscardUnknown() {
	xxx_messageInfo_LogSpan.DiscardUnknown(m)
}

var xxx_messageInfo_LogSpan proto.InternalMessageInfo

func (m *LogSpan) GetManifestName() string {
	if m != nil {
		return m.ManifestName
	}
	return ""
}

type LogList struct {
	Spans    map[string]*LogSpan `protobuf:"bytes,1,rep,name=spans,proto3" json:"spans,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Segments []*LogSegment       `protobuf:"bytes,2,rep,name=segments,proto3" json:"segments,omitempty"`
	// from_checkpoint and to_checkpoint express an interval on the
	// central log-store, with an inclusive start and an exclusive end
	//
	// [from_checkpoint, to_checkpoint)
	//
	// An interval of [0, 0) means that the server isn't using
	// the incremental load protocol.
	//
	// An interval of [-1, -1) means that the server doesn't have new logs
	// to send down.
	FromCheckpoint       int32    `protobuf:"varint,3,opt,name=from_checkpoint,json=fromCheckpoint,proto3" json:"from_checkpoint,omitempty"`
	ToCheckpoint         int32    `protobuf:"varint,4,opt,name=to_checkpoint,json=toCheckpoint,proto3" json:"to_checkpoint,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LogList) Reset()         { *m = LogList{} }
func (m *LogList) String() string { return proto.CompactTextString(m) }
func (*LogList) ProtoMessage()    {}
func (*LogList) Descriptor() ([]byte, []int) {
	return fileDescriptor_3da405ef8c289d22, []int{2}
}

func (m *LogList) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LogList.Unmarshal(m, b)
}
func (m *LogList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LogList.Marshal(b, m, deterministic)
}
func (m *LogList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogList.Merge(m, src)
}
func (m *LogList) XXX_Size() int {
	return xxx_messageInfo_LogList.Size(m)
}
func (m *LogList) XXX_DiscardUnknown() {
	xxx_messageInfo_LogList.DiscardUnknown(m)
}

var xxx_messageInfo_LogList proto.InternalMessageInfo

func (m *LogList) GetSpans() map[string]*LogSpan {
	if m != nil {
		return m.Spans
	}
	return nil
}

func (m *LogList) GetSegments() []*LogSegment {
	if m != nil {
		return m.Segments
	}
	return nil
}

func (m *LogList) GetFromCheckpoint() int32 {
	if m != nil {
		return m.FromCheckpoint
	}
	return 0
}

func (m *LogList) GetToCheckpoint() int32 {
	if m != nil {
		return m.ToCheckpoint
	}
	return 0
}

func init() {
	proto.RegisterEnum("webview.LogLevel", LogLevel_name, LogLevel_value)
	proto.RegisterType((*LogSegment)(nil), "webview.LogSegment")
	proto.RegisterMapType((map[string]string)(nil), "webview.LogSegment.FieldsEntry")
	proto.RegisterType((*LogSpan)(nil), "webview.LogSpan")
	proto.RegisterType((*LogList)(nil), "webview.LogList")
	proto.RegisterMapType((map[string]*LogSpan)(nil), "webview.LogList.SpansEntry")
}

func init() { proto.RegisterFile("pkg/webview/log.proto", fileDescriptor_3da405ef8c289d22) }

var fileDescriptor_3da405ef8c289d22 = []byte{
	// 488 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x53, 0xdb, 0x6e, 0xd3, 0x40,
	0x14, 0xc4, 0x8e, 0x9d, 0xcb, 0x71, 0x29, 0x66, 0xb9, 0x59, 0xe1, 0xa1, 0x56, 0x40, 0xad, 0x85,
	0xc4, 0x5a, 0x84, 0x07, 0x2e, 0x6f, 0x04, 0x5c, 0x54, 0x88, 0x1c, 0x69, 0xcb, 0x45, 0xe2, 0x25,
	0x72, 0x92, 0x8d, 0xb3, 0x8a, 0xed, 0xb5, 0xb2, 0x9b, 0x94, 0x7e, 0x01, 0x7f, 0xc1, 0xb7, 0x56,
	0xbb, 0x76, 0x5a, 0x57, 0xea, 0xdb, 0x39, 0xb3, 0x73, 0x46, 0x33, 0x93, 0x18, 0x9e, 0x94, 0xeb,
	0x34, 0xbc, 0xa0, 0xb3, 0x1d, 0xa3, 0x17, 0x61, 0xc6, 0x53, 0x5c, 0x6e, 0xb8, 0xe4, 0xa8, 0x53,
	0x43, 0xfd, 0xa3, 0x94, 0xf3, 0x34, 0xa3, 0xa1, 0x86, 0x67, 0xdb, 0x65, 0x28, 0x59, 0x4e, 0x85,
	0x4c, 0xf2, 0xb2, 0x62, 0x0e, 0xfe, 0x9b, 0x00, 0x63, 0x9e, 0x9e, 0xd3, 0x34, 0xa7, 0x85, 0x44,
	0xcf, 0xa0, 0x23, 0xca, 0xa4, 0x98, 0xb2, 0x85, 0x67, 0xf8, 0x46, 0xd0, 0x23, 0x6d, 0xb5, 0x9e,
	0x2d, 0x10, 0x06, 0x4b, 0x9d, 0x7a, 0xa6, 0x6f, 0x04, 0xce, 0xb0, 0x8f, 0x2b, 0x5d, 0xbc, 0xd7,
	0xc5, 0x3f, 0xf6, 0xba, 0x44, 0xf3, 0x10, 0x02, 0x4b, 0xd2, 0xbf, 0xd2, 0x6b, 0x69, 0x15, 0x3d,
	0xa3, 0x13, 0xb0, 0x33, 0xba, 0xa3, 0x99, 0x67, 0xf9, 0x46, 0x70, 0x38, 0x7c, 0x88, 0x6b, 0x97,
	0x78, 0xcc, 0xd3, 0xb1, 0x7a, 0x20, 0xd5, 0x3b, 0x7a, 0x0a, 0xed, 0xa4, 0x98, 0xaf, 0xf8, 0xc6,
	0xb3, 0x7d, 0x23, 0xe8, 0x92, 0x7a, 0x43, 0xef, 0xa0, 0xbd, 0x64, 0x34, 0x5b, 0x08, 0xaf, 0xed,
	0xb7, 0x02, 0x67, 0x78, 0xd4, 0x54, 0xa8, 0x23, 0xe0, 0x53, 0xcd, 0x88, 0x0a, 0xb9, 0xb9, 0x24,
	0x35, 0xbd, 0xff, 0x01, 0x9c, 0x06, 0x8c, 0x5c, 0x68, 0xad, 0xe9, 0x65, 0x9d, 0x50, 0x8d, 0xe8,
	0x31, 0xd8, 0xbb, 0x24, 0xdb, 0x56, 0xf9, 0x7a, 0xa4, 0x5a, 0x3e, 0x9a, 0xef, 0x8d, 0x01, 0x86,
	0x8e, 0x12, 0x2f, 0x93, 0x02, 0xbd, 0x80, 0xfb, 0x79, 0x52, 0xb0, 0x25, 0x15, 0x72, 0x5a, 0x24,
	0x39, 0xad, 0x05, 0x0e, 0xf6, 0x60, 0x9c, 0xe4, 0x74, 0xf0, 0xcf, 0xd4, 0x07, 0x63, 0x26, 0x24,
	0x7a, 0x03, 0xb6, 0xaa, 0x4f, 0x78, 0x86, 0xb6, 0xfb, 0xfc, 0x56, 0x60, 0x26, 0x24, 0x56, 0xb2,
	0xb5, 0xd5, 0x8a, 0x89, 0x42, 0xe8, 0x8a, 0x2a, 0x88, 0xf0, 0x4c, 0x7d, 0xf5, 0xe8, 0x8e, 0x90,
	0xe4, 0x9a, 0x84, 0x4e, 0xe0, 0xc1, 0x72, 0xc3, 0xf3, 0xe9, 0x7c, 0x45, 0xe7, 0xeb, 0x92, 0xb3,
	0xa2, 0xea, 0xdc, 0x26, 0x87, 0x0a, 0xfe, 0x7c, 0x8d, 0x2a, 0xf7, 0x92, 0x37, 0x69, 0x96, 0xa6,
	0x1d, 0x48, 0x7e, 0x43, 0xea, 0x7f, 0x03, 0xb8, 0xf1, 0x74, 0x47, 0x4f, 0xc7, 0xcd, 0x9e, 0x9c,
	0xa1, 0x7b, 0xcb, 0x5b, 0x99, 0x14, 0x8d, 0xe6, 0x5e, 0x7d, 0x87, 0xee, 0xfe, 0x87, 0x45, 0x5d,
	0xb0, 0xe2, 0x49, 0x1c, 0xb9, 0xf7, 0xd4, 0x74, 0x16, 0x9f, 0x4e, 0x5c, 0x03, 0x39, 0xd0, 0xf9,
	0x15, 0x91, 0xd1, 0xe4, 0x3c, 0x72, 0x4d, 0xd4, 0x03, 0xfb, 0x4b, 0x34, 0xfa, 0xf9, 0xd5, 0x6d,
	0x29, 0xc6, 0xef, 0x4f, 0x24, 0x76, 0x2d, 0x05, 0x46, 0x84, 0x4c, 0x88, 0x6b, 0x8f, 0x8e, 0xff,
	0xbc, 0x4c, 0x99, 0x5c, 0x6d, 0x67, 0x78, 0xce, 0xf3, 0x50, 0xb2, 0x4c, 0xbe, 0x5e, 0xd0, 0x9d,
	0x1e, 0xc2, 0xc6, 0x37, 0x30, 0x6b, 0xeb, 0x7f, 0xe4, 0xdb, 0xab, 0x00, 0x00, 0x00, 0xff, 0xff,
	0x88, 0xab, 0xfb, 0x09, 0x19, 0x03, 0x00, 0x00,
}

// Code generated by protoc-gen-go. DO NOT EDIT.
// source: pkg/webview/log.proto

package webview

import (
	fmt "fmt"
	math "math"

	proto "github.com/golang/protobuf/proto"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type LogLevel int32

const (
	LogLevel_NONE    LogLevel = 0
	LogLevel_INFO    LogLevel = 1
	LogLevel_VERBOSE LogLevel = 2
	LogLevel_DEBUG   LogLevel = 3
)

var LogLevel_name = map[int32]string{
	0: "NONE",
	1: "INFO",
	2: "VERBOSE",
	3: "DEBUG",
}

var LogLevel_value = map[string]int32{
	"NONE":    0,
	"INFO":    1,
	"VERBOSE": 2,
	"DEBUG":   3,
}

func (x LogLevel) String() string {
	return proto.EnumName(LogLevel_name, int32(x))
}

func (LogLevel) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3da405ef8c289d22, []int{0}
}

type LogSegment struct {
	SpanId               string               `protobuf:"bytes,1,opt,name=span_id,json=spanId,proto3" json:"span_id,omitempty"`
	Time                 *timestamp.Timestamp `protobuf:"bytes,2,opt,name=time,proto3" json:"time,omitempty"`
	Text                 string               `protobuf:"bytes,3,opt,name=text,proto3" json:"text,omitempty"`
	Level                LogLevel             `protobuf:"varint,4,opt,name=level,proto3,enum=webview.LogLevel" json:"level,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *LogSegment) Reset()         { *m = LogSegment{} }
func (m *LogSegment) String() string { return proto.CompactTextString(m) }
func (*LogSegment) ProtoMessage()    {}
func (*LogSegment) Descriptor() ([]byte, []int) {
	return fileDescriptor_3da405ef8c289d22, []int{0}
}

func (m *LogSegment) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LogSegment.Unmarshal(m, b)
}
func (m *LogSegment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LogSegment.Marshal(b, m, deterministic)
}
func (m *LogSegment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogSegment.Merge(m, src)
}
func (m *LogSegment) XXX_Size() int {
	return xxx_messageInfo_LogSegment.Size(m)
}
func (m *LogSegment) XXX_DiscardUnknown() {
	xxx_messageInfo_LogSegment.DiscardUnknown(m)
}

var xxx_messageInfo_LogSegment proto.InternalMessageInfo

func (m *LogSegment) GetSpanId() string {
	if m != nil {
		return m.SpanId
	}
	return ""
}

func (m *LogSegment) GetTime() *timestamp.Timestamp {
	if m != nil {
		return m.Time
	}
	return nil
}

func (m *LogSegment) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *LogSegment) GetLevel() LogLevel {
	if m != nil {
		return m.Level
	}
	return LogLevel_NONE
}

type LogSpan struct {
	ManifestName         string   `protobuf:"bytes,1,opt,name=manifest_name,json=manifestName,proto3" json:"manifest_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LogSpan) Reset()         { *m = LogSpan{} }
func (m *LogSpan) String() string { return proto.CompactTextString(m) }
func (*LogSpan) ProtoMessage()    {}
func (*LogSpan) Descriptor() ([]byte, []int) {
	return fileDescriptor_3da405ef8c289d22, []int{1}
}

func (m *LogSpan) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LogSpan.Unmarshal(m, b)
}
func (m *LogSpan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LogSpan.Marshal(b, m, deterministic)
}
func (m *LogSpan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogSpan.Merge(m, src)
}
func (m *LogSpan) XXX_Size() int {
	return xxx_messageInfo_LogSpan.Size(m)
}
func (m *LogSpan) XXX_DiscardUnknown() {
	xxx_messageInfo_LogSpan.DiscardUnknown(m)
}

var xxx_messageInfo_LogSpan proto.InternalMessageInfo

func (m *LogSpan) GetManifestName() string {
	if m != nil {
		return m.ManifestName
	}
	return ""
}

type LogList struct {
	Spans    map[string]*LogSpan `protobuf:"bytes,1,rep,name=spans,proto3" json:"spans,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Segments []*LogSegment       `protobuf:"bytes,2,rep,name=segments,proto3" json:"segments,omitempty"`
	// from_checkpoint and to_checkpoint express an interval on the
	// central log-store, with an inclusive start and an exclusive end
	//
	// [from_checkpoint, to_checkpoint)
	//
	// An interval of [0, 0) means that the server isn't using
	// the incremental load protocol.
	//
	// An interval of [-1, -1) means that the server doesn't have new logs
	// to send down.
	FromCheckpoint       int32    `protobuf:"varint,3,opt,name=from_checkpoint,json=fromCheckpoint,proto3" json:"from_checkpoint,omitempty"`
	ToCheckpoint         int32    `protobuf:"varint,4,opt,name=to_checkpoint,json=toCheckpoint,proto3" json:"to_checkpoint,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LogList) Reset()         { *m = LogList{} }
func (m *LogList) String() string { return proto.CompactTextString(m) }
func (*LogList) ProtoMessage()    {}
func (*LogList) Descriptor() ([]byte, []int) {
	return fileDescriptor_3da405ef8c289d22, []int{2}
}

func (m *LogList) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LogList.Unmarshal(m, b)
}
func (m *LogList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LogList.Marshal(b, m, deterministic)
}
func (m *LogList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogList.Merge(m, src)
}
func (m *LogList) XXX_Size() int {
	return xxx_messageInfo_LogList.Size(m)
}
func (m *LogList) XXX_DiscardUnknown() {
	xxx_messageInfo_LogList.DiscardUnknown(m)
}

var xxx_messageInfo_LogList proto.InternalMessageInfo

func (m *LogList) GetSpans() map[string]*LogSpan {
	if m != nil {
		return m.Spans
	}
	return nil
}

func (m *LogList) GetSegments() []*LogSegment {
	if m != nil {
		return m.Segments
	}
	return nil
}

func (m *LogList) GetFromCheckpoint() int32 {
	if m != nil {
		return m.FromCheckpoint
	}
	return 0
}

func (m *LogList) GetToCheckpoint() int32 {
	if m != nil {
		return m.ToCheckpoint
	}
	return 0
}

func init() {
	proto.RegisterEnum("webview.LogLevel", LogLevel_name, LogLevel_value)
	proto.RegisterType((*LogSegment)(nil), "webview.LogSegment")
	proto.RegisterType((*LogSpan)(nil), "webview.LogSpan")
	proto.RegisterType((*LogList)(nil), "webview.LogList")
	proto.RegisterMapType((map[string]*LogSpan)(nil), "webview.LogList.SpansEntry")
}

func init() { proto.RegisterFile("pkg/webview/log.proto", fileDescriptor_3da405ef8c289d22) }

var fileDescriptor_3da405ef8c289d22 = []byte{
	// 424 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x54, 0x52, 0x4d, 0x8f, 0xd3, 0x30,
	0x10, 0x25, 0x69, 0xb2, 0xed, 0x4e, 0x97, 0x25, 0x18, 0x21, 0xa2, 0x72, 0xa0, 0x2a, 0x12, 0x2d,
	0x1c, 0x1c, 0x51, 0x24, 0x84, 0x38, 0x16, 0x02, 0x5a, 0x54, 0xb5, 0x52, 0x16, 0x38, 0x70, 0xa9,
	0x92, 0xd6, 0xf5, 0x5a, 0xf5, 0x47, 0x54, 0xbb, 0x2d, 0xfb, 0x0b, 0xb8, 0xf3, 0x8b, 0x57, 0x76,
	0x92, 0xdd, 0xf6, 0x36, 0x7e, 0xf3, 0xde, 0xf3, 0x9b, 0xb1, 0xe1, 0x79, 0xb9, 0xa1, 0xc9, 0x81,
	0x14, 0x7b, 0x46, 0x0e, 0x09, 0x57, 0x14, 0x97, 0x5b, 0x65, 0x14, 0x6a, 0xd7, 0x50, 0xef, 0x15,
	0x55, 0x8a, 0x72, 0x92, 0x38, 0xb8, 0xd8, 0xad, 0x13, 0xc3, 0x04, 0xd1, 0x26, 0x17, 0x65, 0xc5,
	0x1c, 0xfc, 0xf7, 0x00, 0xa6, 0x8a, 0x5e, 0x13, 0x2a, 0x88, 0x34, 0xe8, 0x05, 0xb4, 0x75, 0x99,
	0xcb, 0x05, 0x5b, 0xc5, 0x5e, 0xdf, 0x1b, 0x9d, 0x67, 0x67, 0xf6, 0x78, 0xb5, 0x42, 0x18, 0x02,
	0x2b, 0x8d, 0xfd, 0xbe, 0x37, 0xea, 0x8e, 0x7b, 0xb8, 0xf2, 0xc5, 0x8d, 0x2f, 0xfe, 0xd9, 0xf8,
	0x66, 0x8e, 0x87, 0x10, 0x04, 0x86, 0xfc, 0x35, 0x71, 0xcb, 0xb9, 0xb8, 0x1a, 0x0d, 0x21, 0xe4,
	0x64, 0x4f, 0x78, 0x1c, 0xf4, 0xbd, 0xd1, 0xe5, 0xf8, 0x29, 0xae, 0x53, 0xe2, 0xa9, 0xa2, 0x53,
	0xdb, 0xc8, 0xaa, 0xfe, 0x00, 0x43, 0xdb, 0x66, 0x2a, 0x73, 0x89, 0x5e, 0xc3, 0x63, 0x91, 0x4b,
	0xb6, 0x26, 0xda, 0x2c, 0x64, 0x2e, 0x48, 0x1d, 0xeb, 0xa2, 0x01, 0x67, 0xb9, 0x20, 0x83, 0x7f,
	0xbe, 0x13, 0x4c, 0x99, 0x36, 0xe8, 0x3d, 0x84, 0x36, 0xb2, 0x8e, 0xbd, 0x7e, 0x6b, 0xd4, 0x1d,
	0xbf, 0x3c, 0xb9, 0x84, 0x69, 0x83, 0xad, 0xad, 0x4e, 0xa5, 0xd9, 0xde, 0x66, 0x15, 0x13, 0x25,
	0xd0, 0xd1, 0xd5, 0xfc, 0x3a, 0xf6, 0x9d, 0xea, 0xd9, 0xb1, 0xaa, 0xde, 0x4d, 0x76, 0x4f, 0x42,
	0x43, 0x78, 0xb2, 0xde, 0x2a, 0xb1, 0x58, 0xde, 0x90, 0xe5, 0xa6, 0x54, 0x4c, 0x56, 0x73, 0x86,
	0xd9, 0xa5, 0x85, 0xbf, 0xdc, 0xa3, 0x36, 0xbd, 0x51, 0xc7, 0xb4, 0xc0, 0xd1, 0x2e, 0x8c, 0x7a,
	0x20, 0xf5, 0x7e, 0x00, 0x3c, 0x64, 0x42, 0x11, 0xb4, 0x36, 0xe4, 0xb6, 0x1e, 0xd3, 0x96, 0xe8,
	0x0d, 0x84, 0xfb, 0x9c, 0xef, 0x9a, 0xdd, 0x47, 0x27, 0xd9, 0xca, 0x5c, 0x66, 0x55, 0xfb, 0xb3,
	0xff, 0xc9, 0x7b, 0xf7, 0x11, 0x3a, 0xcd, 0x32, 0x51, 0x07, 0x82, 0xd9, 0x7c, 0x96, 0x46, 0x8f,
	0x6c, 0x75, 0x35, 0xfb, 0x36, 0x8f, 0x3c, 0xd4, 0x85, 0xf6, 0xef, 0x34, 0x9b, 0xcc, 0xaf, 0xd3,
	0xc8, 0x47, 0xe7, 0x10, 0x7e, 0x4d, 0x27, 0xbf, 0xbe, 0x47, 0xad, 0xc9, 0xdb, 0x3f, 0x43, 0xca,
	0xcc, 0xcd, 0xae, 0xc0, 0x4b, 0x25, 0x92, 0x03, 0x93, 0x2b, 0xc1, 0x38, 0x27, 0x92, 0x26, 0x86,
	0x71, 0x93, 0x1c, 0xfd, 0xb2, 0xe2, 0xcc, 0xbd, 0xf9, 0x87, 0xbb, 0x00, 0x00, 0x00, 0xff, 0xff,
	0x12, 0xd4, 0x20, 0xaa, 0x7b, 0x02, 0x00, 0x00,
}

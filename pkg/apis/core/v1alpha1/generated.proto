/*
Copyright 2020 The Tilt Dev Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// This file was autogenerated by go-to-protobuf. Do not edit it manually!

syntax = "proto2";

package github.com.tilt_dev.tilt.pkg.apis.core.v1alpha1;

import "k8s.io/apimachinery/pkg/apis/meta/v1/generated.proto";
import "k8s.io/apimachinery/pkg/runtime/schema/generated.proto";

// Package-wide variables from generator "generated".
option go_package = "v1alpha1";

// Cluster defines any runtime for running containers, in the broadest
// sense of the word "runtime".
//
// +k8s:openapi-gen=true
message Cluster {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional ClusterSpec spec = 2;

  optional ClusterStatus status = 3;
}

// Connection spec for an existing cluster.
message ClusterConnection {
  // Defines connection to a Kubernetes cluster.
  optional KubernetesClusterConnection kubernetes = 1;

  // Defines connection to a Docker daemon.
  optional DockerClusterConnection docker = 2;
}

// ClusterList
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message ClusterList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated Cluster items = 2;
}

// ClusterSpec defines how to find the cluster we're running
// containers on.
//
// Tilt currently supports connecting to an existing Kubernetes
// cluster or an existing Docker Daemon (for Docker Compose).
message ClusterSpec {
  // Connection spec for an existing cluster.
  optional ClusterConnection connection = 1;
}

// ClusterStatus defines the observed state of Cluster
message ClusterStatus {
  // The preferred chip architecture of the cluster.
  //
  // On Kubernetes, this will correspond to the kubernetes.io/arch annotation on
  // a node.
  //
  // On Docker, this will be the Architecture of the Docker daemon.
  //
  // Note that many clusters support multiple chipsets. This field doesn't intend
  // that this is the only architecture a cluster supports, only that it's one
  // of the architectures.
  optional string arch = 1;

  // An unrecoverable error connecting to the cluster.
  //
  // +optional
  optional string error = 2;

  // ConnectedAt indicates the time at which the cluster connection was established.
  //
  // Consumers can use this to detect when the underlying config has changed
  // and refresh their client/connection accordingly.
  //
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime connectedAt = 3;

  // Registry describes a local registry that developer tools can
  // connect to. A local registry allows clients to load images into the local
  // cluster by pushing to this registry.
  //
  // +optional
  optional RegistryHosting registry = 4;
}

// Cmd represents a process on the host machine.
//
// When the process exits, we will make a best-effort attempt
// (within OS limitations) to kill any spawned descendant processes.
//
// +k8s:openapi-gen=true
// +tilt:starlark-gen=true
message Cmd {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional CmdSpec spec = 2;

  optional CmdStatus status = 3;
}

// CmdImage describes an image to build with an arbitrary shell command.
// +k8s:openapi-gen=true
message CmdImage {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional CmdImageSpec spec = 2;

  optional CmdImageStatus status = 3;
}

// CmdImageList
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message CmdImageList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated CmdImage items = 2;
}

// CmdImageSpec describes how the custom script builds images and where it puts them.
message CmdImageSpec {
  // The named reference of the image.
  optional string ref = 7;

  // Command-line arguments. Must have length at least 1.
  repeated string args = 1;

  // Process working directory.
  //
  // If the working directory is not specified, the command is run
  // in the default Tilt working directory.
  //
  // +optional
  // +tilt:local-path=true
  optional string dir = 2;

  // Names of image maps that this build depends on.
  //
  // The controller will watch all the image maps, and rebuild the image
  // if any of the maps resolve to a new image.
  //
  // +optional
  repeated string imageMaps = 3;

  // Specifies where the image is built. If not specified, we assume the image
  // was built to the local Docker image store.
  optional string outputMode = 4;

  // Tag we expect the image to be built with (we use this to check that
  // the expected image+tag has been created).
  //
  // If empty, we create an expected tag at the beginning of CustomBuild (and
  // export $EXPECTED_REF=name:expected_tag )
  //
  // +optional
  optional string outputTag = 5;

  // Specifies a filepath where the cmd script prints the result image ref.
  //
  // Tilt will read it out when we're done to find the image.
  //
  // +optional
  // +tilt:local-path=true
  optional string outputsImageRefTo = 6;
}

// CmdImageStateBuilding expresses that an image build is in-progress.
message CmdImageStateBuilding {
  // The reason why the image is building.
  // +optional
  optional string reason = 1;

  // Time when the build started.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime startedAt = 2;
}

// CmdImageStateCompleted expresses when the image build is finished and
// no new images need to be built.
message CmdImageStateCompleted {
  // The reason why the image was built.
  // +optional
  optional string reason = 1;

  // Error message if the build failed.
  // +optional
  optional string error = 2;

  // Time when we started building an image.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime startedAt = 3;

  // Time when we finished building an image
  optional k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime finishedAt = 4;
}

// CmdImageStateWaiting expresses what we're waiting on to build an image.
message CmdImageStateWaiting {
  // (brief) reason the image build is waiting.
  // +optional
  optional string reason = 1;
}

// CmdImageStatus describes the result of the image build.
message CmdImageStatus {
  // A fully-qualified image reference of a built image, as seen from the local
  // network.
  //
  // Usually includes a name and an immutable tag.
  //
  // NB: If we're building to a particular registry, this may
  // have a different hostname from the Spec `Ref` field.
  //
  // +optional
  optional string ref = 1;

  // Details about a waiting image build.
  // +optional
  optional CmdImageStateWaiting waiting = 2;

  // Details about a building image.
  // +optional
  optional CmdImageStateBuilding building = 3;

  // Details about a finished image build.
  // +optional
  optional CmdImageStateCompleted completed = 4;
}

// CmdList
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message CmdList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated Cmd items = 2;
}

// CmdSpec defines how to run a local command.
message CmdSpec {
  // Command-line arguments. Must have length at least 1.
  repeated string args = 1;

  // Process working directory.
  //
  // If the working directory is not specified, the command is run
  // in the default Tilt working directory.
  //
  // +optional
  // +tilt:local-path=true
  optional string dir = 2;

  // Additional variables process environment.
  //
  // Expressed as a C-style array of strings of the form ["KEY1=VALUE1", "KEY2=VALUE2", ...].
  //
  // Environment variables are layered on top of the environment variables
  // that Tilt runs with.
  //
  // +optional
  repeated string env = 3;

  // Periodic probe of service readiness.
  //
  // +optional
  optional Probe readinessProbe = 4;

  // Indicates objects that can trigger a restart of this command.
  //
  // When a restart is triggered, Tilt will try to gracefully shutdown any
  // currently running process, waiting for it to exit before starting a new
  // process. If the process doesn't shutdown within the allotted time, Tilt
  // will kill the process abruptly.
  //
  // Restarts can happen even if the command is already done.
  //
  // Logs of the current process after the restart are discarded.
  optional RestartOnSpec restartOn = 5;

  // Indicates objects that can trigger a start/restart of this command.
  //
  // Restarts behave the same as RestartOn. The key difference is that
  // a Cmd with any StartOn triggers will not have its command run until its
  // StartOn is satisfied.
  optional StartOnSpec startOn = 6;

  // Specifies how to disable this.
  //
  // +optional
  optional DisableSource disableSource = 7;
}

// CmdStateRunning is a running state of a local command.
message CmdStateRunning {
  // The process id of the command.
  optional int32 pid = 1;

  // Time at which the command was last started.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime startedAt = 2;
}

// CmdStateTerminated is a terminated state of a local command.
message CmdStateTerminated {
  // The process id of the command.
  optional int32 pid = 1;

  // Exit status from the last termination of the command
  optional int32 exitCode = 2;

  // Time at which previous execution of the command started
  optional k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime startedAt = 3;

  // Time at which the command last terminated
  optional k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime finishedAt = 4;

  // (brief) reason the process is terminated
  // +optional
  optional string reason = 5;
}

// CmdStateWaiting is a waiting state of a local command.
message CmdStateWaiting {
  // (brief) reason the process is not yet running.
  // +optional
  optional string reason = 1;
}

// CmdStatus defines the observed state of Cmd
//
// Based loosely on ContainerStatus in Kubernetes
message CmdStatus {
  // Details about a waiting process.
  // +optional
  optional CmdStateWaiting waiting = 1;

  // Details about a running process.
  // +optional
  optional CmdStateRunning running = 2;

  // Details about a terminated process.
  // +optional
  optional CmdStateTerminated terminated = 3;

  // Specifies whether the command has passed its readiness probe.
  //
  // Terminating the command does not change its Ready state.
  //
  // Is always true when no readiness probe is defined.
  //
  // +optional
  optional bool ready = 4;

  // Details about whether/why this is disabled.
  // +optional
  optional DisableStatus disableStatus = 5;
}

// ConfigMap stores unstructured data that other controllers can read and write.
//
// Useful for sharing data from one system and subscribing to it from another.
//
// +k8s:openapi-gen=true
// +tilt:starlark-gen=true
message ConfigMap {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  // Data contains the configuration data.
  // Each key must consist of alphanumeric characters, '-', '_' or '.'.
  // +optional
  map<string, string> data = 2;
}

// Specifies a ConfigMap to control a DisableSource
message ConfigMapDisableSource {
  // The name of the ConfigMap
  optional string name = 1;

  // The key where the enable/disable state is stored.
  optional string key = 2;
}

// ConfigMapList
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message ConfigMapList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated ConfigMap items = 2;
}

// Describes how a ToggleButton's state is stored in a ConfigMap.
// The ConfigMap must be created separately - the ToggleButton will not automatically create it.
message ConfigMapStateSource {
  // Name of the ConfigMap
  optional string name = 1;

  // Key within the ConfigMap
  optional string key = 2;

  // ConfigMap value corresponding to the button's "on" state.
  // If not specified, "true" will be used.
  // +optional
  optional string onValue = 3;

  // ConfigMap value corresponding to the button's "off" state
  // If not specified, "false" will be used.
  optional string offValue = 4;
}

// Container is an init or application container within a pod.
//
// The Tilt API representation mirrors the Kubernetes API very closely. Irrelevant data is
// not included, and some fields might be simplified.
//
// There might also be Tilt-specific status fields.
message Container {
  // Name is the name of the container as defined in Kubernetes.
  optional string name = 1;

  // ID is the normalized container ID (the `docker://` prefix is stripped).
  optional string id = 2;

  // Ready is true if the container is passing readiness checks (or has none defined).
  optional bool ready = 3;

  // Image is the image the container is running.
  optional string image = 4;

  // Restarts is the number of times the container has restarted.
  //
  // This includes restarts before the Tilt daemon was started if the container was already running.
  optional int32 restarts = 5;

  // State provides details about the container's current condition.
  optional ContainerState state = 6;

  // Ports are exposed ports as extracted from the Pod spec.
  //
  // This is added by Tilt for convenience when managing port forwards.
  repeated int32 ports = 7;
}

// ContainerLogStreamStatus defines the current status of each individual
// container log stream.
message ContainerLogStreamStatus {
  // The name of the container.
  optional string name = 1;

  // True when the stream is set up and streaming logs properly.
  //
  // +optional
  optional bool active = 2;

  // True when the logs are done stream and the container is terminated.
  //
  // +optional
  optional bool terminated = 3;

  // The last error message encountered while streaming.
  //
  // Empty when the stream is actively streaming or successfully terminated.
  //
  // +optional
  optional string error = 4;
}

// ContainerState holds a possible state of container.
//
// Only one of its members may be specified.
// If none of them is specified, the default one is ContainerStateWaiting.
message ContainerState {
  // Waiting provides details about a container that is not yet running.
  optional ContainerStateWaiting waiting = 1;

  // Running provides details about a currently executing container.
  optional ContainerStateRunning running = 2;

  // Terminated provides details about an exited container.
  optional ContainerStateTerminated terminated = 3;
}

// ContainerStateRunning is a running state of a container.
message ContainerStateRunning {
  // StartedAt is the time the container began running.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time startedAt = 1;
}

// ContainerStateTerminated is a terminated state of a container.
message ContainerStateTerminated {
  // StartedAt is the time the container began running.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time startedAt = 1;

  // FinishedAt is the time the container stopped running.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time finishedAt = 2;

  // Reason is a (brief) reason the container stopped running.
  optional string reason = 3;

  // ExitCode is the exit status from the termination of the container.
  //
  // Any non-zero value indicates an error during termination.
  optional int32 exitCode = 4;
}

// ContainerStateWaiting is a waiting state of a container.
message ContainerStateWaiting {
  // Reason is a (brief) reason the container is not yet running.
  optional string reason = 1;
}

// Aggregated disable status of DisableSources that belong to a resource.
message DisableResourceStatus {
  // How many of the resource's sources are enabled.
  optional int32 enabledCount = 1;

  // How many of the resource's sources are disabled.
  optional int32 disabledCount = 2;

  // Whether this is currently disabled (if known)
  optional string state = 4;

  // All unique sources that control the resource's objects' disable status.
  repeated DisableSource sources = 3;
}

// Points at a thing that can control whether something is disabled
message DisableSource {
  // This DisableSource is controlled by a ConfigMap
  optional ConfigMapDisableSource configMap = 2;
}

message DisableStatus {
  // Whether this is currently disabled. Deprecated in favor of `State`.
  optional bool disabled = 1;

  // The last time this status was updated.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastUpdateTime = 2;

  // The reason this status was updated.
  optional string reason = 3;

  // Whether this is currently disabled (if known)
  optional string state = 4;
}

message DockerClusterConnection {
  // The docker host to use.
  //
  // If not specified, will read the DOCKER_HOST env or use the default docker
  // host.
  optional string host = 1;
}

message DockerComposeProject {
  // Configuration files to load.
  //
  // If both ConfigPaths and ProjectPath/YAML are specified,
  // the YAML is the source of truth, and the ConfigPaths
  // are used to print diagnostic information.
  repeated string configPaths = 1;

  // The base path of the docker-compose project.
  //
  // Expressed in docker-compose as --project-directory.
  //
  // When used on the command-line, the Docker Compose spec mandates that this
  // must be the directory of the first yaml file.  All additional yaml files are
  // evaluated relative to this project path.
  optional string projectPath = 2;

  // The docker-compose config YAML.
  //
  // Usually contains multiple services.
  //
  // If you have multiple docker-compose.yaml files, you can combine them into a
  // single YAML with `docker-compose -f file1.yaml -f file2.yaml config`.
  optional string yaml = 3;

  // The docker-compose project name.
  //
  // If omitted, the default is to use the NormalizedName of the ProjectPath
  // base name.
  optional string name = 4;

  // Path to an env file to use. Passed to docker-compose as `--env-file FILE`.
  optional string envFile = 5;
}

// DockerComposeService represents a container orchestrated by Docker Compose.
//
// +k8s:openapi-gen=true
message DockerComposeService {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional DockerComposeServiceSpec spec = 2;

  optional DockerComposeServiceStatus status = 3;
}

// DockerComposeServiceList
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message DockerComposeServiceList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated DockerComposeService items = 2;
}

// DockerComposeServiceSpec defines the desired state a Docker Compose container.
message DockerComposeServiceSpec {
  // The name of the service to create.
  optional string service = 1;

  // A specification of the project the service belongs to.
  //
  // Each service spec keeps its own copy of the project spec.
  optional DockerComposeProject project = 2;

  // The image maps that this deploy depends on.
  repeated string imageMaps = 3;

  // Specifies how to disable this.
  //
  // +optional
  optional DisableSource disableSource = 4;
}

// DockerComposeServiceStatus defines the observed state of DockerComposeService,
// continuing to watch the container after it starts.
message DockerComposeServiceStatus {
  // Details about whether/why this is disabled.
  // +optional
  optional DisableStatus disableStatus = 1;

  // How docker binds container ports to the host network for this service.
  // +optional
  repeated DockerPortBinding portBindings = 2;

  // Current state of the container for this service.
  // +optional
  optional DockerContainerState containerState = 3;

  // Current container ID.
  // +optional
  optional string containerID = 4;

  // Current container name.
  // +optional
  optional string containerName = 8;

  // An error bringing up the container.
  //
  // +optional
  optional string applyError = 5;

  // Timestamp of when we last started bringing up this service in Docker Compose.
  //
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime lastApplyStartTime = 6;

  // Timestamp of when we last finished bringing up this service in Docker Compose.
  //
  // When populated, must be equal or after the LastApplyStartTime field.
  //
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime lastApplyFinishTime = 7;
}

// State of a standalone container in Docker.
//
// An apiserver-compatible representation of this struct:
// https://pkg.go.dev/github.com/docker/docker/api/types#ContainerState
message DockerContainerState {
  // String representation of the container state.
  // Can be one of "created", "running", "paused", "restarting", "removing", "exited", or "dead".
  // +optional
  optional string status = 1;

  // Whether the container is running.
  // +optional
  optional bool running = 2;

  // Whether the container is in an error state.
  // +optional
  optional string error = 3;

  // The exit code, if the container has exited.
  // +optional
  optional int32 exitCode = 4;

  // When the container process started.
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime startedAt = 5;

  // When the container process finished.
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime finishedAt = 6;
}

// DockerImage describes an image to build with Docker.
// +k8s:openapi-gen=true
message DockerImage {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional DockerImageSpec spec = 2;

  optional DockerImageStatus status = 3;
}

// DockerImageList
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message DockerImageList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated DockerImage items = 2;
}

// DockerImageSpec describes how to build a Docker image with `docker_build`.
//
// Most fields of this spec directly correspond to the Docker CLI.
message DockerImageSpec {
  // The named reference of the image.
  optional string ref = 12;

  // Dockerfile contains the complete contents of the Dockerfile.
  //
  // TODO(nick): We should also support referencing the Dockerfile as a path.
  //
  // +optional
  optional string dockerfileContents = 1;

  // Context specifies the Docker build context.
  //
  // Must be an absolute path on the local filesystem.
  //
  // +tilt:local-path=true
  optional string context = 2;

  // Args specifies the build arguments to the Dockerfile.
  //
  // Equivalent to `--build-arg` in the docker CLI.
  //
  // Each item should take the form "KEY" or "KEY=VALUE".
  //
  // +optional
  repeated string args = 3;

  // Target specifies the name of the stage in the Dockerfile to build.
  //
  // Equivalent to `--target` in the docker CLI.
  //
  // +optional
  optional string target = 4;

  // Pass SSH secrets to docker so it can clone private repos.
  //
  // https://docs.docker.com/develop/develop-images/build_enhancements/#using-ssh-to-access-private-data-in-builds
  //
  // Equivalent to `--ssh` in the docker CLI.
  //
  // +optional
  repeated string sshAgentConfigs = 5;

  // Pass secrets to docker.
  //
  // https://docs.docker.com/develop/develop-images/build_enhancements/#new-docker-build-secret-information
  //
  // Equivalent to `--secret` in the Docker CLI.
  //
  // +optional
  repeated string secrets = 6;

  // Set the networking mode for the RUN instructions in the docker build.
  //
  // Equivalent to `--network` in the Docker CLI.
  //
  // +optional
  optional string network = 7;

  // Always attempt to pull a new version of the base image.
  //
  // Equivalent to `--pull` in the Docker CLI.
  //
  // +optional
  optional bool pull = 8;

  // Images to use as cache sources.
  //
  // Equivalent to `--cache-from` in the Docker CLI.
  repeated string cacheFrom = 9;

  // Platform specifies architecture information for target image.
  //
  // https://docs.docker.com/desktop/multi-arch/
  //
  // Equivalent to `--platform` in the Docker CLI.
  optional string platform = 10;

  // By default, Tilt creates a new temporary image reference for each build.
  // The user can also specify their own reference, to integrate with other tooling
  // (like build IDs for Jenkins build pipelines)
  //
  // Equivalent to the docker build --tag flag.
  //
  // +optional
  repeated string extraTags = 11;

  // Names of image maps that this build depends on.
  //
  // The controller will watch all the image maps, rebuild the image if any of
  // the maps resolve to a new image, and inject them into the dockerfile.
  //
  // +optional
  repeated string imageMaps = 13;
}

// DockerImageStageStatus gives detailed report of each stage
// of the most recent image build.
//
// Most stages are derived from Buildkit's StatusResponse
// https://github.com/moby/buildkit/blob/35fcb28a009d6454b2915a5c8084b25ad851cf38/api/services/control/control.proto#L108
// but Tilt may synthesize its own stages for the steps it
// owns.
//
// Stages may be executed in parallel.
message DockerImageStageStatus {
  // A human-readable name of the stage.
  optional string name = 1;

  // Whether Buildkit was able to cache the stage based on inputs.
  // +optional
  optional bool cached = 2;

  // The timestamp when we started working on the stage.
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime startedAt = 6;

  // The timetsamp when we completed the work on the stage.
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime finishedAt = 7;

  // Error message if the stage failed. If empty, the stage succeeded.
  // +optional
  optional string error = 5;
}

// DockerImageStateBuilding expresses that an image build is in-progress.
message DockerImageStateBuilding {
  // The reason why the image is building.
  // +optional
  optional string reason = 1;

  // Time when the build started.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime startedAt = 2;
}

// DockerImageStateCompleted expresses when the image build is finished and
// no new images need to be built.
message DockerImageStateCompleted {
  // The reason why the image was built.
  // +optional
  optional string reason = 1;

  // Error message if the build failed.
  // +optional
  optional string error = 2;

  // Time when we started building an image.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime startedAt = 3;

  // Time when we finished building an image
  optional k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime finishedAt = 4;
}

// DockerImageStateWaiting expresses what we're waiting on to build an image.
message DockerImageStateWaiting {
  // (brief) reason the image build is waiting.
  // +optional
  optional string reason = 1;
}

// DockerImageStatus defines the observed state of DockerImage
message DockerImageStatus {
  // A fully-qualified image reference of a built image, as seen from the local
  // network.
  //
  // Usually includes a name and an immutable tag.
  //
  // NB: If we're building to a particular registry, this may
  // have a different hostname from the Spec `Ref` field.
  //
  // +optional
  optional string ref = 1;

  // Details about a waiting image build.
  // +optional
  optional DockerImageStateWaiting waiting = 2;

  // Details about a building image.
  // +optional
  optional DockerImageStateBuilding building = 3;

  // Details about a finished image build.
  // +optional
  optional DockerImageStateCompleted completed = 4;

  // Status information about each individual build stage
  // of the most recent image build.
  repeated DockerImageStageStatus stageStatuses = 5;
}

// How docker binds container ports to the host network
message DockerPortBinding {
  // The port inside the container.
  optional int32 containerPort = 1;

  // The port on the host machine where Docker running.
  optional int32 hostPort = 2;

  // The IP on the host machine where Docker is binding the network.
  optional string hostIP = 3;
}

// ExecAction describes a "run in container" action.
message ExecAction {
  // Command is the command line to execute inside the container, the working directory for the
  // command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
  // not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
  // a shell, you need to explicitly call out to that shell.
  // Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
  // +optional
  repeated string command = 1;
}

// Extension defines an extension that's evaluated on Tilt startup.
// +k8s:openapi-gen=true
// +tilt:starlark-gen=true
message Extension {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional ExtensionSpec spec = 2;

  optional ExtensionStatus status = 3;
}

// ExtensionList
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message ExtensionList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated Extension items = 2;
}

// ExtensionRepo specifies a repo or folder where a set of extensions live.
// +k8s:openapi-gen=true
// +tilt:starlark-gen=true
message ExtensionRepo {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional ExtensionRepoSpec spec = 2;

  optional ExtensionRepoStatus status = 3;
}

// ExtensionRepoList
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message ExtensionRepoList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated ExtensionRepo items = 2;
}

// ExtensionRepoSpec defines how to access the repo.
message ExtensionRepoSpec {
  // The URL of the repo.
  //
  // Allowed:
  // https: URLs that point to a public git repo
  // file: URLs that point to a location on disk.
  optional string url = 1;

  // A reference to sync the repo to. If empty, Tilt will always update
  // the repo to the latest version.
  // +optional
  optional string ref = 2;
}

// ExtensionRepoStatus defines the observed state of ExtensionRepo
message ExtensionRepoStatus {
  // Contains information about any problems loading the repo.
  optional string error = 1;

  // The last time the repo was fetched and checked for validity.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastFetchedAt = 2;

  // The path to the repo on local disk.
  optional string path = 3;

  // The reference that we currently have checked out.
  // On git, this is the commit hash.
  // On file repos, this is empty.
  optional string checkoutRef = 4;
}

// ExtensionSpec defines the desired state of Extension
message ExtensionSpec {
  // RepoName specifies the ExtensionRepo object where we should find this extension.
  //
  // The Extension controller should watch for changes to this repo, and
  // may update if this repo is deleted or moved.
  optional string repoName = 1;

  // RepoPath specifies the path to the extension directory inside the repo.
  //
  // Once the repo is downloaded, this path should point to a directory with a
  // Tiltfile as the main "entrypoint" of the extension.
  optional string repoPath = 2;

  // Arguments to the Tiltfile loaded by this extension.
  //
  // Arguments can be positional (['a', 'b', 'c']) or flag-based ('--to-edit=a').
  // By default, a list of arguments indicates the list of services in the tiltfile
  // that should be enabled.
  //
  // +optional
  repeated string args = 3;
}

// ExtensionStatus defines the observed state of Extension
message ExtensionStatus {
  // Contains information about any problems loading the extension.
  optional string error = 1;

  // The path to the extension on disk. This location should be shared
  // and readable by all Tilt instances.
  optional string path = 2;
}

message FileEvent {
  // Time is an approximate timestamp for a batch of file changes.
  //
  // This will NOT exactly match any inode attributes (e.g. ctime, mtime) at the filesystem level and is purely
  // informational or for use as an opaque watermark.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime time = 1;

  // SeenFiles is a list of paths which changed (create, modify, or delete).
  repeated string seenFiles = 2;
}

// FileWatch
// +k8s:openapi-gen=true
// +tilt:starlark-gen=true
message FileWatch {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional FileWatchSpec spec = 2;

  optional FileWatchStatus status = 3;
}

// FileWatchList
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message FileWatchList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated FileWatch items = 2;
}

// FileWatchSpec defines the desired state of FileWatch
message FileWatchSpec {
  // WatchedPaths are paths of directories or files to watch for changes to. It cannot be empty.
  //
  // +tilt:local-path=true
  repeated string watchedPaths = 1;

  // Ignores are optional rules to filter out a subset of changes matched by WatchedPaths.
  repeated IgnoreDef ignores = 2;

  // Specifies how to disable this.
  //
  // +optional
  optional DisableSource disableSource = 3;
}

// FileWatchStatus defines the observed state of FileWatch
message FileWatchStatus {
  // MonitorStartTime is the timestamp of when filesystem monitor was started. It is zero if the monitor has not
  // been started yet.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime monitorStartTime = 1;

  // LastEventTime is the timestamp of the most recent file event. It is zero if no events have been seen yet.
  //
  // If the specifics of which files changed are not important, this field can be used as a watermark without
  // needing to inspect FileEvents.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime lastEventTime = 2;

  // FileEvents summarizes batches of file changes (create, modify, or delete) that have been seen in ascending
  // chronological order. Only the most recent 20 events are included.
  repeated FileEvent fileEvents = 3;

  // Error is set if there is a problem with the filesystem watch. If non-empty, consumers should assume that
  // no filesystem events will be seen and that the file watcher is in a failed state.
  optional string error = 4;

  // Details about whether/why this is disabled.
  // +optional
  optional DisableStatus disableStatus = 5;
}

// Forward defines a port forward to execute on a given pod.
message Forward {
  // The port to expose on the current machine.
  //
  // If not specified (or 0), a random free port will be chosen and can
  // be discovered via the status once established.
  //
  // +optional
  optional int32 localPort = 4;

  // The port on the Kubernetes pod to connect to. Required.
  optional int32 containerPort = 3;

  // Optional host to bind to on the current machine (localhost by default)
  //
  // +optional
  optional string host = 5;

  // Name to identify this port forward.
  //
  // +optional
  optional string name = 6;

  // Path to include as part of generated links for port forward.
  //
  // +optional
  optional string path = 7;
}

message ForwardStatus {
  // LocalPort is the port bound to on the system running Tilt.
  optional int32 localPort = 1;

  // ContainerPort is the port in the container being forwarded.
  optional int32 containerPort = 2;

  // Addresses that the forwarder is bound to.
  //
  // For example, a `localhost` host will bind to 127.0.0.1 and [::1].
  repeated string addresses = 3;

  // StartedAt is the time at which the forward was initiated.
  //
  // If the forwarder is not running yet, this will be zero/empty.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime startedAt = 4;

  // Error is a human-readable description if a problem was encountered
  // while initializing the forward.
  optional string error = 5;
}

// HTTPGetAction describes an action based on HTTP Get requests.
message HTTPGetAction {
  // Path to access on the HTTP server.
  // +optional
  optional string path = 1;

  // Name or number of the port to access on the container.
  // Number must be in the range 1 to 65535.
  optional int32 port = 2;

  // Host name to connect to, defaults to the pod IP. You probably want to set
  // "Host" in httpHeaders instead.
  // +optional
  optional string host = 3;

  // Scheme to use for connecting to the host.
  // Defaults to HTTP.
  // +optional
  optional string scheme = 4;

  // Custom headers to set in the request. HTTP allows repeated headers.
  // +optional
  repeated HTTPHeader httpHeaders = 5;
}

// HTTPHeader describes a custom header to be used in HTTP probes
message HTTPHeader {
  // The header field name
  optional string name = 1;

  // The header field value
  optional string value = 2;
}

// Handler defines a specific action that should be taken in a probe.
message Handler {
  // One and only one of the following should be specified.
  // Exec specifies the action to take.
  // +optional
  optional ExecAction exec = 1;

  // HTTPGet specifies the http request to perform.
  // +optional
  optional HTTPGetAction httpGet = 2;

  // TCPSocket specifies an action involving a TCP port.
  // TCP hooks not yet supported
  // TODO: implement a realistic TCP lifecycle hook
  // +optional
  optional TCPSocketAction tcpSocket = 3;
}

// Describes sets of file paths that the FileWatch should ignore.
message IgnoreDef {
  // BasePath is the base path for the patterns. It cannot be empty.
  //
  // If no patterns are specified, everything under it will be recursively ignored.
  //
  // +tilt:local-path=true
  optional string basePath = 1;

  // Patterns are dockerignore style rules. Absolute-style patterns will be rooted to the BasePath.
  //
  // See https://docs.docker.com/engine/reference/builder/#dockerignore-file.
  repeated string patterns = 2;
}

// ImageMap expresses the mapping from an image reference to a real, pushed
// image in an image registry that a container runtime can access.
//
// Another way to think about the ImageMap is that ImageMapSpec is a mutable
// image reference (where the image might not exist yet), but ImageMapStatus is
// an immutable image reference (where, if an image is specified, it always
// exists).
//
// ImageMap does not specify how the image is built or who is responsible for
// building this. But any API that builds images should produce an ImageMap.
//
// For example, a builder that builds to a local image registry might create
// a map from: 'my-apiserver:dev' to 'localhost:5000/my-apiserver:content-based-label'.
//
// ImageMap doesn't follow the usual Kubernetes-style API semantics
// (where the Status is the result of running the Spec). It's closer to a
// ConfigMap. Though the Status does represent a real runtime result
// (an image in a registry).
//
// +k8s:openapi-gen=true
message ImageMap {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional ImageMapSpec spec = 2;

  optional ImageMapStatus status = 3;
}

// ImageMapList
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message ImageMapList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated ImageMap items = 2;
}

// ImageMapArgsOverride defines args to inject when the image
// is injected. Only applies to types that embed a v1.Container
// with a Command field.
//
// https://pkg.go.dev/k8s.io/api/core/v1#Container
message ImageMapOverrideArgs {
  // A list of args strings.
  repeated string args = 1;
}

// ImageMapCommandOverride defines a command to inject when the image
// is injected. Only applies to types that embed a v1.Container
// with a Command field.
//
// https://pkg.go.dev/k8s.io/api/core/v1#Container
message ImageMapOverrideCommand {
  // A list of command strings.
  repeated string command = 1;
}

// ImageMapSpec defines the desired state of ImageMap
message ImageMapSpec {
  // A named image reference.
  //
  // Deployment tools expect this image reference to match an image
  // in the YAML being deployed, and will replace that image reference.
  //
  // By default, this selector will match an image if the names match
  // (tags on both the selector and the matched reference are ignored).
  optional string selector = 1;

  // If specified, then tags on both the selector and the matched
  // reference are used for matching. The selector will only
  // match the reference if the tags match exactly.
  //
  // +optional
  optional bool matchExact = 2;

  // If specified, then the selector will also match any strings
  // in container env variables.
  //
  // +optional
  optional bool matchInEnvVars = 3;

  // If specified, the injector will replace the 'command'
  // field in the container when it replaces the image.
  //
  // +optional
  optional ImageMapOverrideCommand overrideCommand = 4;

  // If specified, the injector will replace the 'args'
  // field in the container when it replaces the image.
  //
  // +optional
  optional ImageMapOverrideArgs overrideArgs = 5;

  // Specifies how to disable this.
  //
  // +optional
  optional DisableSource disableSource = 6;
}

// ImageMapStatus defines the observed state of ImageMap
message ImageMapStatus {
  // A fully-qualified image reference, including a name and an immutable tag,
  // as seen from the cluster container runtime that we're mapping this image to.
  //
  // NB: Container images often need to be referenced from different networks,
  // including:
  //
  // 1) The cluster container runtime
  // 2) The local network
  // 3) The cluster network
  //
  // And each of these cases may have distinct URLs.
  // We might deprecate this field and only use fields
  // of the form `ImageFromX`.
  //
  // For more details on image references in different networks, see:
  // https://github.com/kubernetes/enhancements/tree/master/keps/sig-cluster-lifecycle/generic/1755-communicating-a-local-registry#specification-for-localregistryhosting-v1
  optional string image = 1;

  // A fully-qualified image reference, including a name and an immutable tag,
  // as seen from the local network.
  optional string imageFromLocal = 3;

  // A fully-qualified image reference, including a name and an immutable tag,
  // as seen from the cluster container runtime.
  optional string imageFromCluster = 4;

  // Timestamp indicating when the image started building.
  //
  // Intended to be used to determine which file changes were picked up by the
  // image build. We can assume that any file changes before this timestamp were
  // definitely included in the image, and any file changes after this timestamp
  // may not be included in the image.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime buildStartTime = 2;
}

// KubernetesApply specifies a blob of YAML to apply, and a set of ImageMaps
// that the YAML depends on.
//
// The KubernetesApply controller will resolve the ImageMaps into immutable image
// references. The controller will process the spec YAML, then apply it to the cluster.
// Those processing steps might include:
//
// - Injecting the resolved image references.
// - Adding custom labels so that Tilt can track the progress of the apply.
// - Modifying image pull rules to ensure the image is pulled correctly.
//
// The controller won't apply anything until all ImageMaps resolve to real images.
//
// The controller will watch all the image maps, and redeploy the entire YAML if
// any of the maps resolve to a new image.
//
// The status field will contain both the raw applied object, and derived fields
// to help other controllers figure out how to watch the apply progress.
//
// +k8s:openapi-gen=true
// +tilt:starlark-gen=true
message KubernetesApply {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional KubernetesApplySpec spec = 2;

  optional KubernetesApplyStatus status = 3;
}

message KubernetesApplyCmd {
  // Args are the command-line arguments for the apply command. Must have length >= 1.
  repeated string args = 1;

  // Process working directory.
  //
  // If not specified, will default to Tilt working directory.
  //
  // +optional
  // +tilt:local-path=true
  optional string dir = 2;

  // Env are additional variables for the process environment.
  //
  // Environment variables are layered on top of the environment variables
  // that Tilt runs with.
  //
  // +optional
  repeated string env = 3;
}

// KubernetesApplyList
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message KubernetesApplyList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated KubernetesApply items = 2;
}

// KubernetesApplySpec defines the desired state of KubernetesApply
message KubernetesApplySpec {
  // YAML to apply to the cluster.
  //
  // Exactly one of YAML OR ApplyCmd MUST be provided.
  //
  // +optional
  optional string yaml = 1;

  // Names of image maps that this applier depends on.
  //
  // The controller will watch all the image maps, and redeploy the entire YAML
  // if any of the maps resolve to a new image.
  //
  // +optional
  repeated string imageMaps = 2;

  // Descriptors of how to find images in the YAML.
  //
  // Needed when injecting images into CRDs.
  //
  // +optional
  repeated KubernetesImageLocator imageLocators = 3;

  // The timeout on the apply operation.
  //
  // We've had problems with both:
  // 1) CRD apiservers that take an arbitrarily long time to apply, and
  // 2) Infinite loops in the apimachinery
  // So we offer the ability to set a timeout on Kubernetes apply operations.
  //
  // The default timeout is 30s.
  //
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Duration timeout = 4;

  // KubernetesDiscoveryTemplateSpec describes how we discover pods
  // for resources created by this Apply.
  //
  // If not specified, the KubernetesDiscovery controller will listen to all pods,
  // and follow owner references to find the pods owned by these resources.
  //
  // +optional
  optional KubernetesDiscoveryTemplateSpec kubernetesDiscoveryTemplateSpec = 5;

  // PortForwardTemplateSpec describes the data model for port forwards
  // that KubernetesApply should set up.
  //
  // Underneath the hood, we'll create a KubernetesDiscovery object that finds
  // the pods and sets up the port-forwarding. Only one PortForward will be
  // active at a time.
  //
  // +optional
  optional PortForwardTemplateSpec portForwardTemplateSpec = 6;

  // PodLogStreamTemplateSpec describes the data model for PodLogStreams
  // that KubernetesApply should set up.
  //
  // Underneath the hood, we'll create a KubernetesDiscovery object that finds
  // the pods and sets up the pod log streams.
  //
  // If no template is specified, the controller will stream all
  // pod logs available from the apiserver.
  //
  // +optional
  optional PodLogStreamTemplateSpec podLogStreamTemplateSpec = 7;

  // DiscoveryStrategy describes how we set up pod watches for the applied
  // resources. This affects all systems that attach to pods, including
  // PortForwards, PodLogStreams, resource readiness, and live-updates.
  //
  // +optional
  optional string discoveryStrategy = 8;

  // Specifies how to disable this.
  //
  // +optional
  optional DisableSource disableSource = 9;

  // ApplyCmd is a custom command to execute to deploy entities to the Kubernetes cluster.
  //
  // The command must be idempotent, e.g. it must not fail if some or all entities already exist.
  //
  // The ApplyCmd MUST return valid Kubernetes YAML for the entities it applied to the cluster.
  //
  // Exactly one of YAML OR ApplyCmd MUST be provided.
  //
  // +optional
  optional KubernetesApplyCmd applyCmd = 10;

  // RestartOn determines external triggers that will result in an apply.
  //
  // +optional
  optional RestartOnSpec restartOn = 11;

  // DeleteCmd is a custom command to execute to delete entities created by ApplyCmd and clean up any
  // additional state.
  //
  // +optional
  optional KubernetesApplyCmd deleteCmd = 12;
}

// KubernetesApplyStatus defines the observed state of KubernetesApply
message KubernetesApplyStatus {
  // The result of applying the YAML to the cluster. This should contain
  // UIDs for the applied resources.
  //
  // +optional
  optional string resultYAML = 1;

  // An error applying the YAML.
  //
  // If there was an error, than ResultYAML should be empty (and vice versa).
  //
  // +optional
  optional string error = 2;

  // Timestamp of we last finished applying this YAML to the cluster.
  //
  // When populated, must be equal or after the LastApplyStartTime field.
  //
  // TODO(nick): In v1, we may rename this to LastApplyFinishTime, which
  // is more consistent with how we name this in other API objects.
  //
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime lastApplyTime = 3;

  // Timestamp of when we last started applying this YAML to the cluster.
  //
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime lastApplyStartTime = 6;

  // A base64-encoded hash of all the inputs to the apply.
  //
  // We added this so that more procedural code can determine whether
  // their updates have been applied yet or not by the reconciler. But any code
  // using it this way should note that the reconciler may "skip" an update
  // (e.g., if two images get updated in quick succession before the reconciler
  // injects them into the YAML), so a particular ApplieInputHash might never appear.
  //
  // +optional
  optional string appliedInputHash = 4;

  // Details about whether/why this is disabled.
  // +optional
  optional DisableStatus disableStatus = 5;
}

message KubernetesClusterConnection {
  // The name of the kubeconfig context to use.
  //
  // If not specified, will use the default context in the kubeconfig.
  optional string context = 1;

  // The default namespace to use.
  //
  // If not specified, will use the namespace in the kubeconfig.
  optional string namespace = 2;
}

// KubernetesDiscovery
// +k8s:openapi-gen=true
// +tilt:starlark-gen=true
message KubernetesDiscovery {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional KubernetesDiscoverySpec spec = 2;

  optional KubernetesDiscoveryStatus status = 3;
}

// KubernetesDiscoveryList
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message KubernetesDiscoveryList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated KubernetesDiscovery items = 2;
}

// KubernetesDiscoverySpec defines the desired state of KubernetesDiscovery
message KubernetesDiscoverySpec {
  // Watches determine what resources are discovered.
  //
  // If a discovered resource (e.g. Pod) matches the KubernetesWatchRef UID exactly, it will be reported.
  // If a discovered resource is transitively owned by the KubernetesWatchRef UID, it will be reported.
  repeated KubernetesWatchRef watches = 1;

  // ExtraSelectors are label selectors that will force discovery of a Pod even if it does not match
  // the AncestorUID.
  //
  // This should only be necessary in the event that a CRD creates Pods but does not set an owner reference
  // to itself.
  repeated k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector extraSelectors = 2;

  // PortForwardTemplateSpec describes the data model for port forwards
  // that KubernetesDiscovery should set up.
  //
  // The KubernetesDiscovery controller will choose a "best" candidate
  // for attaching the port-forwarding. Only one PortForward will be
  // active at a time.
  //
  // +optional
  optional PortForwardTemplateSpec portForwardTemplateSpec = 3;

  // PodLogStreamTemplateSpec describes the data model for PodLogStreams
  // that KubernetesDiscovery should set up.
  //
  // The KubernetesDiscovery controller will attach PodLogStream objects
  // to all active pods it discovers.
  //
  // If no template is specified, the controller will stream all
  // pod logs available from the apiserver.
  //
  // +optional
  optional PodLogStreamTemplateSpec podLogStreamTemplateSpec = 4;

  // Cluster name to determine the Kubernetes cluster.
  //
  // If not provided, "default" will be used.
  //
  // +optional
  optional string cluster = 5;
}

message KubernetesDiscoveryStateRunning {
  // StartTime is when Kubernetes resource discovery began.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime startTime = 1;
}

message KubernetesDiscoveryStateWaiting {
  // Reason the monitor has not yet been started.
  optional string reason = 1;
}

// KubernetesDiscoveryStatus defines the observed state of KubernetesDiscovery
message KubernetesDiscoveryStatus {
  // MonitorStartTime is the timestamp of when Kubernetes resource discovery was started.
  //
  // It is zero if discovery has not been started yet.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime monitorStartTime = 2;

  // Pods that have been discovered based on the criteria in the spec.
  repeated Pod pods = 1;

  // Waiting contains information about why the monitor has not started.
  //
  // +optional
  optional KubernetesDiscoveryStateWaiting waiting = 3;

  // Running contains information about the currently running monitor.
  //
  // +optional
  optional KubernetesDiscoveryStateRunning running = 4;
}

message KubernetesDiscoveryTemplateSpec {
  // ExtraSelectors are label selectors that will force discovery of a Pod even
  // if it does not match the AncestorUID.
  //
  // This should only be necessary in the event that a CRD creates Pods but does
  // not set an owner reference to itself.
  repeated k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector extraSelectors = 1;
}

// Finds image references in Kubernetes YAML.
message KubernetesImageLocator {
  // Selects which objects to look in.
  optional ObjectSelector objectSelector = 1;

  // A JSON path to the image reference field.
  //
  // If Object is empty, the field should be a string.
  //
  // If Object is non-empty, the field should be an object with subfields.
  optional string path = 2;

  // A descriptor of the path and structure of an object that describes an image
  // reference. This is a common way to describe images in CRDs, breaking
  // them down into an object rather than an image reference string.
  //
  // +optional
  optional KubernetesImageObjectDescriptor object = 3;
}

message KubernetesImageObjectDescriptor {
  // The name of the field that contains the image repository.
  optional string repoField = 1;

  // The name of the field that contains the image tag.
  optional string tagField = 2;
}

// KubernetesWatchRef is similar to v1.ObjectReference from the Kubernetes API and is used to determine
// what objects should be reported on based on discovery.
message KubernetesWatchRef {
  // UID is a Kubernetes object UID.
  //
  // It should either be the exact object UID or the transitive owner.
  //
  // +optional
  optional string uid = 1;

  // Namespace is the Kubernetes namespace for discovery. Required.
  optional string namespace = 2;

  // Name is the Kubernetes object name.
  //
  // This is not directly used in discovery; it is extra metadata.
  //
  // +optional
  optional string name = 3;
}

// LiveUpdate
// +k8s:openapi-gen=true
message LiveUpdate {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional LiveUpdateSpec spec = 2;

  optional LiveUpdateStatus status = 3;
}

message LiveUpdateContainerStateWaiting {
  // One word camel-case reason why we're in a waiting state.
  // +optional
  optional string reason = 1;

  // Human-readable description of what's blocking.
  // +optional
  optional string message = 2;
}

// LiveUpdateContainerStatus defines the observed state of
// the live-update syncer for a particular container.
message LiveUpdateContainerStatus {
  // The name of the container in the pod.
  optional string containerName = 1;

  // The ID of the container in the pod, in the format 'docker://<container_id>'.
  // +optional
  optional string containerID = 2;

  // The name of the pod this container belongs to.
  optional string podName = 3;

  // The namespace of the pod this container belongs to.
  optional string namespace = 4;

  // The timestamp of the most recent file update successfully synced to the
  // container.
  //
  // Must match the timestamp in a FileEvent, not the time the sync was performed.
  //
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime lastFileTimeSynced = 5;

  // Contains any error messages from the most recent sequence of Execs.
  //
  // Empty if the most recent Execs completed successfully.
  //
  // An ExecError is not necessarily a failure state. For example, a linter
  // error in the container is something we'd want to surface to the user, but
  // not an indication that the live-updater did something wrong.
  //
  // +optional
  optional string lastExecError = 6;

  // Details about a waiting live update.
  //
  // A live update is waiting when the reconciler is aware of file changes
  // that need to be synced to the container, but has decided not to sync them yet.
  optional LiveUpdateContainerStateWaiting waiting = 7;
}

// Specifies how to select containers to live update inside Docker Compose.
message LiveUpdateDockerComposeSelector {
  // The name of a DockerComposeService object.
  //
  // For simple projects, this is usually the same as the service
  // name in the docker-compose.yml file. (But it doesn't necessarily
  // have to be.)
  optional string service = 1;
}

// Runs a remote command after files have been synced to the container.
// Commonly used for small in-container changes (like moving files
// around, or restart processes).
message LiveUpdateExec {
  // Command-line arguments to run inside the container. Must have length at least 1.
  repeated string args = 1;

  // A list of relative paths that trigger this command exec.
  //
  // If not specified, all file changes seen by the LiveUpdate trigger this exec.
  //
  // Paths are specified relative to the the BasePath of the LiveUpdate.
  //
  // +optional
  repeated string triggerPaths = 2;
}

// Specifies how to select containers to live update inside K8s.
message LiveUpdateKubernetesSelector {
  // The name of a KubernetesDiscovery object for finding pods.
  optional string discoveryName = 1;

  // ApplyName is the name of a KubernetesApply object for filtering discovered pods to prevent updating old
  // deployments.
  //
  // If not provided, no filtering will be applied and all discovered Pods will be eligible for update.
  //
  // +optional
  optional string applyName = 3;

  // Image specifies the name of the image that we're copying files into.
  //
  // Determines which containers in a pod to live-update.
  // Matches images by name unless tag is explicitly specified.
  //
  // Exactly one of Image or ContainerName MUST be specified.
  //
  // +optional
  optional string image = 2;

  // ContainerName specifies the name of the container that we're copying files into.
  //
  // Exactly one of Image or ContainerName MUST be specified.
  //
  // +optional
  optional string containerName = 4;
}

// LiveUpdateList
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message LiveUpdateList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated LiveUpdate items = 2;
}

// Specifies how to select containers to live update.
//
// Every live update must be associated with some object for finding
// containers. In the future, we expect there to be other types
// of container discovery objects (like Docker Compose container discovery).
message LiveUpdateSelector {
  // Finds containers in Kubernetes.
  optional LiveUpdateKubernetesSelector kubernetes = 1;

  // Finds containers in Docker Compose.
  optional LiveUpdateDockerComposeSelector dockerCompose = 2;
}

// Specifies how to pull in files.
message LiveUpdateSource {
  // The name of a FileWatch to use as a file source.
  //
  // +optional
  optional string fileWatch = 1;

  // Name of the ImageMap object to watch for which file changes from this source
  // are included in the container image.
  //
  // If not provided, the live-updater will copy any file changes that it's aware of,
  // even if they're already included in the container.
  //
  // +optional
  optional string imageMap = 2;
}

// LiveUpdateSpec defines the desired state of LiveUpdate
message LiveUpdateSpec {
  // An absolute local path that serves as the basis for all
  // path calculations.
  //
  // Relative paths in this object are calculated relative to the base path. It
  // cannot be empty.
  //
  // +tilt:local-path=true
  optional string basePath = 1;

  // Specifies how this live-updater finds the containers that need live update.
  optional LiveUpdateSelector selector = 8;

  // Sources of files to sync.
  //
  // Every live update must be associated with at least one Source object
  // to trigger the update. Usually, Tilt structures it so that there's
  // a Source for each image we depend on.
  repeated LiveUpdateSource sources = 9;

  // A list of relative paths that will immediately stop the live-update for the
  // current container.
  //
  // Used to detect file changes that invalidate the entire container image,
  // forcing a complete rebuild.
  //
  // +optional
  repeated string stopPaths = 4;

  // Specify paths that can be live-updated into the container and their destinations.
  // Any file changes observed that do not match any of these will invalidate the container image and force a complete rebuild.
  //
  // +optional
  repeated LiveUpdateSync syncs = 5;

  // A list of commands to run inside the container after files are synced.
  //
  // NB: In some documentation, we call these 'runs'. 'exec' more clearly
  // matches kubectl exec for remote commands.
  //
  // +optional
  repeated LiveUpdateExec execs = 6;

  // Specifies whether Tilt should try to natively restart the container in-place
  // after syncs and execs.
  //
  // Note that native restarts are only supported by Docker and Docker Compose
  // (and NOT docker-shim or containerd, the most common Kubernetes runtimes).
  //
  // To restart on live-update in Kubernetes, see the guide for how
  // to apply extensions to add restart behavior:
  //
  // https://docs.tilt.dev/live_update_reference.html
  //
  // +optional
  optional string restart = 7;
}

// If any of the containers are currently failing to process updates, the
// LiveUpdateStateFailed surfaces information about what's happening and what
// the live-updater is doing to fix the problem.
message LiveUpdateStateFailed {
  // One word camel-case reason why we've reached a failure state.
  // +optional
  optional string reason = 1;

  // Human-readable description of what's wrong.
  // +optional
  optional string message = 2;

  // When the live-updater transitioned into a Failed state.
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime lastTransitionTime = 3;
}

// LiveUpdateStatus defines the observed state of LiveUpdate
message LiveUpdateStatus {
  // A list of all containers that the live-updater is currently connected to.
  // +optional
  repeated LiveUpdateContainerStatus containers = 1;

  // If any of the containers are currently failing to process updates,
  // the Failed state surfaces information about what's happening and what
  // the live-updater is doing to fix the problem.
  //
  // If all containers are updating successfully, Failed will be nil.
  //
  // +optional
  optional LiveUpdateStateFailed failed = 2;
}

// Determines how a local path maps into a container image.
message LiveUpdateSync {
  // A relative path to local files. Required.
  //
  // Computed relative to the live-update BasePath.
  optional string localPath = 1;

  // An absolute path inside the container. Required.
  optional string containerPath = 2;
}

// Selector for any Kubernetes-style API.
message ObjectSelector {
  // A regular expression apiVersion match.
  // +optional
  optional string apiVersionRegexp = 1;

  // A regular expression kind match.
  // +optional
  optional string kindRegexp = 2;

  // A regular expression name match.
  // +optional
  optional string nameRegexp = 3;

  // A regular expression namespace match.
  // +optional
  optional string namespaceRegexp = 4;
}

// Pod is a collection of containers that can run on a host.
//
// The Tilt API representation mirrors the Kubernetes API very closely. Irrelevant data is
// not included, and some fields might be simplified.
//
// There might also be Tilt-specific status fields.
message Pod {
  // UID is the unique Pod UID within the K8s cluster.
  optional string uid = 14;

  // Name is the Pod name within the K8s cluster.
  optional string name = 1;

  // Namespace is the Pod namespace within the K8s cluster.
  optional string namespace = 2;

  // CreatedAt is when the Pod was created.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time createdAt = 3;

  // Phase is where the Pod is at in its current lifecycle.
  //
  // Valid values for this are v1.PodPhase values from the Kubernetes API.
  optional string phase = 4;

  // Deleting indicates that the Pod is in the process of being removed.
  optional bool deleting = 5;

  // Conditions are various lifecycle conditions for this Pod.
  //
  // See also v1.PodCondition in the Kubernetes API.
  repeated PodCondition conditions = 6;

  // InitContainers are containers executed prior to the Pod containers being executed.
  repeated Container initContainers = 7;

  // Containers are the containers belonging to the Pod.
  repeated Container containers = 8;

  // AncestorUID is the UID from the WatchRef that matched this Pod.
  //
  // If the Pod matched based on extra label selectors, this will be empty.
  //
  // +optional
  optional string ancestorUID = 15;

  // PodTemplateSpecHash is a hash of the Pod template spec.
  //
  // Tilt uses this to associate Pods with the build that triggered them.
  optional string podTemplateSpecHash = 10;

  // Status is a concise description for the Pod's current state.
  //
  // This is based off the status output from `kubectl get pod` and is not an "enum-like"
  // value.
  optional string status = 12;

  // Errors are aggregated error messages for the Pod and its containers.
  repeated string errors = 13;

  // Direct owner of this pod, if available.
  optional PodOwner owner = 16;
}

// PodCondition is a lifecycle condition for a Pod.
message PodCondition {
  // Type is the type of condition.
  //
  // Valid values for this are v1.PodConditionType values from the Kubernetes API.
  optional string type = 1;

  // Status is the current state of the condition (True, False, or Unknown).
  //
  // Valid values for this are v1.PodConditionStatus values from the Kubernetes API.
  optional string status = 2;

  // LastTransitionTime is the last time the status changed.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;

  // Reason is a unique, one-word, CamelCase value for the cause of the last status change.
  optional string reason = 4;

  // Message is a human-readable description of the last status change.
  optional string message = 5;
}

// PodLogStream
//
// Streams logs from a pod on Kubernetes into the core Tilt engine.
//
// +k8s:openapi-gen=true
message PodLogStream {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional PodLogStreamSpec spec = 2;

  optional PodLogStreamStatus status = 3;
}

// PodLogStreamList
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message PodLogStreamList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated PodLogStream items = 2;
}

// PodLogStreamSpec defines the desired state of PodLogStream
//
// Translated into a PodLog query to the current Kubernetes cluster:
// https://pkg.go.dev/k8s.io/api/core/v1#PodLogOptions
//
// TODO(nick): Should all Kubernetes types have an object that describes
// which Kubernetes context to use?
message PodLogStreamSpec {
  // The name of the pod to watch. Required.
  optional string pod = 1;

  // The namespace of the pod to watch. Defaults to the kubecontext default namespace.
  //
  // +optional
  optional string namespace = 2;

  // An RFC3339 timestamp from which to show logs. If this value
  // precedes the time a pod was started, only logs since the pod start will be returned.
  // If this value is in the future, no logs will be returned.
  //
  // Translates directly to the underlying PodLogOptions.
  //
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time sinceTime = 3;

  // The names of containers to include in the stream.
  //
  // If `onlyContainers` and `ignoreContainers` are not set,
  // will watch all containers in the pod.
  //
  // +optional
  repeated string onlyContainers = 4;

  // The names of containers to exclude from the stream.
  //
  // If `onlyContainers` and `ignoreContainers` are not set,
  // will watch all containers in the pod.
  //
  // +optional
  repeated string ignoreContainers = 5;

  // Cluster the Pod belongs to.
  //
  // If not provided, "default" will be used.
  //
  // +optional
  optional string cluster = 6;
}

// PodLogStreamStatus defines the observed state of PodLogStream
message PodLogStreamStatus {
  // A list of containers being watched.
  //
  // +optional
  repeated ContainerLogStreamStatus containerStatuses = 1;

  // Error message encountered while setting up the stream.
  //
  // +optional
  optional string error = 2;
}

// PodLogStreamTemplateSpec describes common attributes for PodLogStreams
// that can be shared across pods.
message PodLogStreamTemplateSpec {
  // An RFC3339 timestamp from which to show logs. If this value
  // precedes the time a pod was started, only logs since the pod start will be returned.
  // If this value is in the future, no logs will be returned.
  //
  // Translates directly to the underlying PodLogOptions.
  //
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time sinceTime = 1;

  // The names of containers to include in the stream.
  //
  // If `onlyContainers` and `ignoreContainers` are not set,
  // will watch all containers in the pod.
  //
  // +optional
  repeated string onlyContainers = 2;

  // The names of containers to exclude from the stream.
  //
  // If `onlyContainers` and `ignoreContainers` are not set,
  // will watch all containers in the pod.
  //
  // +optional
  repeated string ignoreContainers = 3;
}

// PodOwner contains information of the direct owner of the
// pod, if available.
//
// Tools that need to select a most relevant pod or set of pods
// can use this info to group pods by owner.
message PodOwner {
  // The name of the owner.
  optional string name = 1;

  // API version of the owner.
  optional string apiVersion = 3;

  // Kind of the owner
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  optional string kind = 4;

  // The creation timestamp of the owner.
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time creationTimestamp = 2;
}

// PortForward
// +k8s:openapi-gen=true
message PortForward {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional PortForwardSpec spec = 2;

  optional PortForwardStatus status = 3;
}

// PortForwardList
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message PortForwardList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated PortForward items = 2;
}

// PortForwardSpec defines the desired state of PortForward
message PortForwardSpec {
  // The name of the pod to port forward to/from. Required.
  optional string podName = 1;

  // The namespace of the pod to port forward to/from. Defaults to the kubecontext default namespace.
  //
  // +optional
  optional string namespace = 2;

  // One or more port forwards to execute on the given pod. Required.
  repeated Forward forwards = 3;
}

// PortForwardStatus defines the observed state of PortForward
message PortForwardStatus {
  repeated ForwardStatus forwardStatuses = 2;
}

// PortForwardTemplateSpec describes common attributes for PortForwards
// that can be shared across pods.
message PortForwardTemplateSpec {
  // One or more port forwards to execute on the given pod. Required.
  repeated Forward forwards = 1;
}

// Probe describes a health check to be performed to determine whether it is
// alive or ready to receive traffic.
message Probe {
  // The action taken to determine the health of a container
  optional Handler handler = 1;

  // Number of seconds after the container has started before liveness probes are initiated.
  // More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
  // +optional
  optional int32 initialDelaySeconds = 2;

  // Number of seconds after which the probe times out.
  // Defaults to 1 second. Minimum value is 1.
  // More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
  // +optional
  optional int32 timeoutSeconds = 3;

  // How often (in seconds) to perform the probe.
  // Default to 10 seconds. Minimum value is 1.
  // +optional
  optional int32 periodSeconds = 4;

  // Minimum consecutive successes for the probe to be considered successful after having failed.
  // Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
  // +optional
  optional int32 successThreshold = 5;

  // Minimum consecutive failures for the probe to be considered failed after having succeeded.
  // Defaults to 3. Minimum value is 1.
  // +optional
  optional int32 failureThreshold = 6;
}

message RegistryHosting {
  // Host documents the host (hostname and port) of the registry, as seen from
  // outside the cluster.
  //
  // This is the registry host that tools outside the cluster should push images
  // to.
  optional string host = 1;

  // HostFromClusterNetwork documents the host (hostname and port) of the
  // registry, as seen from networking inside the container pods.
  //
  // This is the registry host that tools running on pods inside the cluster
  // should push images to. If not set, then tools inside the cluster should
  // assume the local registry is not available to them.
  optional string hostFromClusterNetwork = 2;

  // HostFromContainerRuntime documents the host (hostname and port) of the
  // registry, as seen from the cluster's container runtime.
  //
  // When tools apply Kubernetes objects to the cluster, this host should be
  // used for image name fields. If not set, users of this field should use the
  // value of Host instead.
  //
  // Note that it doesn't make sense semantically to define this field, but not
  // define Host or HostFromClusterNetwork. That would imply a way to pull
  // images without a way to push images.
  optional string hostFromContainerRuntime = 3;

  // Help contains a URL pointing to documentation for users on how to set
  // up and configure a local registry.
  //
  // Tools can use this to nudge users to enable the registry. When possible,
  // the writer should use as permanent a URL as possible to prevent drift
  // (e.g., a version control SHA).
  //
  // When image pushes to a registry host specified in one of the other fields
  // fail, the tool should display this help URL to the user. The help URL
  // should contain instructions on how to diagnose broken or misconfigured
  // registries.
  optional string help = 4;
}

// RestartOnSpec indicates the set of objects that can trigger a restart of this object.
message RestartOnSpec {
  // FileWatches that can trigger a restart.
  // +optional
  repeated string fileWatches = 1;

  // UIButtons that can trigger a restart.
  // +optional
  repeated string uiButtons = 2;
}

// Session provides introspective data about the status of the Tilt process.
// +k8s:openapi-gen=true
message Session {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional SessionSpec spec = 2;

  optional SessionStatus status = 3;
}

// SessionList is a list of Session objects.
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message SessionList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated Session items = 2;
}

// SessionSpec defines the desired state of Session
message SessionSpec {
  // TiltfilePath is the path to the Tiltfile for the run. It cannot be empty.
  optional string tiltfilePath = 1;

  // ExitCondition defines the criteria for Tilt to exit.
  optional string exitCondition = 2;
}

// SessionStatus defines the observed state of Session
message SessionStatus {
  // PID is the process identifier for this instance of Tilt.
  optional int64 pid = 1;

  // StartTime is when the Tilt engine was first started.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime startTime = 2;

  // Targets are normalized representations of the servers/jobs managed by this Session.
  //
  // A resource from a Tiltfile might produce one or more targets. A target can also be shared across
  // multiple resources (e.g. an image referenced by multiple K8s pods).
  repeated Target targets = 3;

  // Done indicates whether this Session has completed its work and is ready to exit.
  optional bool done = 4;

  // Error is a non-empty string when the Session is Done but encountered a failure as defined by the ExitCondition
  // from the SessionSpec.
  //
  // +optional
  optional string error = 5;
}

// StartOnSpec indicates the set of objects that can trigger a start/restart of this object.
message StartOnSpec {
  // StartAfter indicates that events before this time should be ignored.
  //
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time startAfter = 1;

  // UIButtons that can trigger a start/restart.
  repeated string uiButtons = 2;
}

// Describes where a ToggleButton's state is stored.
// Exactly one type of source must be set.
message StateSource {
  // State is stored in a ConfigMap.
  //
  // +optional
  optional ConfigMapStateSource configMap = 1;
}

message StopOnSpec {
  // UIButtons that can trigger a stop.
  repeated string uiButtons = 2;
}

// TCPSocketAction describes an action based on opening a socket
message TCPSocketAction {
  // Number or name of the port to access on the container.
  // Number must be in the range 1 to 65535.
  optional int32 port = 1;

  // Optional: Host name to connect to, defaults to the pod IP.
  // +optional
  optional string host = 2;
}

// Target is a server or job whose execution is managed as part of this Session.
message Target {
  // Name is the name of the target; this is auto-generated from Tiltfile resources.
  optional string name = 1;

  // Type is the execution profile for this resource.
  //
  // Job targets run to completion (e.g. a build script or database migration script).
  // Server targets run indefinitely (e.g. an HTTP server).
  optional string type = 2;

  // Resources are one or more Tiltfile resources that this target is associated with.
  repeated string resources = 3;

  // State provides information about the current status of the target.
  optional TargetState state = 4;
}

// TargetState describes the current execution status for a target.
//
// Either EXACTLY one of Waiting, Active, Disabled, or Terminated will be populated or NONE of them will be.
// In the event that all states are null, the target is currently inactive or disabled and should not
// be expected to execute.
message TargetState {
  // Waiting being non-nil indicates that the next execution of the target has been queued but not yet started.
  //
  // +optional
  optional TargetStateWaiting waiting = 1;

  // Active being non-nil indicates that the target is currently executing.
  //
  // +optional
  optional TargetStateActive active = 2;

  // Terminated being non-nil indicates that the target finished execution either normally or due to failure.
  //
  // +optional
  optional TargetStateTerminated terminated = 3;

  // Disabled being non-nil indicates that the target is disabled.
  //
  // +optional
  optional TargetStateDisabled disabled = 4;
}

// TargetStateActive is a target that is currently running but has not yet finished.
message TargetStateActive {
  // StartTime is when execution began.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime startTime = 1;

  // Ready indicates that the target has passed readiness checks.
  //
  // If the target does not use or support readiness checks, this is always true.
  optional bool ready = 2;
}

// TargetStateDisabled is a target that has been disabled.
message TargetStateDisabled {
}

// TargetStateTerminated is a target that finished running, either because it completed successfully or
// encountered an error.
message TargetStateTerminated {
  // StartTime is when the target began executing.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime startTime = 1;

  // FinishTime is when the target stopped executing.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime finishTime = 2;

  // Error is a non-empty string if the target encountered a failure during execution that caused it to stop.
  //
  // For targets of type TargetTypeServer, this is always populated, as the target is expected to run indefinitely,
  // and thus any termination is an error.
  //
  // +optional
  optional string error = 3;
}

// TargetStateWaiting is a target that has been enqueued for execution but has not yet started.
message TargetStateWaiting {
  // WaitReason is a description for why the target is waiting and not yet active.
  //
  // This is NOT the "cause" or "trigger" for the target being invoked.
  optional string waitReason = 1;
}

// Information about the running tilt binary.
message TiltBuild {
  // A semantic version string.
  // +optional
  optional string version = 1;

  // The Git digest of the commit this binary was built at.
  // +optional
  optional string commitSHA = 2;

  // A human-readable string representing when the binary was built.
  // +optional
  optional string date = 3;

  // Indicates whether this is a development build (true) or an official release (false).
  // +optional
  optional bool dev = 4;
}

// Tiltfile is the main way users add services to Tilt.
//
// The Tiltfile evaluator executes the Tiltfile, then adds all the objects
// it creates as children of the Tiltfile object.
//
// +k8s:openapi-gen=true
message Tiltfile {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional TiltfileSpec spec = 2;

  optional TiltfileStatus status = 3;
}

// TiltfileList
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message TiltfileList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated Tiltfile items = 2;
}

// TiltfileSpec defines the desired state of Tiltfile
message TiltfileSpec {
  // The path to the Tiltfile on disk.
  optional string path = 1;

  // A set of labels to apply to all objects owned by this Tiltfile.
  // +optional
  map<string, string> labels = 2;

  // Objects that can trigger a re-execution of this Tiltfile.
  // +optional
  optional RestartOnSpec restartOn = 3;

  // Arguments to the Tiltfile.
  //
  // Arguments can be positional (['a', 'b', 'c']) or flag-based ('--to-edit=a').
  // By default, a list of arguments indicates the list of services in the tiltfile
  // that should be enabled.
  //
  // +optional
  repeated string args = 4;

  // Objects that can stop execution of this Tiltfile.
  //
  // +optional
  optional StopOnSpec stopOn = 5;
}

// TiltfileStateRunning is a running state of a tiltfile execution.
message TiltfileStateRunning {
  // The reason why this tiltfile was built.
  // May contain more than one reason.
  // +optional
  repeated string reasons = 1;

  // Time at which previous execution of the command started.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime startedAt = 2;
}

// TiltfileStateTerminated is a terminated state of a tiltfile execution.
message TiltfileStateTerminated {
  // The reasons why this tiltfile was built.
  // May contain more than one reason.
  // +optional
  repeated string reasons = 1;

  // Error message if this tiltfile execution failed.
  // +optional
  optional string error = 2;

  // Time at which previous execution of the command started.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime startedAt = 3;

  // Time at which the command last terminated.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime finishedAt = 4;

  // Number of warnings generated by this Tiltfile.
  // (brief) reason the process is terminated
  // +optional
  optional int32 warningCount = 5;
}

// TiltfileStateWaiting is a waiting state of a tiltfile execution.
message TiltfileStateWaiting {
  // (brief) reason the tiltfile is waiting.
  // +optional
  optional string reason = 1;
}

// TiltfileStatus defines the observed state of Tiltfile
message TiltfileStatus {
  // Details about a waiting tiltfile.
  // +optional
  optional TiltfileStateWaiting waiting = 1;

  // Details about a running tiltfile.
  // +optional
  optional TiltfileStateRunning running = 2;

  // Details about a terminated tiltfile.
  // +optional
  optional TiltfileStateTerminated terminated = 3;
}

// ToggleButton
// +k8s:openapi-gen=true
message ToggleButton {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional ToggleButtonSpec spec = 2;

  optional ToggleButtonStatus status = 3;
}

// ToggleButtonList
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message ToggleButtonList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated ToggleButton items = 2;
}

// ToggleButtonSpec defines the desired state of ToggleButton
message ToggleButtonSpec {
  // Where to display the button
  optional UIComponentLocation location = 1;

  // Config for the button when it is "on"
  optional ToggleButtonStateSpec on = 2;

  // Config for the button when it is "off"
  optional ToggleButtonStateSpec off = 3;

  // If `StateSource` does not point at a valid value, the initial button
  // state will be "on" or "off" depending on this bool
  optional bool defaultOn = 4;

  // Where the toggle button's state is stored
  optional StateSource stateSource = 5;
}

// Describes a state (on/off) of a ToggleButton
message ToggleButtonStateSpec {
  // Text to appear on the button itself or as hover text (depending on button location).
  optional string text = 2;

  // IconName is a Material Icon to appear next to button text or on the button itself (depending on button location).
  //
  // Valid values are icon font ligature names from the Material Icons set.
  // See https://fonts.google.com/icons for the full list of available icons.
  //
  // If both IconSVG and IconName are specified, IconSVG will take precedence.
  //
  // +optional
  optional string iconName = 3;

  // IconSVG is an SVG to use as the icon to appear next to button text or on the button itself (depending on button
  // location).
  //
  // This should be an <svg> element scaled for a 24x24 viewport.
  //
  // If both IconSVG and IconName are specified, IconSVG will take precedence.
  //
  // +optional
  optional string iconSVG = 4;

  // If true, clicking the button in this state requires a second click
  // to confirm.
  //
  // +optional
  optional bool requiresConfirmation = 5;
}

// ToggleButtonStatus defines the observed state of ToggleButton
message ToggleButtonStatus {
  // If healthy, empty. If non-healthy, specifies a problem the ToggleButton encountered
  // +optional
  optional string error = 1;
}

// Describes a boolean checkbox input field attached to a button.
message UIBoolInputSpec {
  // Whether the input is initially true or false.
  // +optional
  optional bool defaultValue = 1;

  // If the input's value is converted to a string, use this when the value is true.
  // If unspecified, its string value will be `"true"`
  // +optional
  optional string trueString = 2;

  // If the input's value is converted to a string, use this when the value is false.
  // If unspecified, its string value will be `"false"`
  // +optional
  optional string falseString = 3;
}

message UIBoolInputStatus {
  optional bool value = 1;
}

// UIBuildRunning respresents an in-progress build/update in the user interface.
message UIBuildRunning {
  // The time when the build started.
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime startTime = 1;

  // The log span where the build logs are stored in the logstore.
  // +optional
  optional string spanID = 2;
}

// UIBuildRunning respresents a finished build/update in the user interface.
message UIBuildTerminated {
  // A non-empty string if the build failed with an error.
  // +optional
  optional string error = 1;

  // A list of warnings encountered while running the build.
  // These warnings will also be printed to the build's log.
  // +optional
  repeated string warnings = 2;

  // The time when the build started.
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime startTime = 3;

  // The time when the build finished.
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime finishTime = 4;

  // The log span where the build logs are stored in the logstore.
  // +optional
  optional string spanID = 5;

  // A crash rebuild happens when Tilt live-updated a container, then
  // the pod crashed, wiping out the live-updates. Tilt does a full
  // build+deploy to reset the pod state to what's on disk.
  // +optional
  optional bool isCrashRebuild = 6;
}

// UIButton
// +k8s:openapi-gen=true
// +tilt:starlark-gen=true
message UIButton {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional UIButtonSpec spec = 2;

  optional UIButtonStatus status = 3;
}

// UIButtonList
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message UIButtonList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated UIButton items = 2;
}

// UIButtonSpec defines the desired state of UIButton
message UIButtonSpec {
  // Location associates the button with another component for layout.
  optional UIComponentLocation location = 1;

  // Text to appear on the button itself or as hover text (depending on button location).
  optional string text = 2;

  // IconName is a Material Icon to appear next to button text or on the button itself (depending on button location).
  //
  // Valid values are icon font ligature names from the Material Icons set.
  // See https://fonts.google.com/icons for the full list of available icons.
  //
  // If both IconSVG and IconName are specified, IconSVG will take precedence.
  //
  // +optional
  optional string iconName = 3;

  // IconSVG is an SVG to use as the icon to appear next to button text or on the button itself (depending on button
  // location).
  //
  // This should be an <svg> element scaled for a 24x24 viewport.
  //
  // If both IconSVG and IconName are specified, IconSVG will take precedence.
  //
  // +optional
  optional string iconSVG = 4;

  // If true, the button will be rendered, but with an effect indicating it's
  // disabled. It will also be unclickable.
  //
  // +optional
  optional bool disabled = 5;

  // If true, the UI will require the user to click the button a second time to
  // confirm before taking action
  //
  // +optional
  optional bool requiresConfirmation = 7;

  // Any inputs for this button.
  // +optional
  repeated UIInputSpec inputs = 6;
}

// UIButtonStatus defines the observed state of UIButton
message UIButtonStatus {
  // LastClickedAt is the timestamp of the last time the button was clicked.
  //
  // If the button has never clicked before, this will be the zero-value/null.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime lastClickedAt = 1;

  // Status of any inputs on this button.
  // +optional
  repeated UIInputStatus inputs = 2;
}

// UIComponentLocation specifies where to put a UI component.
message UIComponentLocation {
  // ComponentID is the identifier of the parent component to associate this component with.
  //
  // For example, this is a resource name if the ComponentType is Resource.
  optional string componentID = 1;

  // ComponentType is the type of the parent component.
  optional string componentType = 2;
}

message UIComponentLocationResource {
  optional string resourceName = 1;
}

// Configures Tilt to enable non-default features (e.g., experimental or
// deprecated).
//
// The Tilt features controlled by this are generally in an unfinished state,
// and not yet documented.
//
// As a Tilt user, you don’t need to worry about this unless something
// else directs you to (e.g., an experimental feature doc, or a conversation
// with a Tilt contributor).
message UIFeatureFlag {
  // The name of the flag.
  // +optional
  optional string name = 1;

  // The value of the flag.
  // +optional
  optional bool value = 2;
}

// Describes a hidden input field attached to a button,
// with a value to pass on any submit.
message UIHiddenInputSpec {
  optional string value = 1;
}

message UIHiddenInputStatus {
  optional string value = 1;
}

// Defines an Input to render in the UI.
// If UIButton is analogous to an HTML <form>,
// UIInput is analogous to an HTML <input>.
message UIInputSpec {
  // Name of this input. Must be unique within the UIButton.
  optional string name = 1;

  // A label to display next to this input in the UI.
  // +optional
  optional string label = 2;

  // A Text input that takes a string.
  // +optional
  optional UITextInputSpec text = 3;

  // A Bool input that is true or false
  // +optional
  optional UIBoolInputSpec bool = 4;

  // An input that has a constant value and does not display to the user
  // +optional
  optional UIHiddenInputSpec hidden = 5;
}

// The status corresponding to a UIInputSpec
message UIInputStatus {
  // Name of the input whose status this is. Must match the `Name` of a corresponding
  // UIInputSpec.
  optional string name = 1;

  // The status of the input, if it's text
  // +optional
  optional UITextInputStatus text = 2;

  // The status of the input, if it's a bool
  // +optional
  optional UIBoolInputStatus bool = 3;

  // The status of the input, if it's a hidden
  // +optional
  optional UIHiddenInputStatus hidden = 4;
}

// UIResource represents per-resource status data for rendering the web UI.
//
// Treat this as a legacy data structure that's more intended to make transition
// easier rather than a robust long-term API.
//
// +k8s:openapi-gen=true
message UIResource {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional UIResourceSpec spec = 2;

  optional UIResourceStatus status = 3;
}

message UIResourceCondition {
  // Type of UI Resource condition.
  optional string type = 1;

  // Status of the condition, one of True, False, Unknown.
  optional string status = 6;

  // Last time the condition transitioned from one status to another.
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime lastTransitionTime = 3;

  // The reason for the condition's last transition.
  // +optional
  optional string reason = 4;

  // A human readable message indicating details about the transition.
  // +optional
  optional string message = 5;
}

// UIResourceKubernetes contains status information specific to Kubernetes.
message UIResourceKubernetes {
  // The name of the active pod.
  //
  // The active pod tends to be what Tilt defaults to for port-forwards,
  // live-updates, etc.
  // +optional
  optional string podName = 1;

  // The creation time of the active pod.
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time podCreationTime = 2;

  // The last update time of the active pod
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time podUpdateStartTime = 3;

  // The status of the active pod.
  // +optional
  optional string podStatus = 4;

  // Extra error messaging around the current status of the active pod.
  // +optional
  optional string podStatusMessage = 5;

  // Whether all the containers in the pod are currently healthy
  // and have passed readiness checks.
  // +optional
  optional bool allContainersReady = 6;

  // The number of pod restarts.
  // +optional
  optional int32 podRestarts = 7;

  // The span where this pod stores its logs in the Tilt logstore.
  // +optional
  optional string spanID = 8;

  // The list of all resources deployed in the Kubernetes deploy
  // for this resource.
  // +optional
  repeated string displayNames = 9;
}

// UIResourceLink represents a link assocatiated with a UIResource.
message UIResourceLink {
  // A URL to link to.
  // +optional
  optional string url = 1;

  // The display label on a URL.
  // +optional
  optional string name = 2;
}

// UIResourceList
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message UIResourceList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated UIResource items = 2;
}

// UIResourceLocal contains status information specific to local commands.
message UIResourceLocal {
  // The PID of the actively running local command.
  // +optional
  optional int64 pid = 1;

  // Whether this represents a test job.
  //
  // Deprecated: Users should use labels for marking services as tests.
  //
  // +optional
  optional bool isTest = 2;
}

// UIResourceSpec is an empty struct.
// UIResource is a kludge for making Tilt's internal status readable, not
// for specifying behavior.
message UIResourceSpec {
}

message UIResourceStateWaiting {
  // Reason is a unique, one-word reason for why the UIResource update is pending.
  optional string reason = 1;

  // HoldingOn is the set of objects blocking this resource from updating.
  //
  // These objects might NOT be explicit dependencies of the current resource. For example, if an un-parallelizable
  // resource is updating, all other resources with queued updates will be holding on it with a reason of
  // `waiting-for-local`.
  //
  // +optional
  repeated UIResourceStateWaitingOnRef on = 2;
}

message UIResourceStateWaitingOnRef {
  // Group for the object type being waited on.
  optional string group = 1;

  // APIVersion for the object type being waited on.
  optional string apiVersion = 2;

  // Kind of the object type being waited on.
  optional string kind = 3;

  // Name of the object being waiting on.
  optional string name = 4;
}

// UIResourceStatus defines the observed state of UIResource
message UIResourceStatus {
  // The last time this resource was deployed.
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime lastDeployTime = 1;

  // Bit mask representing whether this resource is run when:
  // 1) When a file changes
  // 2) When the resource initializes
  // +optional
  optional int32 triggerMode = 2;

  // Past completed builds.
  // +optional
  repeated UIBuildTerminated buildHistory = 3;

  // The currently running build, if any.
  // +optional
  optional UIBuildRunning currentBuild = 4;

  // When the build was put in the pending queue.
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime pendingBuildSince = 5;

  // True if the build was put in the pending queue due to file changes.
  // +optional
  optional bool hasPendingChanges = 6;

  // Links attached to this resource.
  // +optional
  repeated UIResourceLink endpointLinks = 7;

  // Extra data about Kubernetes resources.
  // +optional
  optional UIResourceKubernetes k8sResourceInfo = 8;

  // Extra data about Local resources
  // +optional
  optional UIResourceLocal localResourceInfo = 9;

  // The RuntimeStatus is a simple, high-level summary of the runtime state of a server.
  //
  // Not all resources run servers.
  // +optional
  optional string runtimeStatus = 10;

  // The UpdateStatus is a simple, high-level summary of any update tasks to bring
  // the resource up-to-date.
  //
  // If the resource runs a server, this may include both build tasks and live-update
  // syncing.
  // +optional
  optional string updateStatus = 14;

  // Information about all the target specs that this resource summarizes.
  // +optional
  repeated UIResourceTargetSpec specs = 12;

  // Queued is a simple indicator of whether the resource is queued for an update.
  // +optional
  optional bool queued = 13;

  // Order expresses the relative order of resources in the UI when they're not
  // otherwise sorted. Lower integers go first. When two resources have the same
  // order, they should be sorted by name.
  //
  // When UIResources are generated from the Tiltfile, we use the order they
  // were added to the Tiltfile for the Order field.
  //
  // +optional
  optional int32 order = 15;

  // Information about the resource's objects' disabled status.
  optional DisableResourceStatus disableStatus = 16;

  // Waiting provides detail on why the resource is currently blocked from updating.
  //
  // +optional
  optional UIResourceStateWaiting waiting = 17;

  // Represents the latest available observations of a UIResource's current state.
  //
  // Designed for compatibility with 'wait' and cross-resource status reporting.
  // https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#typical-status-properties
  //
  // +optional
  repeated UIResourceCondition conditions = 18;
}

// UIResourceTargetSpec represents the spec of a build or deploy that a resource summarizes.
message UIResourceTargetSpec {
  // The ID of the target.
  // +optional
  optional string id = 1;

  // The type of the target.
  // +optional
  optional string type = 2;

  // Whether the target has a live update assocated with it.
  // +optional
  optional bool hasLiveUpdate = 3;
}

// UISession represents global status data for rendering the web UI.
//
// Treat this as a legacy data structure that's more intended to make transition
// easier rather than a robust long-term API.
//
// Per-resource status data should be stored in UIResource.
//
// +k8s:openapi-gen=true
message UISession {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional UISessionSpec spec = 2;

  optional UISessionStatus status = 3;
}

// UISessionList
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message UISessionList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated UISession items = 2;
}

// UISessionSpec is an empty struct.
// UISession is a kludge for making Tilt's internal status readable, not
// for specifying behavior.
message UISessionSpec {
}

// UISessionStatus defines the observed state of UISession
message UISessionStatus {
  // FeatureFlags reports a list of experimental features that have been
  // enabled.
  // +optional
  repeated UIFeatureFlag featureFlags = 1;

  // NeedsAnalyticsNudge reports whether the UI hasn't opted in or out
  // of analytics, and the UI should nudge them to do so.
  // +optional
  optional bool needsAnalyticsNudge = 2;

  // RunningTiltBuild reports the currently running version of tilt
  // that this UI is talking to.
  // +optional
  optional TiltBuild runningTiltBuild = 3;

  // SuggestedTiltVersion tells the UI the recommended version for this
  // user. If the version is different than what's running, the UI
  // may display a prompt to upgrade.
  // +optional
  optional string suggestedTiltVersion = 4;

  // VersionSettings indicates whether version updates have been enabled/disabled
  // from the Tiltfile.
  // +optional
  optional VersionSettings versionSettings = 12;

  // TiltCloudUsername reports the username if the user is signed into
  // TiltCloud.
  // +optional
  optional string tiltCloudUsername = 5;

  // TiltCloudUsername reports the human-readable team name if the user is
  // signed into TiltCloud and the Tiltfile declares a team.
  // +optional
  optional string tiltCloudTeamName = 6;

  // TiltCloudSchemeHost reports the base URL of the Tilt Cloud instance
  // associated with this Tilt process. Usually https://cloud.tilt.dev
  // +optional
  optional string tiltCloudSchemeHost = 7;

  // TiltCloudTeamID reports the unique team id if the user is signed into
  // TiltCloud and the Tiltfile declares a team.
  // +optional
  optional string tiltCloudTeamID = 8;

  // A FatalError is an error that forces Tilt to stop its control loop.
  // The API server will stay up and continue to serve the UI, but
  // no further builds will happen.
  // +optional
  optional string fatalError = 9;

  // The time that this instance of tilt started.
  // Clients can use this to determine if the API server has restarted
  // and all the objects need to be refreshed.
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time tiltStartTime = 10;

  // An identifier for the Tiltfile that is running.
  // Clients can use this to store data associated with a particular
  // project in LocalStorage or other persistent storage.
  // +optional
  optional string tiltfileKey = 11;
}

// Describes a text input field attached to a button.
message UITextInputSpec {
  // Initial value for this field.
  //
  // +optional
  optional string defaultValue = 1;

  // A short hint that describes the expected input of this field.
  //
  // +optional
  optional string placeholder = 2;
}

message UITextInputStatus {
  // The content of the text input.
  optional string value = 1;
}

// Information about how the Tilt binary handles updates.
message VersionSettings {
  // Whether version updates have been enabled/disabled from the Tiltfile.
  // +optional
  optional bool checkUpdates = 1;
}


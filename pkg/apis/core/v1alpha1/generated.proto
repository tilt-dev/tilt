/*
Copyright 2020 The Tilt Dev Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// This file was autogenerated by go-to-protobuf. Do not edit it manually!

syntax = "proto2";

package github.com.tilt_dev.tilt.pkg.apis.core.v1alpha1;

import "k8s.io/apimachinery/pkg/apis/meta/v1/generated.proto";
import "k8s.io/apimachinery/pkg/runtime/schema/generated.proto";

// Package-wide variables from generator "generated".
option go_package = "v1alpha1";

// Cmd represents a process on the host machine.
//
// When the process exits, we will make a best-effort attempt
// (within OS limitations) to kill any spawned descendant processes.
//
// +k8s:openapi-gen=true
message Cmd {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional CmdSpec spec = 2;

  optional CmdStatus status = 3;
}

// CmdList
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message CmdList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated Cmd items = 2;
}

// CmdSpec defines how to run a local command.
message CmdSpec {
  // Command-line arguments. Must have length at least 1.
  repeated string args = 1;

  // Process working directory.
  //
  // If the working directory is not specified, the command is run
  // in the default Tilt working directory.
  //
  // +optional
  optional string dir = 2;

  // Additional variables process environment.
  //
  // Expressed as a C-style array of strings of the form ["KEY1=VALUE1", "KEY2=VALUE2", ...].
  //
  // Environment variables are layered on top of the environment variables
  // that Tilt runs with.
  //
  // +optional
  repeated string env = 3;

  // Periodic probe of service readiness.
  //
  // +optional
  optional Probe readinessProbe = 4;

  // Indicates objects that can trigger a restart of this command.
  //
  // When a restart is triggered, Tilt will try to gracefully shutdown any
  // currently running process, waiting for it to exit before starting a new
  // process. If the process doesn't shutdown within the allotted time, Tilt
  // will kill the process abruptly.
  //
  // Restarts can happen even if the command is already done.
  //
  // Logs of the current process after the restart are discarded.
  optional RestartOnSpec restartOn = 5;

  // Indicates objects that can trigger a start/restart of this command.
  //
  // Restarts behave the same as RestartOn. The key difference is that
  // a Cmd with any StartOn triggers will not have its command run until its
  // StartOn is satisfied.
  optional StartOnSpec startOn = 6;
}

// CmdStateRunning is a running state of a local command.
message CmdStateRunning {
  // The process id of the command.
  optional int32 pid = 1;

  // Time at which the command was last started.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime startedAt = 2;
}

// CmdStateTerminated is a terminated state of a local command.
message CmdStateTerminated {
  // The process id of the command.
  optional int32 pid = 1;

  // Exit status from the last termination of the command
  optional int32 exitCode = 2;

  // Time at which previous execution of the command started
  optional k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime startedAt = 3;

  // Time at which the command last terminated
  optional k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime finishedAt = 4;

  // (brief) reason the process is terminated
  // +optional
  optional string reason = 5;
}

// CmdStateWaiting is a waiting state of a local command.
message CmdStateWaiting {
  // (brief) reason the process is not yet running.
  // +optional
  optional string reason = 1;
}

// CmdStatus defines the observed state of Cmd
//
// Based loosely on ContainerStatus in Kubernetes
message CmdStatus {
  // Details about a waiting process.
  // +optional
  optional CmdStateWaiting waiting = 1;

  // Details about a running process.
  // +optional
  optional CmdStateRunning running = 2;

  // Details about a terminated process.
  // +optional
  optional CmdStateTerminated terminated = 3;

  // Specifies whether the command has passed its readiness probe.
  //
  // Terminating the command does not change its Ready state.
  //
  // Is always true when no readiness probe is defined.
  //
  // +optional
  optional bool ready = 4;
}

// Container is an init or application container within a pod.
//
// The Tilt API representation mirrors the Kubernetes API very closely. Irrelevant data is
// not included, and some fields might be simplified.
//
// There might also be Tilt-specific status fields.
message Container {
  // Name is the name of the container as defined in Kubernetes.
  optional string name = 1;

  // ID is the normalized container ID (the `docker://` prefix is stripped).
  optional string id = 2;

  // Ready is true if the container is passing readiness checks (or has none defined).
  optional bool ready = 3;

  // Image is the image the container is running.
  optional string image = 4;

  // Restarts is the number of times the container has restarted.
  //
  // This includes restarts before the Tilt daemon was started if the container was already running.
  optional int32 restarts = 5;

  // State provides details about the container's current condition.
  optional ContainerState state = 6;

  // Ports are exposed ports as extracted from the Pod spec.
  //
  // This is added by Tilt for convenience when managing port forwards.
  repeated int32 ports = 7;
}

// ContainerLogStreamStatus defines the current status of each individual
// container log stream.
message ContainerLogStreamStatus {
  // The name of the container.
  optional string name = 1;

  // True when the stream is set up and streaming logs properly.
  //
  // +optional
  optional bool active = 2;

  // True when the logs are done stream and the container is terminated.
  //
  // +optional
  optional bool terminated = 3;

  // The last error message encountered while streaming.
  //
  // Empty when the stream is actively streaming or successfully terminated.
  //
  // +optional
  optional string error = 4;
}

// ContainerState holds a possible state of container.
//
// Only one of its members may be specified.
// If none of them is specified, the default one is ContainerStateWaiting.
message ContainerState {
  // Waiting provides details about a container that is not yet running.
  optional ContainerStateWaiting waiting = 1;

  // Running provides details about a currently executing container.
  optional ContainerStateRunning running = 2;

  // Terminated provides details about an exited container.
  optional ContainerStateTerminated terminated = 3;
}

// ContainerStateRunning is a running state of a container.
message ContainerStateRunning {
  // StartedAt is the time the container began running.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time startedAt = 1;
}

// ContainerStateTerminated is a terminated state of a container.
message ContainerStateTerminated {
  // StartedAt is the time the container began running.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time startedAt = 1;

  // FinishedAt is the time the container stopped running.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time finishedAt = 2;

  // Reason is a (brief) reason the container stopped running.
  optional string reason = 3;

  // ExitCode is the exit status from the termination of the container.
  //
  // Any non-zero value indicates an error during termination.
  optional int32 exitCode = 4;
}

// ContainerStateWaiting is a waiting state of a container.
message ContainerStateWaiting {
  // Reason is a (brief) reason the container is not yet running.
  optional string reason = 1;
}

// ExecAction describes a "run in container" action.
message ExecAction {
  // Command is the command line to execute inside the container, the working directory for the
  // command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
  // not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
  // a shell, you need to explicitly call out to that shell.
  // Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
  // +optional
  repeated string command = 1;
}

message FileEvent {
  // Time is an approximate timestamp for a batch of file changes.
  //
  // This will NOT exactly match any inode attributes (e.g. ctime, mtime) at the filesystem level and is purely
  // informational or for use as an opaque watermark.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime time = 1;

  // SeenFiles is a list of paths which changed (create, modify, or delete).
  repeated string seenFiles = 2;
}

// FileWatch
// +k8s:openapi-gen=true
message FileWatch {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional FileWatchSpec spec = 2;

  optional FileWatchStatus status = 3;
}

// FileWatchList
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message FileWatchList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated FileWatch items = 2;
}

// FileWatchSpec defines the desired state of FileWatch
message FileWatchSpec {
  // WatchedPaths are paths of directories or files to watch for changes to. It cannot be empty.
  repeated string watchedPaths = 1;

  // Ignores are optional rules to filter out a subset of changes matched by WatchedPaths.
  repeated IgnoreDef ignores = 2;
}

// FileWatchStatus defines the observed state of FileWatch
message FileWatchStatus {
  // MonitorStartTime is the timestamp of when filesystem monitor was started. It is zero if the monitor has not
  // been started yet.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime monitorStartTime = 1;

  // LastEventTime is the timestamp of the most recent file event. It is zero if no events have been seen yet.
  //
  // If the specifics of which files changed are not important, this field can be used as a watermark without
  // needing to inspect FileEvents.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime lastEventTime = 2;

  // FileEvents summarizes batches of file changes (create, modify, or delete) that have been seen in ascending
  // chronological order. Only the most recent 20 events are included.
  repeated FileEvent fileEvents = 3;

  // Error is set if there is a problem with the filesystem watch. If non-empty, consumers should assume that
  // no filesystem events will be seen and that the file watcher is in a failed state.
  optional string error = 4;
}

// Forward defines a port forward to execute on a given pod.
message Forward {
  // The port to expose on the current machine.
  //
  // If not specified (or 0), a random free port will be chosen and can
  // be discovered via the status once established.
  //
  // +optional
  optional int32 localPort = 4;

  // The port on the Kubernetes pod to connect to. Required.
  optional int32 containerPort = 3;

  // Optional host to bind to on the current machine (localhost by default)
  //
  // +optional
  optional string host = 5;
}

message ForwardStatus {
  // LocalPort is the port bound to on the system running Tilt.
  optional int32 localPort = 1;

  // ContainerPort is the port in the container being forwarded.
  optional int32 containerPort = 2;

  // Addresses that the forwarder is bound to.
  //
  // For example, a `localhost` host will bind to 127.0.0.1 and [::1].
  repeated string addresses = 3;

  // StartedAt is the time at which the forward was initiated.
  //
  // If the forwarder is not running yet, this will be zero/empty.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime startedAt = 4;

  // Error is a human-readable description if a problem was encountered
  // while initializing the forward.
  optional string error = 5;
}

// HTTPGetAction describes an action based on HTTP Get requests.
message HTTPGetAction {
  // Path to access on the HTTP server.
  // +optional
  optional string path = 1;

  // Name or number of the port to access on the container.
  // Number must be in the range 1 to 65535.
  optional int32 port = 2;

  // Host name to connect to, defaults to the pod IP. You probably want to set
  // "Host" in httpHeaders instead.
  // +optional
  optional string host = 3;

  // Scheme to use for connecting to the host.
  // Defaults to HTTP.
  // +optional
  optional string scheme = 4;

  // Custom headers to set in the request. HTTP allows repeated headers.
  // +optional
  repeated HTTPHeader httpHeaders = 5;
}

// HTTPHeader describes a custom header to be used in HTTP probes
message HTTPHeader {
  // The header field name
  optional string name = 1;

  // The header field value
  optional string value = 2;
}

// Handler defines a specific action that should be taken in a probe.
message Handler {
  // One and only one of the following should be specified.
  // Exec specifies the action to take.
  // +optional
  optional ExecAction exec = 1;

  // HTTPGet specifies the http request to perform.
  // +optional
  optional HTTPGetAction httpGet = 2;

  // TCPSocket specifies an action involving a TCP port.
  // TCP hooks not yet supported
  // TODO: implement a realistic TCP lifecycle hook
  // +optional
  optional TCPSocketAction tcpSocket = 3;
}

message IgnoreDef {
  // BasePath is the base path for the patterns. It cannot be empty.
  //
  // If no patterns are specified, everything under it will be recursively ignored.
  optional string basePath = 1;

  // Patterns are dockerignore style rules. Absolute-style patterns will be rooted to the BasePath.
  //
  // See https://docs.docker.com/engine/reference/builder/#dockerignore-file.
  repeated string patterns = 2;
}

// ImageMap expresses the mapping from an image reference to a real, pushed
// image in an image registry that a container runtime can access.
//
// Another way to think about the ImageMap is that ImageMapSpec is a mutable
// image reference (where the image might not exist yet), but ImageMapStatus is
// an immutable image reference (where, if an image is specified, it always
// exists).
//
// ImageMap does not specify how the image is built or who is responsible for
// building this. But any API that builds images should produce an ImageMap.
//
// For example, a builder that builds to a local image registry might create
// a map from: 'my-apiserver:dev' to 'localhost:5000/my-apiserver:content-based-label'.
//
// ImageMap doesn't follow the usual Kubernetes-style API semantics
// (where the Status is the result of running the Spec). It's closer to a
// ConfigMap. Though the Status does represent a real runtime result
// (an image in a registry).
//
// +k8s:openapi-gen=true
message ImageMap {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional ImageMapSpec spec = 2;

  optional ImageMapStatus status = 3;
}

// ImageMapList
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message ImageMapList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated ImageMap items = 2;
}

// ImageMapArgsOverride defines args to inject when the image
// is injected. Only applies to types that embed a v1.Container
// with a Command field.
//
// https://pkg.go.dev/k8s.io/api/core/v1#Container
message ImageMapOverrideArgs {
  // A list of args strings.
  repeated string args = 1;
}

// ImageMapCommandOverride defines a command to inject when the image
// is injected. Only applies to types that embed a v1.Container
// with a Command field.
//
// https://pkg.go.dev/k8s.io/api/core/v1#Container
message ImageMapOverrideCommand {
  // A list of command strings.
  repeated string command = 1;
}

// ImageMapSpec defines the desired state of ImageMap
message ImageMapSpec {
  // A named image reference.
  //
  // Deployment tools expect this image reference to match an image
  // in the YAML being deployed, and will replace that image reference.
  //
  // By default, this selector will match an image if the names match
  // (tags on both the selector and the matched reference are ignored).
  optional string selector = 1;

  // If specified, then tags on both the selector and the matched
  // reference are used for matching. The selector will only
  // match the reference if the tags match exactly.
  //
  // +optional
  optional bool matchExact = 2;

  // If specified, then the selector will also match any strings
  // in container env variables.
  //
  // +optional
  optional bool matchInEnvVars = 3;

  // If specified, the injector will replace the 'command'
  // field in the container when it replaces the image.
  //
  // +optional
  optional ImageMapOverrideCommand overrideCommand = 4;

  // If specified, the injector will replace the 'args'
  // field in the container when it replaces the image.
  //
  // +optional
  optional ImageMapOverrideArgs overrideArgs = 5;
}

// ImageMapStatus defines the observed state of ImageMap
message ImageMapStatus {
  // A fully-qualified image reference, including a name and an immutable tag.
  //
  // The image will not necessarily have the same repo URL as the selector. Many
  // Kubernetes clusters let you push to a local registry for local development.
  optional string image = 1;
}

// KubernetesApply specifies a blob of YAML to apply, and a set of ImageMaps
// that the YAML depends on.
//
// The KubernetesApply controller will resolve the ImageMaps into immutable image
// references. The controller will process the spec YAML, then apply it to the cluster.
// Those processing steps might include:
//
// - Injecting the resolved image references.
// - Adding custom labels so that Tilt can track the progress of the apply.
// - Modifying image pull rules to ensure the image is pulled correctly.
//
// The controller won't apply anything until all ImageMaps resolve to real images.
//
// The controller will watch all the image maps, and redeploy the entire YAML if
// any of the maps resolve to a new image.
//
// The status field will contain both the raw applied object, and derived fields
// to help other controllers figure out how to watch the apply progress.
//
// +k8s:openapi-gen=true
message KubernetesApply {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional KubernetesApplySpec spec = 2;

  optional KubernetesApplyStatus status = 3;
}

// KubernetesApplyList
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message KubernetesApplyList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated KubernetesApply items = 2;
}

// KubernetesApplySpec defines the desired state of KubernetesApply
message KubernetesApplySpec {
  // The YAML to apply to the cluster. Required.
  optional string yaml = 1;

  // Names of image maps that this applier depends on.
  //
  // The controller will watch all the image maps, and redeploy the entire YAML
  // if any of the maps resolve to a new image.
  //
  // +optional
  repeated string imageMaps = 2;

  // Descriptors of how to find images in the YAML.
  //
  // Needed when injecting images into CRDs.
  //
  // +optional
  repeated KubernetesImageLocator imageLocators = 3;

  // The timeout on the apply operation.
  //
  // We've had problems with both:
  // 1) CRD apiservers that take an arbitrarily long time to apply, and
  // 2) Infinite loops in the apimachinery
  // So we offer the ability to set a timeout on Kubernetes apply operations.
  //
  // The default timeout is 30s.
  //
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Duration timeout = 4;

  // KubernetesDiscoveryTemplateSpec describes how we discover pods
  // for resources created by this Apply.
  //
  // If not specified, the KubernetesDiscovery controller will listen to all pods,
  // and follow owner references to find the pods owned by these resources.
  //
  // +optional
  optional KubernetesDiscoveryTemplateSpec kubernetesDiscoveryTemplateSpec = 5;

  // PortForwardTemplateSpec describes the data model for port forwards
  // that KubernetesApply should set up.
  //
  // Underneath the hood, we'll create a KubernetesDiscovery object that finds
  // the pods and sets up the port-forwarding. Only one PortForward will be
  // active at a time.
  //
  // +optional
  optional PortForwardTemplateSpec portForwardTemplateSpec = 6;

  // PodLogStreamTemplateSpec describes the data model for PodLogStreams
  // that KubernetesApply should set up.
  //
  // Underneath the hood, we'll create a KubernetesDiscovery object that finds
  // the pods and sets up the pod log streams.
  //
  // If no template is specified, the controller will stream all
  // pod logs available from the apiserver.
  //
  // +optional
  optional PodLogStreamTemplateSpec podLogStreamTemplateSpec = 7;
}

// KubernetesApplyStatus defines the observed state of KubernetesApply
message KubernetesApplyStatus {
  // The result of applying the YAML to the cluster. This should contain
  // UIDs for the applied resources.
  //
  // +optional
  optional string resultYAML = 1;

  // An error applying the YAML.
  //
  // If there was an error, than ResultYAML should be empty (and vice versa).
  //
  // +optional
  optional string error = 2;

  // The last time the controller tried to apply YAML.
  //
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime lastApplyTime = 3;

  // A base64-encoded hash of all the inputs to the apply.
  //
  // We added this so that more procedural code can determine whether
  // their updates have been applied yet or not by the reconciler. But any code
  // using it this way should note that the reconciler may "skip" an update
  // (e.g., if two images get updated in quick succession before the reconciler
  // injects them into the YAML), so a particular ApplieInputHash might never appear.
  //
  // +optional
  optional string appliedInputHash = 4;
}

// KubernetesDiscovery
// +k8s:openapi-gen=true
message KubernetesDiscovery {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional KubernetesDiscoverySpec spec = 2;

  optional KubernetesDiscoveryStatus status = 3;
}

// KubernetesDiscoveryList
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message KubernetesDiscoveryList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated KubernetesDiscovery items = 2;
}

// KubernetesDiscoverySpec defines the desired state of KubernetesDiscovery
message KubernetesDiscoverySpec {
  // Watches determine what resources are discovered.
  //
  // If a discovered resource (e.g. Pod) matches the KubernetesWatchRef UID exactly, it will be reported.
  // If a discovered resource is transitively owned by the KubernetesWatchRef UID, it will be reported.
  repeated KubernetesWatchRef watches = 1;

  // ExtraSelectors are label selectors that will force discovery of a Pod even if it does not match
  // the AncestorUID.
  //
  // This should only be necessary in the event that a CRD creates Pods but does not set an owner reference
  // to itself.
  repeated k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector extraSelectors = 2;

  // PortForwardTemplateSpec describes the data model for port forwards
  // that KubernetesDiscovery should set up.
  //
  // The KubernetesDiscovery controller will choose a "best" candidate
  // for attaching the port-forwarding. Only one PortForward will be
  // active at a time.
  //
  // +optional
  optional PortForwardTemplateSpec portForwardTemplateSpec = 3;

  // PodLogStreamTemplateSpec describes the data model for PodLogStreams
  // that KubernetesDiscovery should set up.
  //
  // The KubernetesDiscovery controller will attach PodLogStream objects
  // to all active pods it discovers.
  //
  // If no template is specified, the controller will stream all
  // pod logs available from the apiserver.
  //
  // +optional
  optional PodLogStreamTemplateSpec podLogStreamTemplateSpec = 4;
}

// KubernetesDiscoveryStatus defines the observed state of KubernetesDiscovery
message KubernetesDiscoveryStatus {
  // MonitorStartTime is the timestamp of when Kubernetes resource discovery was started.
  //
  // It is zero if discovery has not been started yet.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime monitorStartTime = 2;

  // Pods that have been discovered based on the criteria in the spec.
  repeated Pod pods = 1;
}

message KubernetesDiscoveryTemplateSpec {
  // ExtraSelectors are label selectors that will force discovery of a Pod even
  // if it does not match the AncestorUID.
  //
  // This should only be necessary in the event that a CRD creates Pods but does
  // not set an owner reference to itself.
  repeated k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector extraSelectors = 1;
}

// Finds image references in Kubernetes YAML.
message KubernetesImageLocator {
  // Selects which objects to look in.
  optional ObjectSelector objectSelector = 1;

  // A JSON path to the image reference field.
  //
  // If Object is empty, the field should be a string.
  //
  // If Object is non-empty, the field should be an object with subfields.
  optional string path = 2;

  // A descriptor of the path and structure of an object that describes an image
  // reference. This is a common way to describe images in CRDs, breaking
  // them down into an object rather than an image reference string.
  //
  // +optional
  optional KubernetesImageObjectDescriptor object = 3;
}

message KubernetesImageObjectDescriptor {
  // The name of the field that contains the image repository.
  optional string repoField = 1;

  // The name of the field that contains the image tag.
  optional string tagField = 2;
}

// KubernetesWatchRef is similar to v1.ObjectReference from the Kubernetes API and is used to determine
// what objects should be reported on based on discovery.
message KubernetesWatchRef {
  // UID is a Kubernetes object UID.
  //
  // It should either be the exact object UID or the transitive owner.
  optional string uid = 1;

  // Namespace is the Kubernetes namespace for discovery. Required.
  optional string namespace = 2;

  // Name is the Kubernetes object name.
  //
  // This is not directly used in discovery; it is extra metadata.
  optional string name = 3;
}

// Selector for any Kubernetes-style API.
message ObjectSelector {
  // A regular expression apiVersion match.
  // +optional
  optional string apiVersionRegexp = 1;

  // A regular expression kind match.
  // +optional
  optional string kindRegexp = 2;

  // A regular expression name match.
  // +optional
  optional string nameRegexp = 3;

  // A regular expression namespace match.
  // +optional
  optional string namespaceRegexp = 4;
}

// Pod is a collection of containers that can run on a host.
//
// The Tilt API representation mirrors the Kubernetes API very closely. Irrelevant data is
// not included, and some fields might be simplified.
//
// There might also be Tilt-specific status fields.
message Pod {
  // UID is the unique Pod UID within the K8s cluster.
  optional string uid = 14;

  // Name is the Pod name within the K8s cluster.
  optional string name = 1;

  // Namespace is the Pod namespace within the K8s cluster.
  optional string namespace = 2;

  // CreatedAt is when the Pod was created.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time createdAt = 3;

  // Phase is where the Pod is at in its current lifecycle.
  //
  // Valid values for this are v1.PodPhase values from the Kubernetes API.
  optional string phase = 4;

  // Deleting indicates that the Pod is in the process of being removed.
  optional bool deleting = 5;

  // Conditions are various lifecycle conditions for this Pod.
  //
  // See also v1.PodCondition in the Kubernetes API.
  repeated PodCondition conditions = 6;

  // InitContainers are containers executed prior to the Pod containers being executed.
  repeated Container initContainers = 7;

  // Containers are the containers belonging to the Pod.
  repeated Container containers = 8;

  // AncestorUID is the UID from the WatchRef that matched this Pod.
  //
  // If the Pod matched based on extra label selectors, this will be empty.
  //
  // +optional
  optional string ancestorUID = 15;

  // PodTemplateSpecHash is a hash of the Pod template spec.
  //
  // Tilt uses this to associate Pods with the build that triggered them.
  optional string podTemplateSpecHash = 10;

  // Status is a concise description for the Pod's current state.
  //
  // This is based off the status output from `kubectl get pod` and is not an "enum-like"
  // value.
  optional string status = 12;

  // Errors are aggregated error messages for the Pod and its containers.
  repeated string errors = 13;
}

// PodCondition is a lifecycle condition for a Pod.
message PodCondition {
  // Type is the type of condition.
  //
  // Valid values for this are v1.PodConditionType values from the Kubernetes API.
  optional string type = 1;

  // Status is the current state of the condition (True, False, or Unknown).
  //
  // Valid values for this are v1.PodConditionStatus values from the Kubernetes API.
  optional string status = 2;

  // LastTransitionTime is the last time the status changed.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;

  // Reason is a unique, one-word, CamelCase value for the cause of the last status change.
  optional string reason = 4;

  // Message is a human-readable description of the last status change.
  optional string message = 5;
}

// PodLogStream
//
// Streams logs from a pod on Kubernetes into the core Tilt engine.
//
// +k8s:openapi-gen=true
message PodLogStream {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional PodLogStreamSpec spec = 2;

  optional PodLogStreamStatus status = 3;
}

// PodLogStreamList
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message PodLogStreamList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated PodLogStream items = 2;
}

// PodLogStreamSpec defines the desired state of PodLogStream
//
// Translated into a PodLog query to the current Kubernetes cluster:
// https://pkg.go.dev/k8s.io/api/core/v1#PodLogOptions
//
// TODO(nick): Should all Kubernetes types have an object that describes
// which Kubernetes context to use?
message PodLogStreamSpec {
  // The name of the pod to watch. Required.
  optional string pod = 1;

  // The namespace of the pod to watch. Defaults to the kubecontext default namespace.
  //
  // +optional
  optional string namespace = 2;

  // An RFC3339 timestamp from which to show logs. If this value
  // precedes the time a pod was started, only logs since the pod start will be returned.
  // If this value is in the future, no logs will be returned.
  //
  // Translates directly to the underlying PodLogOptions.
  //
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time sinceTime = 3;

  // The names of containers to include in the stream.
  //
  // If `onlyContainers` and `ignoreContainers` are not set,
  // will watch all containers in the pod.
  //
  // +optional
  repeated string onlyContainers = 4;

  // The names of containers to exclude from the stream.
  //
  // If `onlyContainers` and `ignoreContainers` are not set,
  // will watch all containers in the pod.
  //
  // +optional
  repeated string ignoreContainers = 5;
}

// PodLogStreamStatus defines the observed state of PodLogStream
//
// TODO(nick): rewrite this status field, i don't think this is quite right.
message PodLogStreamStatus {
  // A list of containers being watched.
  //
  // +optional
  repeated ContainerLogStreamStatus containerStatuses = 1;
}

// PodLogStreamTemplateSpec describes common attributes for PodLogStreams
// that can be shared across pods.
message PodLogStreamTemplateSpec {
  // An RFC3339 timestamp from which to show logs. If this value
  // precedes the time a pod was started, only logs since the pod start will be returned.
  // If this value is in the future, no logs will be returned.
  //
  // Translates directly to the underlying PodLogOptions.
  //
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time sinceTime = 1;

  // The names of containers to include in the stream.
  //
  // If `onlyContainers` and `ignoreContainers` are not set,
  // will watch all containers in the pod.
  //
  // +optional
  repeated string onlyContainers = 2;

  // The names of containers to exclude from the stream.
  //
  // If `onlyContainers` and `ignoreContainers` are not set,
  // will watch all containers in the pod.
  //
  // +optional
  repeated string ignoreContainers = 3;
}

// PortForward
// +k8s:openapi-gen=true
message PortForward {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional PortForwardSpec spec = 2;

  optional PortForwardStatus status = 3;
}

// PortForwardList
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message PortForwardList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated PortForward items = 2;
}

// PortForwardSpec defines the desired state of PortForward
message PortForwardSpec {
  // The name of the pod to port forward to/from. Required.
  optional string podName = 1;

  // The namespace of the pod to port forward to/from. Defaults to the kubecontext default namespace.
  //
  // +optional
  optional string namespace = 2;

  // One or more port forwards to execute on the given pod. Required.
  repeated Forward forwards = 3;
}

// PortForwardStatus defines the observed state of PortForward
message PortForwardStatus {
  repeated ForwardStatus forwardStatuses = 2;
}

// PortForwardTemplateSpec describes common attributes for PortForwards
// that can be shared across pods.
message PortForwardTemplateSpec {
  // One or more port forwards to execute on the given pod. Required.
  repeated Forward forwards = 1;
}

// Probe describes a health check to be performed o determine whether it is
// alive or ready to receive traffic.
message Probe {
  // The action taken to determine the health of a container
  optional Handler handler = 1;

  // Number of seconds after the container has started before liveness probes are initiated.
  // More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
  // +optional
  optional int32 initialDelaySeconds = 2;

  // Number of seconds after which the probe times out.
  // Defaults to 1 second. Minimum value is 1.
  // More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
  // +optional
  optional int32 timeoutSeconds = 3;

  // How often (in seconds) to perform the probe.
  // Default to 10 seconds. Minimum value is 1.
  // +optional
  optional int32 periodSeconds = 4;

  // Minimum consecutive successes for the probe to be considered successful after having failed.
  // Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
  // +optional
  optional int32 successThreshold = 5;

  // Minimum consecutive failures for the probe to be considered failed after having succeeded.
  // Defaults to 3. Minimum value is 1.
  // +optional
  optional int32 failureThreshold = 6;
}

// RestartOnSpec indicates the set of objects that can trigger a restart of this object.
message RestartOnSpec {
  // A list of file watches that can trigger a restart.
  repeated string fileWatches = 1;
}

// Session provides introspective data about the status of the Tilt process.
// +k8s:openapi-gen=true
message Session {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional SessionSpec spec = 2;

  optional SessionStatus status = 3;
}

// SessionList is a list of Session objects.
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message SessionList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated Session items = 2;
}

// SessionSpec defines the desired state of Session
message SessionSpec {
  // TiltfilePath is the path to the Tiltfile for the run. It cannot be empty.
  optional string tiltfilePath = 1;

  // ExitCondition defines the criteria for Tilt to exit.
  optional string exitCondition = 2;
}

// SessionStatus defines the observed state of Session
message SessionStatus {
  // PID is the process identifier for this instance of Tilt.
  optional int64 pid = 1;

  // StartTime is when the Tilt engine was first started.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime startTime = 2;

  // Targets are normalized representations of the servers/jobs managed by this Session.
  //
  // A resource from a Tiltfile might produce one or more targets. A target can also be shared across
  // multiple resources (e.g. an image referenced by multiple K8s pods).
  repeated Target targets = 3;

  // Done indicates whether this Session has completed its work and is ready to exit.
  optional bool done = 4;

  // Error is a non-empty string when the Session is Done but encountered a failure as defined by the ExitCondition
  // from the SessionSpec.
  //
  // +optional
  optional string error = 5;
}

// StartOnSpec indicates the set of objects that can trigger a start/restart of this object.
message StartOnSpec {
  // Any events that predate this time will be ignored.
  //
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time startAfter = 1;

  // A list of ui buttons that can trigger a run.
  repeated string uiButtons = 2;
}

// TCPSocketAction describes an action based on opening a socket
message TCPSocketAction {
  // Number or name of the port to access on the container.
  // Number must be in the range 1 to 65535.
  optional int32 port = 1;

  // Optional: Host name to connect to, defaults to the pod IP.
  // +optional
  optional string host = 2;
}

// Target is a server or job whose execution is managed as part of this Session.
message Target {
  // Name is the name of the target; this is auto-generated from Tiltfile resources.
  optional string name = 1;

  // Type is the execution profile for this resource.
  //
  // Job targets run to completion (e.g. a build script or database migration script).
  // Server targets run indefinitely (e.g. an HTTP server).
  optional string type = 2;

  // Resources are one or more Tiltfile resources that this target is associated with.
  repeated string resources = 3;

  // State provides information about the current status of the target.
  optional TargetState state = 4;
}

// TargetState describes the current execution status for a target.
//
// Either EXACTLY one of Waiting, Active, or Terminated will be populated or NONE of them will be.
// In the event that all states are null, the target is currently inactive or disabled and should not
// be expected to execute.
message TargetState {
  // Waiting being non-nil indicates that the next execution of the target has been queued but not yet started.
  //
  // +optional
  optional TargetStateWaiting waiting = 1;

  // Active being non-nil indicates that the target is currently executing.
  //
  // +optional
  optional TargetStateActive active = 2;

  // Terminated being non-nil indicates that the target finished execution either normally or due to failure.
  //
  // +optional
  optional TargetStateTerminated terminated = 3;
}

// TargetStateActive is a target that is currently running but has not yet finished.
message TargetStateActive {
  // StartTime is when execution began.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime startTime = 1;

  // Ready indicates that the target has passed readiness checks.
  //
  // If the target does not use or support readiness checks, this is always true.
  optional bool ready = 2;
}

// TargetStateTerminated is a target that finished running, either because it completed successfully or
// encountered an error.
message TargetStateTerminated {
  // StartTime is when the target began executing.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime startTime = 1;

  // FinishTime is when the target stopped executing.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime finishTime = 2;

  // Error is a non-empty string if the target encountered a failure during execution that caused it to stop.
  //
  // For targets of type TargetTypeServer, this is always populated, as the target is expected to run indefinitely,
  // and thus any termination is an error.
  //
  // +optional
  optional string error = 3;
}

// TargetStateWaiting is a target that has been enqueued for execution but has not yet started.
message TargetStateWaiting {
  // WaitReason is a description for why the target is waiting and not yet active.
  //
  // This is NOT the "cause" or "trigger" for the target being invoked.
  optional string waitReason = 1;
}

// Information about the running tilt binary.
message TiltBuild {
  // A semantic version string.
  // +optional
  optional string version = 1;

  // The Git digest of the commit this binary was built at.
  // +optional
  optional string commitSHA = 2;

  // A human-readable string representing when the binary was built.
  // +optional
  optional string date = 3;

  // Indicates whether this is a development build (true) or an official release (false).
  // +optional
  optional bool dev = 4;
}

// UIBuildRunning respresents an in-progress build/update in the user interface.
message UIBuildRunning {
  // The time when the build started.
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime startTime = 1;

  // The log span where the build logs are stored in the logstore.
  // +optional
  optional string spanID = 2;
}

// UIBuildRunning respresents a finished build/update in the user interface.
message UIBuildTerminated {
  // A non-empty string if the build failed with an error.
  // +optional
  optional string error = 1;

  // A list of warnings encountered while running the build.
  // These warnings will also be printed to the build's log.
  // +optional
  repeated string warnings = 2;

  // The time when the build started.
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime startTime = 3;

  // The time when the build finished.
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime finishTime = 4;

  // The log span where the build logs are stored in the logstore.
  // +optional
  optional string spanID = 5;

  // A crash rebuild happens when Tilt live-updated a container, then
  // the pod crashed, wiping out the live-updates. Tilt does a full
  // build+deploy to reset the pod state to what's on disk.
  // +optional
  optional bool isCrashRebuild = 6;
}

// UIButton
// +k8s:openapi-gen=true
message UIButton {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional UIButtonSpec spec = 2;

  optional UIButtonStatus status = 3;
}

// UIButtonList
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message UIButtonList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated UIButton items = 2;
}

// UIButtonSpec defines the desired state of UIButton
message UIButtonSpec {
  // Location associates the button with another component for layout.
  optional UIComponentLocation location = 1;

  // Text to appear on the button itself or as hover text (depending on button location).
  optional string text = 2;

  // IconName is a Material Icon to appear next to button text or on the button itself (depending on button location).
  //
  // Valid values are icon font ligature names from the Material Icons set.
  // See https://fonts.google.com/icons for the full list of available icons.
  //
  // If both IconSVG and IconName are specified, IconSVG will take precedence.
  //
  // +optional
  optional string iconName = 3;

  // IconSVG is an SVG to use as the icon to appear next to button text or on the button itself (depending on button
  // location).
  //
  // This should be an <svg> element scaled for a 24x24 viewport.
  //
  // If both IconSVG and IconName are specified, IconSVG will take precedence.
  //
  // +optional
  optional string iconSVG = 4;
}

// UIButtonStatus defines the observed state of UIButton
message UIButtonStatus {
  // LastClickedAt is the timestamp of the last time the button was clicked.
  //
  // If the button has never clicked before, this will be the zero-value/null.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime lastClickedAt = 1;
}

// UIComponentLocation specifies where to put a UI component.
message UIComponentLocation {
  // ComponentID is the identifier of the parent component to associate this component with.
  //
  // For example, this is a resource name if the ComponentType is Resource.
  optional string componentID = 1;

  // ComponentType is the type of the parent component.
  optional string componentType = 2;
}

message UIComponentLocationResource {
  optional string resourceName = 1;
}

// Configures Tilt to enable non-default features (e.g., experimental or
// deprecated).
//
// The Tilt features controlled by this are generally in an unfinished state,
// and not yet documented.
//
// As a Tilt user, you don’t need to worry about this unless something
// else directs you to (e.g., an experimental feature doc, or a conversation
// with a Tilt contributor).
message UIFeatureFlag {
  // The name of the flag.
  // +optional
  optional string name = 1;

  // The value of the flag.
  // +optional
  optional bool value = 2;
}

// UIResource represents per-resource status data for rendering the web UI.
//
// Treat this as a legacy data structure that's more intended to make transition
// easier rather than a robust long-term API.
//
// +k8s:openapi-gen=true
message UIResource {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional UIResourceSpec spec = 2;

  optional UIResourceStatus status = 3;
}

// UIResourceKubernetes contains status information specific to Kubernetes.
message UIResourceKubernetes {
  // The name of the active pod.
  //
  // The active pod tends to be what Tilt defaults to for port-forwards,
  // live-updates, etc.
  // +optional
  optional string podName = 1;

  // The creation time of the active pod.
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time podCreationTime = 2;

  // The last update time of the active pod
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time podUpdateStartTime = 3;

  // The status of the active pod.
  // +optional
  optional string podStatus = 4;

  // Extra error messaging around the current status of the active pod.
  // +optional
  optional string podStatusMessage = 5;

  // Whether all the containers in the pod are currently healthy
  // and have passed readiness checks.
  // +optional
  optional bool allContainersReady = 6;

  // The number of pod restarts.
  // +optional
  optional int32 podRestarts = 7;

  // The span where this pod stores its logs in the Tilt logstore.
  // +optional
  optional string spanID = 8;

  // The list of all resources deployed in the Kubernetes deploy
  // for this resource.
  // +optional
  repeated string displayNames = 9;
}

// UIResourceLink represents a link assocatiated with a UIResource.
message UIResourceLink {
  // A URL to link to.
  // +optional
  optional string url = 1;

  // The display label on a URL.
  // +optional
  optional string name = 2;
}

// UIResourceList
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message UIResourceList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated UIResource items = 2;
}

// UIResourceLocal contains status information specific to local commands.
message UIResourceLocal {
  // The PID of the actively running local command.
  // +optional
  optional int64 pid = 1;

  // Whether this represents a test job.
  // +optional
  optional bool isTest = 2;
}

// UIResourceSpec is an empty struct.
// UIResource is a kludge for making Tilt's internal status readable, not
// for specifying behavior.
message UIResourceSpec {
}

// UIResourceStatus defines the observed state of UIResource
message UIResourceStatus {
  // The last time this resource was deployed.
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime lastDeployTime = 1;

  // Bit mask representing whether this resource is run when:
  // 1) When a file changes
  // 2) When the resource initializes
  // +optional
  optional int32 triggerMode = 2;

  // Past completed builds.
  // +optional
  repeated UIBuildTerminated buildHistory = 3;

  // The currently running build, if any.
  // +optional
  optional UIBuildRunning currentBuild = 4;

  // When the build was put in the pending queue.
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime pendingBuildSince = 5;

  // True if the build was put in the pending queue due to file changes.
  // +optional
  optional bool hasPendingChanges = 6;

  // Links attached to this resource.
  // +optional
  repeated UIResourceLink endpointLinks = 7;

  // Extra data about Kubernetes resources.
  // +optional
  optional UIResourceKubernetes k8sResourceInfo = 8;

  // Extra data about Local resources
  // +optional
  optional UIResourceLocal localResourceInfo = 9;

  // The RuntimeStatus is a simple, high-level summary of the runtime state of a server.
  //
  // Not all resources run servers.
  // +optional
  optional string runtimeStatus = 10;

  // The UpdateStatus is a simple, high-level summary of any update tasks to bring
  // the resource up-to-date.
  //
  // If the resource runs a server, this may include both build tasks and live-update
  // syncing.
  // +optional
  optional string updateStatus = 14;

  // Information about all the target specs that this resource summarizes.
  // +optional
  repeated UIResourceTargetSpec specs = 12;

  // Queued is a simple indicator of whether the resource is queued for an update.
  // +optional
  optional bool queued = 13;

  // Order expresses the relative order of resources in the UI when they're not
  // otherwise sorted. Lower integers go first. When two resources have the same
  // order, they should be sorted by name.
  //
  // When UIResources are generated from the Tiltfile, we use the order they
  // were added to the Tiltfile for the Order field.
  //
  // +optional
  optional int32 order = 15;
}

// UIResourceTargetSpec represents the spec of a build or deploy that a resource summarizes.
message UIResourceTargetSpec {
  // The ID of the target.
  // +optional
  optional string id = 1;

  // The type of the target.
  // +optional
  optional string type = 2;

  // Whether the target has a live update assocated with it.
  // +optional
  optional bool hasLiveUpdate = 3;
}

// UISession represents global status data for rendering the web UI.
//
// Treat this as a legacy data structure that's more intended to make transition
// easier rather than a robust long-term API.
//
// Per-resource status data should be stored in UIResource.
//
// +k8s:openapi-gen=true
message UISession {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional UISessionSpec spec = 2;

  optional UISessionStatus status = 3;
}

// UISessionList
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message UISessionList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated UISession items = 2;
}

// UISessionSpec is an empty struct.
// UISession is a kludge for making Tilt's internal status readable, not
// for specifying behavior.
message UISessionSpec {
}

// UISessionStatus defines the observed state of UISession
message UISessionStatus {
  // FeatureFlags reports a list of experimental features that have been
  // enabled.
  // +optional
  repeated UIFeatureFlag featureFlags = 1;

  // NeedsAnalyticsNudge reports whether the UI hasn't opted in or out
  // of analytics, and the UI should nudge them to do so.
  // +optional
  optional bool needsAnalyticsNudge = 2;

  // RunningTiltBuild reports the currently running version of tilt
  // that this UI is talking to.
  // +optional
  optional TiltBuild runningTiltBuild = 3;

  // SuggestedTiltVersion tells the UI the recommended version for this
  // user. If the version is different than what's running, the UI
  // may display a prompt to upgrade.
  // +optional
  optional string suggestedTiltVersion = 4;

  // VersionSettings indicates whether version updates have been enabled/disabled
  // from the Tiltfile.
  // +optional
  optional VersionSettings versionSettings = 12;

  // TiltCloudUsername reports the username if the user is signed into
  // TiltCloud.
  // +optional
  optional string tiltCloudUsername = 5;

  // TiltCloudUsername reports the human-readable team name if the user is
  // signed into TiltCloud and the Tiltfile declares a team.
  // +optional
  optional string tiltCloudTeamName = 6;

  // TiltCloudSchemeHost reports the base URL of the Tilt Cloud instance
  // associated with this Tilt process. Usually https://cloud.tilt.dev
  // +optional
  optional string tiltCloudSchemeHost = 7;

  // TiltCloudTeamID reports the unique team id if the user is signed into
  // TiltCloud and the Tiltfile declares a team.
  // +optional
  optional string tiltCloudTeamID = 8;

  // A FatalError is an error that forces Tilt to stop its control loop.
  // The API server will stay up and continue to serve the UI, but
  // no further builds will happen.
  // +optional
  optional string fatalError = 9;

  // The time that this instance of tilt started.
  // Clients can use this to determine if the API server has restarted
  // and all the objects need to be refreshed.
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time tiltStartTime = 10;

  // An identifier for the Tiltfile that is running.
  // Clients can use this to store data associated with a particular
  // project in LocalStorage or other persistent storage.
  // +optional
  optional string tiltfileKey = 11;
}

// Information about how the Tilt binary handles updates.
message VersionSettings {
  // Whether version updates have been enabled/disabled from the Tiltfile.
  // +optional
  optional bool checkUpdates = 1;
}


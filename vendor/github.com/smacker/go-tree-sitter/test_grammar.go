//Code generated by test_grammar_generate.sh; DO NOT EDIT.
package sitter
//#ifndef TREE_SITTER_PARSER_H_
//#define TREE_SITTER_PARSER_H_
//
//#ifdef __cplusplus
//extern "C" {
//#endif
//
//#include <stdbool.h>
//#include <stdint.h>
//#include <stdlib.h>
//
//#define ts_builtin_sym_error ((TSSymbol)-1)
//#define ts_builtin_sym_end 0
//#define TREE_SITTER_SERIALIZATION_BUFFER_SIZE 1024
//
//typedef uint16_t TSStateId;
//
//#ifndef TREE_SITTER_API_H_
//typedef uint16_t TSSymbol;
//typedef uint16_t TSFieldId;
//typedef struct TSLanguage TSLanguage;
//#endif
//
//typedef struct {
//  TSFieldId field_id;
//  uint8_t child_index;
//  bool inherited;
//} TSFieldMapEntry;
//
//typedef struct {
//  uint16_t index;
//  uint16_t length;
//} TSFieldMapSlice;
//
//typedef struct {
//  bool visible;
//  bool named;
//  bool supertype;
//} TSSymbolMetadata;
//
//typedef struct TSLexer TSLexer;
//
//struct TSLexer {
//  int32_t lookahead;
//  TSSymbol result_symbol;
//  void (*advance)(TSLexer *, bool);
//  void (*mark_end)(TSLexer *);
//  uint32_t (*get_column)(TSLexer *);
//  bool (*is_at_included_range_start)(const TSLexer *);
//  bool (*eof)(const TSLexer *);
//};
//
//typedef enum {
//  TSParseActionTypeShift,
//  TSParseActionTypeReduce,
//  TSParseActionTypeAccept,
//  TSParseActionTypeRecover,
//} TSParseActionType;
//
//typedef union {
//  struct {
//    uint8_t type;
//    TSStateId state;
//    bool extra;
//    bool repetition;
//  } shift;
//  struct {
//    uint8_t type;
//    uint8_t child_count;
//    TSSymbol symbol;
//    int16_t dynamic_precedence;
//    uint16_t production_id;
//  } reduce;
//  uint8_t type;
//} TSParseAction;
//
//typedef struct {
//  uint16_t lex_state;
//  uint16_t external_lex_state;
//} TSLexMode;
//
//typedef union {
//  TSParseAction action;
//  struct {
//    uint8_t count;
//    bool reusable;
//  } entry;
//} TSParseActionEntry;
//
//struct TSLanguage {
//  uint32_t version;
//  uint32_t symbol_count;
//  uint32_t alias_count;
//  uint32_t token_count;
//  uint32_t external_token_count;
//  uint32_t state_count;
//  uint32_t large_state_count;
//  uint32_t production_id_count;
//  uint32_t field_count;
//  uint16_t max_alias_sequence_length;
//  const uint16_t *parse_table;
//  const uint16_t *small_parse_table;
//  const uint32_t *small_parse_table_map;
//  const TSParseActionEntry *parse_actions;
//  const char * const *symbol_names;
//  const char * const *field_names;
//  const TSFieldMapSlice *field_map_slices;
//  const TSFieldMapEntry *field_map_entries;
//  const TSSymbolMetadata *symbol_metadata;
//  const TSSymbol *public_symbol_map;
//  const uint16_t *alias_map;
//  const TSSymbol *alias_sequences;
//  const TSLexMode *lex_modes;
//  bool (*lex_fn)(TSLexer *, TSStateId);
//  bool (*keyword_lex_fn)(TSLexer *, TSStateId);
//  TSSymbol keyword_capture_token;
//  struct {
//    const bool *states;
//    const TSSymbol *symbol_map;
//    void *(*create)(void);
//    void (*destroy)(void *);
//    bool (*scan)(void *, TSLexer *, const bool *symbol_whitelist);
//    unsigned (*serialize)(void *, char *);
//    void (*deserialize)(void *, const char *, unsigned);
//  } external_scanner;
//};
//
///*
// *  Lexer Macros
// */
//
//#define START_LEXER()           \
//  bool result = false;          \
//  bool skip = false;            \
//  bool eof = false;             \
//  int32_t lookahead;            \
//  goto start;                   \
//  next_state:                   \
//  lexer->advance(lexer, skip);  \
//  start:                        \
//  skip = false;                 \
//  lookahead = lexer->lookahead;
//
//#define ADVANCE(state_value) \
//  {                          \
//    state = state_value;     \
//    goto next_state;         \
//  }
//
//#define SKIP(state_value) \
//  {                       \
//    skip = true;          \
//    state = state_value;  \
//    goto next_state;      \
//  }
//
//#define ACCEPT_TOKEN(symbol_value)     \
//  result = true;                       \
//  lexer->result_symbol = symbol_value; \
//  lexer->mark_end(lexer);
//
//#define END_STATE() return result;
//
///*
// *  Parse Table Macros
// */
//
//#define SMALL_STATE(id) id - LARGE_STATE_COUNT
//
//#define STATE(id) id
//
//#define ACTIONS(id) id
//
//#define SHIFT(state_value)            \
//  {{                                  \
//    .shift = {                        \
//      .type = TSParseActionTypeShift, \
//      .state = state_value            \
//    }                                 \
//  }}
//
//#define SHIFT_REPEAT(state_value)     \
//  {{                                  \
//    .shift = {                        \
//      .type = TSParseActionTypeShift, \
//      .state = state_value,           \
//      .repetition = true              \
//    }                                 \
//  }}
//
//#define SHIFT_EXTRA()                 \
//  {{                                  \
//    .shift = {                        \
//      .type = TSParseActionTypeShift, \
//      .extra = true                   \
//    }                                 \
//  }}
//
//#define REDUCE(symbol_val, child_count_val, ...) \
//  {{                                             \
//    .reduce = {                                  \
//      .type = TSParseActionTypeReduce,           \
//      .symbol = symbol_val,                      \
//      .child_count = child_count_val,            \
//      __VA_ARGS__                                \
//    },                                           \
//  }}
//
//#define RECOVER()                    \
//  {{                                 \
//    .type = TSParseActionTypeRecover \
//  }}
//
//#define ACCEPT_INPUT()              \
//  {{                                \
//    .type = TSParseActionTypeAccept \
//  }}
//
//#ifdef __cplusplus
//}
//#endif
//
//#endif  // TREE_SITTER_PARSER_H_
//
//#if defined(__GNUC__) || defined(__clang__)
//#pragma GCC diagnostic push
//#pragma GCC diagnostic ignored "-Wmissing-field-initializers"
//#endif
//
//#define LANGUAGE_VERSION 13
//#define STATE_COUNT 9
//#define LARGE_STATE_COUNT 4
//#define SYMBOL_COUNT 9
//#define ALIAS_COUNT 0
//#define TOKEN_COUNT 7
//#define EXTERNAL_TOKEN_COUNT 0
//#define FIELD_COUNT 2
//#define MAX_ALIAS_SEQUENCE_LENGTH 3
//#define PRODUCTION_ID_COUNT 2
//
//enum {
//  anon_sym_LPAREN = 1,
//  anon_sym_RPAREN = 2,
//  anon_sym_PLUS = 3,
//  sym_number = 4,
//  sym_comment = 5,
//  sym_variable = 6,
//  sym_expression = 7,
//  sym_sum = 8,
//};
//
//static const char * const ts_symbol_names[] = {
//  [ts_builtin_sym_end] = "end",
//  [anon_sym_LPAREN] = "(",
//  [anon_sym_RPAREN] = ")",
//  [anon_sym_PLUS] = "+",
//  [sym_number] = "number",
//  [sym_comment] = "comment",
//  [sym_variable] = "variable",
//  [sym_expression] = "expression",
//  [sym_sum] = "sum",
//};
//
//static const TSSymbol ts_symbol_map[] = {
//  [ts_builtin_sym_end] = ts_builtin_sym_end,
//  [anon_sym_LPAREN] = anon_sym_LPAREN,
//  [anon_sym_RPAREN] = anon_sym_RPAREN,
//  [anon_sym_PLUS] = anon_sym_PLUS,
//  [sym_number] = sym_number,
//  [sym_comment] = sym_comment,
//  [sym_variable] = sym_variable,
//  [sym_expression] = sym_expression,
//  [sym_sum] = sym_sum,
//};
//
//static const TSSymbolMetadata ts_symbol_metadata[] = {
//  [ts_builtin_sym_end] = {
//    .visible = false,
//    .named = true,
//  },
//  [anon_sym_LPAREN] = {
//    .visible = true,
//    .named = false,
//  },
//  [anon_sym_RPAREN] = {
//    .visible = true,
//    .named = false,
//  },
//  [anon_sym_PLUS] = {
//    .visible = true,
//    .named = false,
//  },
//  [sym_number] = {
//    .visible = true,
//    .named = true,
//  },
//  [sym_comment] = {
//    .visible = true,
//    .named = true,
//  },
//  [sym_variable] = {
//    .visible = true,
//    .named = true,
//  },
//  [sym_expression] = {
//    .visible = true,
//    .named = true,
//  },
//  [sym_sum] = {
//    .visible = true,
//    .named = true,
//  },
//};
//
//enum {
//  field_left = 1,
//  field_right = 2,
//};
//
//static const char * const ts_field_names[] = {
//  [0] = NULL,
//  [field_left] = "left",
//  [field_right] = "right",
//};
//
//static const TSFieldMapSlice ts_field_map_slices[PRODUCTION_ID_COUNT] = {
//  [1] = {.index = 0, .length = 2},
//};
//
//static const TSFieldMapEntry ts_field_map_entries[] = {
//  [0] =
//    {field_left, 0},
//    {field_right, 2},
//};
//
//static const TSSymbol ts_alias_sequences[PRODUCTION_ID_COUNT][MAX_ALIAS_SEQUENCE_LENGTH] = {
//  [0] = {0},
//};
//
//static const uint16_t ts_non_terminal_alias_map[] = {
//  0,
//};
//
//static bool ts_lex(TSLexer *lexer, TSStateId state) {
//  START_LEXER();
//  eof = lexer->eof(lexer);
//  switch (state) {
//    case 0:
//      if (eof) ADVANCE(3);
//      if (lookahead == '(') ADVANCE(4);
//      if (lookahead == ')') ADVANCE(5);
//      if (lookahead == '+') ADVANCE(6);
//      if (lookahead == '/') ADVANCE(1);
//      if (lookahead == '\t' ||
//          lookahead == '\n' ||
//          lookahead == '\r' ||
//          lookahead == ' ') SKIP(0)
//      if (('0' <= lookahead && lookahead <= '9')) ADVANCE(7);
//      if (('A' <= lookahead && lookahead <= 'Z') ||
//          ('a' <= lookahead && lookahead <= 'z')) ADVANCE(2);
//      END_STATE();
//    case 1:
//      if (lookahead == '/') ADVANCE(8);
//      END_STATE();
//    case 2:
//      if (lookahead == '\\') ADVANCE(9);
//      END_STATE();
//    case 3:
//      ACCEPT_TOKEN(ts_builtin_sym_end);
//      END_STATE();
//    case 4:
//      ACCEPT_TOKEN(anon_sym_LPAREN);
//      END_STATE();
//    case 5:
//      ACCEPT_TOKEN(anon_sym_RPAREN);
//      END_STATE();
//    case 6:
//      ACCEPT_TOKEN(anon_sym_PLUS);
//      END_STATE();
//    case 7:
//      ACCEPT_TOKEN(sym_number);
//      if (('0' <= lookahead && lookahead <= '9')) ADVANCE(7);
//      END_STATE();
//    case 8:
//      ACCEPT_TOKEN(sym_comment);
//      if (lookahead != 0 &&
//          lookahead != '\n') ADVANCE(8);
//      END_STATE();
//    case 9:
//      ACCEPT_TOKEN(sym_variable);
//      if (lookahead == 'w') ADVANCE(9);
//      END_STATE();
//    default:
//      return false;
//  }
//}
//
//static const TSLexMode ts_lex_modes[STATE_COUNT] = {
//  [0] = {.lex_state = 0},
//  [1] = {.lex_state = 0},
//  [2] = {.lex_state = 0},
//  [3] = {.lex_state = 0},
//  [4] = {.lex_state = 0},
//  [5] = {.lex_state = 0},
//  [6] = {.lex_state = 0},
//  [7] = {.lex_state = 0},
//  [8] = {.lex_state = 0},
//};
//
//static const uint16_t ts_parse_table[LARGE_STATE_COUNT][SYMBOL_COUNT] = {
//  [0] = {
//    [ts_builtin_sym_end] = ACTIONS(1),
//    [anon_sym_LPAREN] = ACTIONS(1),
//    [anon_sym_RPAREN] = ACTIONS(1),
//    [anon_sym_PLUS] = ACTIONS(1),
//    [sym_number] = ACTIONS(1),
//    [sym_comment] = ACTIONS(3),
//    [sym_variable] = ACTIONS(1),
//  },
//  [1] = {
//    [sym_expression] = STATE(7),
//    [sym_sum] = STATE(4),
//    [anon_sym_LPAREN] = ACTIONS(5),
//    [sym_number] = ACTIONS(7),
//    [sym_comment] = ACTIONS(3),
//    [sym_variable] = ACTIONS(7),
//  },
//  [2] = {
//    [sym_expression] = STATE(8),
//    [sym_sum] = STATE(4),
//    [anon_sym_LPAREN] = ACTIONS(5),
//    [sym_number] = ACTIONS(7),
//    [sym_comment] = ACTIONS(3),
//    [sym_variable] = ACTIONS(7),
//  },
//  [3] = {
//    [sym_expression] = STATE(6),
//    [sym_sum] = STATE(4),
//    [anon_sym_LPAREN] = ACTIONS(5),
//    [sym_number] = ACTIONS(7),
//    [sym_comment] = ACTIONS(3),
//    [sym_variable] = ACTIONS(7),
//  },
//};
//
//static const uint16_t ts_small_parse_table[] = {
//  [0] = 2,
//    ACTIONS(3), 1,
//      sym_comment,
//    ACTIONS(9), 3,
//      ts_builtin_sym_end,
//      anon_sym_RPAREN,
//      anon_sym_PLUS,
//  [9] = 2,
//    ACTIONS(3), 1,
//      sym_comment,
//    ACTIONS(11), 3,
//      ts_builtin_sym_end,
//      anon_sym_RPAREN,
//      anon_sym_PLUS,
//  [18] = 2,
//    ACTIONS(3), 1,
//      sym_comment,
//    ACTIONS(13), 3,
//      ts_builtin_sym_end,
//      anon_sym_RPAREN,
//      anon_sym_PLUS,
//  [27] = 3,
//    ACTIONS(3), 1,
//      sym_comment,
//    ACTIONS(15), 1,
//      ts_builtin_sym_end,
//    ACTIONS(17), 1,
//      anon_sym_PLUS,
//  [37] = 3,
//    ACTIONS(3), 1,
//      sym_comment,
//    ACTIONS(17), 1,
//      anon_sym_PLUS,
//    ACTIONS(19), 1,
//      anon_sym_RPAREN,
//};
//
//static const uint32_t ts_small_parse_table_map[] = {
//  [SMALL_STATE(4)] = 0,
//  [SMALL_STATE(5)] = 9,
//  [SMALL_STATE(6)] = 18,
//  [SMALL_STATE(7)] = 27,
//  [SMALL_STATE(8)] = 37,
//};
//
//static const TSParseActionEntry ts_parse_actions[] = {
//  [0] = {.entry = {.count = 0, .reusable = false}},
//  [1] = {.entry = {.count = 1, .reusable = false}}, RECOVER(),
//  [3] = {.entry = {.count = 1, .reusable = true}}, SHIFT_EXTRA(),
//  [5] = {.entry = {.count = 1, .reusable = true}}, SHIFT(2),
//  [7] = {.entry = {.count = 1, .reusable = true}}, SHIFT(4),
//  [9] = {.entry = {.count = 1, .reusable = true}}, REDUCE(sym_expression, 1),
//  [11] = {.entry = {.count = 1, .reusable = true}}, REDUCE(sym_expression, 3),
//  [13] = {.entry = {.count = 1, .reusable = true}}, REDUCE(sym_sum, 3, .production_id = 1),
//  [15] = {.entry = {.count = 1, .reusable = true}},  ACCEPT_INPUT(),
//  [17] = {.entry = {.count = 1, .reusable = true}}, SHIFT(3),
//  [19] = {.entry = {.count = 1, .reusable = true}}, SHIFT(5),
//};
//
//#ifdef __cplusplus
//extern "C" {
//#endif
//#ifdef _WIN32
//#define extern __declspec(dllexport)
//#endif
//
//extern const TSLanguage *tree_sitter_test_grammar(void) {
//  static const TSLanguage language = {
//    .version = LANGUAGE_VERSION,
//    .symbol_count = SYMBOL_COUNT,
//    .alias_count = ALIAS_COUNT,
//    .token_count = TOKEN_COUNT,
//    .external_token_count = EXTERNAL_TOKEN_COUNT,
//    .state_count = STATE_COUNT,
//    .large_state_count = LARGE_STATE_COUNT,
//    .production_id_count = PRODUCTION_ID_COUNT,
//    .field_count = FIELD_COUNT,
//    .max_alias_sequence_length = MAX_ALIAS_SEQUENCE_LENGTH,
//    .parse_table = &ts_parse_table[0][0],
//    .small_parse_table = ts_small_parse_table,
//    .small_parse_table_map = ts_small_parse_table_map,
//    .parse_actions = ts_parse_actions,
//    .symbol_names = ts_symbol_names,
//    .field_names = ts_field_names,
//    .field_map_slices = ts_field_map_slices,
//    .field_map_entries = ts_field_map_entries,
//    .symbol_metadata = ts_symbol_metadata,
//    .public_symbol_map = ts_symbol_map,
//    .alias_map = ts_non_terminal_alias_map,
//    .alias_sequences = &ts_alias_sequences[0][0],
//    .lex_modes = ts_lex_modes,
//    .lex_fn = ts_lex,
//  };
//  return &language;
//}
//#ifdef __cplusplus
//}
//#endif
import "C"
import "unsafe"

func getTestGrammar() *Language {
	ptr := unsafe.Pointer(C.tree_sitter_test_grammar())
	return NewLanguage(ptr)
}

# This file was generated by `make builtins` based on the spec at:
# https://raw.githubusercontent.com/bazelbuild/starlark/master/spec.md

def any(x):
  """`any(x)` returns `True` if any element of the iterable sequence x is true. If the iterable is empty, it returns `False`."""
  pass

def all(x):
  """`all(x)` returns `False` if any element of the iterable sequence x is false. If the iterable is empty, it returns `True`."""
  pass

def bool(x):
  """`bool(x)` interprets `x` as a Boolean value---`True` or `False`. With no argument, `bool()` returns `False`."""
  pass

def bytes(x):
  """`bytes(x)` converts its argument to a `bytes`."""
  pass

def dict():
  """`dict` creates a dictionary.  It accepts up to one positional argument, which is interpreted as an iterable of two-element sequences (pairs), each specifying a key/value pair in the resulting dictionary."""
  pass

def dir(x):
  """`dir(x)` returns a new sorted list of the names of the attributes (fields and methods) of its operand. The attributes of a value `x` are the names `f` such that `x.f` is a valid expression."""
  pass

def enumerate(x):
  """`enumerate(x)` returns a list of (index, value) pairs, each containing successive values of the iterable sequence xand the index of the value within the sequence."""
  pass

def float(x):
  """`float(x)` interprets its argument as a floating-point number."""
  pass

def fail(*args):
  """The `fail(*args)` function causes execution to fail with an error message that includes the string forms of the argument values. The precise formatting depends on the implementation."""
  pass

def getattr(x, name):
  """`getattr(x, name[, default])` returns the value of the attribute (field or method) of x named `name` if it exists. If not, it either returns `default` (if specified) or raises an error."""
  pass

def hasattr(x, name):
  """`hasattr(x, name)` reports whether x has an attribute (field or method) named `name`."""
  pass

def hash(x):
  """`hash(x)` returns an integer hash of a string or bytes x such that two equal values have the same hash. In other words `x == y` implies `hash(x) == hash(y)`. Any other type of argument in an error, even if it is suitable as the key of a dict."""
  pass

def int(x):
  """`int(x[, base])` interprets its argument as an integer."""
  pass

def len(x):
  """`len(x)` returns the number of elements in its argument."""
  pass

def list():
  """`list` constructs a list."""
  pass

def max(x):
  """`max(x)` returns the greatest element in the iterable sequence x."""
  pass

def min(x):
  """`min(x)` returns the least element in the iterable sequence x."""
  pass

def print(*args, sep=" "):
  """`print(*args, sep=" ")` prints its arguments, followed by a newline. Arguments are formatted as if by `str(x)` and separated with a space, unless an alternative separator is specified by a `sep` named argument."""
  pass

def range():
  """`range` returns an immutable sequence of integers defined by the specified interval and stride."""
  pass

def repr(x):
  """`repr(x)` formats its argument as a string."""
  pass

def reversed(x):
  """`reversed(x)` returns a new list containing the elements of the iterable sequence x in reverse order."""
  pass

def sorted(x):
  """`sorted(x)` returns a new list containing the elements of the iterable sequence x, in sorted order.  The sort algorithm is stable."""
  pass

def str(x):
  """`str(x)` formats its argument as a string."""
  pass

def tuple(x):
  """`tuple(x)` returns a tuple containing the elements of the iterable x."""
  pass

def type(x):
  """`type(x)` returns a string describing the type of its operand."""
  pass

def zip():
  """`zip()` returns a new list of n-tuples formed from corresponding elements of each of the n iterable sequences provided as arguments to `zip`.  That is, the first tuple contains the first element of each of the sequences, the second element contains the second element of each of the sequences, and so on.  The result list is only as long as the shortest of the input sequences."""
  pass

class Bytes:
  def elems(self):
    """`b.elems()` returns an opaque iterable value containing successive int elements of b. Its type is `"bytes.elems"`, and its string representation is of the form `b"...".elems()`."""
    pass

class Dict:
  def get(self, key):
    """`D.get(key[, default])` returns the dictionary value corresponding to the given key. If the dictionary contains no such value, `get` returns `None`, or the value of the optional `default` parameter if present."""
    pass

  def items(self):
    """`D.items()` returns a new list of key/value pairs, one per element in dictionary D, in the same order as they would be returned by a `for` loop."""
    pass

  def keys(self):
    """`D.keys()` returns a new list containing the keys of dictionary D, in the same order as they would be returned by a `for` loop."""
    pass

  def pop(self, key):
    """`D.pop(key[, default])` returns the value corresponding to the specified key, and removes it from the dictionary.  If the dictionary contains no such value, and the optional `default` parameter is present, `pop` returns that value; otherwise, it fails."""
    pass

  def popitem(self):
    """`D.popitem()` returns the first key/value pair, removing it from the dictionary."""
    pass

  def setdefault(self, key):
    """`D.setdefault(key[, default])` returns the dictionary value corresponding to the given key. If the dictionary contains no such value, `setdefault`, like `get`, returns `None` or the value of the optional `default` parameter if present; `setdefault` additionally inserts the new key/value entry into the dictionary."""
    pass

  def update(self):
    """`D.update([pairs][, name=value[, ...])` makes a sequence of key/value insertions into dictionary D, then returns `None.`"""
    pass

  def values(self):
    """`D.values()` returns a new list containing the dictionary's values, in the same order as they would be returned by a `for` loop over the dictionary."""
    pass

class List:
  def append(self, x):
    """`L.append(x)` appends `x` to the list L, and returns `None`."""
    pass

  def clear(self):
    """`L.clear()` removes all the elements of the list L and returns `None`. It fails if the list is frozen or if there are active iterators."""
    pass

  def extend(self, x):
    """`L.extend(x)` appends the elements of `x`, which must be iterable, to the list L, and returns `None`."""
    pass

  def index(self, x):
    """`L.index(x[, start[, end]])` finds `x` within the list L and returns its index."""
    pass

  def insert(self, i, x):
    """`L.insert(i, x)` inserts the value `x` in the list L at index `i`, moving higher-numbered elements along by one.  It returns `None`."""
    pass

  def pop(self):
    """`L.pop([index])` removes and returns the last element of the list L, or, if the optional index is provided, at that index."""
    pass

  def remove(self, x):
    """`L.remove(x)` removes the first occurrence of the value `x` from the list L, and returns `None`."""
    pass

class String:
  def capitalize(self):
    """`S.capitalize()` returns a copy of string S, where the first character (if any) is converted to uppercase; all other characters are converted to lowercase."""
    pass

  def count(self, sub):
    """`S.count(sub[, start[, end]])` returns the number of occurrences of `sub` within the string S, or, if the optional substring indices `start` and `end` are provided, within the designated substring of S. They are interpreted according to Starlark's [indexing conventions](#indexing)."""
    pass

  def elems(self):
    """`S.elems()` returns an opaque iterable value containing successive 1-element substrings of S. Its type is `"string.elems"`, and its string representation is of the form `"...".elems()`."""
    pass

  def endswith(self, suffix):
    """`S.endswith(suffix[, start[, end]])` reports whether the string `S[start:end]` has the specified suffix."""
    pass

  def find(self, sub):
    """`S.find(sub[, start[, end]])` returns the index of the first occurrence of the substring `sub` within S."""
    pass

  def format(self, *args, **kwargs):
    """`S.format(*args, **kwargs)` returns a version of the format string S in which bracketed portions `{...}` are replaced by arguments from `args` and `kwargs`."""
    pass

  def index(self, sub):
    """`S.index(sub[, start[, end]])` returns the index of the first occurrence of the substring `sub` within S, like `S.find`, except that if the substring is not found, the operation fails."""
    pass

  def isalnum(self):
    """`S.isalnum()` reports whether the string S is non-empty and consists only Unicode letters and digits."""
    pass

  def isalpha(self):
    """`S.isalpha()` reports whether the string S is non-empty and consists only of Unicode letters."""
    pass

  def isdigit(self):
    """`S.isdigit()` reports whether the string S is non-empty and consists only of Unicode digits."""
    pass

  def islower(self):
    """`S.islower()` reports whether the string S contains at least one cased Unicode letter, and all such letters are lowercase."""
    pass

  def isspace(self):
    """`S.isspace()` reports whether the string S is non-empty and consists only of Unicode spaces."""
    pass

  def istitle(self):
    """`S.istitle()` reports whether the string S contains at least one cased Unicode letter, and all such letters that begin a word are in title case."""
    pass

  def isupper(self):
    """`S.isupper()` reports whether the string S contains at least one cased Unicode letter, and all such letters are uppercase."""
    pass

  def join(self, iterable):
    """`S.join(iterable)` returns the string formed by concatenating each element of its argument, with a copy of the string S between successive elements. The argument must be an iterable whose elements are strings."""
    pass

  def lower(self):
    """`S.lower()` returns a copy of the string S with letters converted to lowercase."""
    pass

  def lstrip(self):
    """`S.lstrip([cutset])` returns a copy of the string S with leading whitespace removed."""
    pass

  def partition(self, x):
    """`S.partition(x)` splits string S into three parts and returns them as a tuple: the portion before the first occurrence of string `x`, `x` itself, and the portion following it. If S does not contain `x`, `partition` returns `(S, "", "")`."""
    pass

  def removeprefix(self, x):
    """`S.removeprefix(x)` removes the prefix `x` from the string S at most once, and returns the rest of the string. If the prefix string is not found then it returns the original string."""
    pass

  def removesuffix(self, x):
    """`S.removesuffix(x)` removes the suffix `x` from the string S at most once, and returns the rest of the string. If the suffix string is not found then it returns the original string."""
    pass

  def replace(self, old, new):
    """`S.replace(old, new[, count])` returns a copy of string S with all occurrences of substring `old` replaced by `new`. If the optional argument `count`, which must be an `int`, is non-negative, it specifies a maximum number of occurrences to replace."""
    pass

  def rfind(self, sub):
    """`S.rfind(sub[, start[, end]])` returns the index of the substring `sub` within S, like `S.find`, except that `rfind` returns the index of the substring's _last_ occurrence."""
    pass

  def rindex(self, sub):
    """`S.rindex(sub[, start[, end]])` returns the index of the substring `sub` within S, like `S.index`, except that `rindex` returns the index of the substring's _last_ occurrence."""
    pass

  def rpartition(self, x):
    """`S.rpartition(x)` is like `partition`, but splits `S` at the last occurrence of `x`."""
    pass

  def rsplit(self):
    """`S.rsplit([sep[, maxsplit]])` splits a string into substrings like `S.split`, except that when a maximum number of splits is specified, `rsplit` chooses the rightmost splits."""
    pass

  def rstrip(self):
    """`S.rstrip([cutset])` returns a copy of the string S with trailing whitespace removed."""
    pass

  def split(self):
    """`S.split([sep [, maxsplit]])` returns the list of substrings of S, splitting at occurrences of the delimiter string `sep`."""
    pass

  def splitlines(self):
    """`S.splitlines([keepends])` returns a list whose elements are the successive lines of S, that is, the strings formed by splitting S at line terminators (currently assumed to be `\n`, `\r` and `\r\n`, regardless of platform)."""
    pass

  def startswith(self, prefix):
    """`S.startswith(prefix[, start[, end]])` reports whether the string `S[start:end]` has the specified prefix."""
    pass

  def strip(self):
    """`S.strip([cutset])` returns a copy of the string S with leading and trailing whitespace removed."""
    pass

  def title(self):
    """`S.title()` returns a copy of the string S with letters converted to titlecase."""
    pass

  def upper(self):
    """`S.upper()` returns a copy of the string S with letters converted to uppercase."""
    pass


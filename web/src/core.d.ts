// Code generated by tygo. DO NOT EDIT.
export interface ObjectMeta {
  name: string
  namespace: string
  resourceVersion?: string
  uid: string
  labels?: { [key: string]: string }
  annotations?: { [key: string]: string }
  creationTimestamp?: string
  deletionTimestamp?: string
}

//////////
// source: cluster_types.go

export const ClusterNameDefault = "default"
export const ClusterNameDocker = "docker"
/**
 * Cluster defines any runtime for running containers, in the broadest
 * sense of the word "runtime".
 * +k8s:openapi-gen=true
 */
export interface Cluster {
  TypeMeta: null
  metadata?: ObjectMeta
  spec?: ClusterSpec
  status?: ClusterStatus
}
/**
 * ClusterList
 * +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
 */
export interface ClusterList {
  TypeMeta: null
  metadata?: null
  items: Cluster[]
}
/**
 * ClusterSpec defines how to find the cluster we're running
 * containers on.
 * Tilt currently supports connecting to an existing Kubernetes
 * cluster or an existing Docker Daemon (for Docker Compose).
 */
export interface ClusterSpec {
  /**
   * Connection spec for an existing cluster.
   */
  connection?: ClusterConnection
  /**
   * DefaultRegistry determines where images for this Cluster should
   * be pushed/pulled from if the Cluster itself does not provide local
   * registry hosting metadata.
   * If not specified, no registry rewriting will occur, and the images will
   * be pushed/pulled to from the registry specified by the corresponding
   * image build directive (e.g. `docker_build` or `custom_build`).
   * +optional
   */
  defaultRegistry?: RegistryHosting
}
/**
 * Connection spec for an existing cluster.
 */
export interface ClusterConnection {
  /**
   * Defines connection to a Kubernetes cluster.
   */
  kubernetes?: KubernetesClusterConnection
  /**
   * Defines connection to a Docker daemon.
   */
  docker?: DockerClusterConnection
}
export interface KubernetesClusterConnection {
  /**
   * The name of the kubeconfig context to use.
   * If not specified, will use the default context in the kubeconfig.
   * +optional
   */
  context?: string
  /**
   * The default namespace to use.
   * If not specified, will use the namespace in the kubeconfig.
   * +optional
   */
  namespace?: string
}
export interface DockerClusterConnection {
  /**
   * The docker host to use.
   * If not specified, will read the DOCKER_HOST env or use the default docker
   * host.
   */
  host?: string
}
/**
 * ClusterStatus defines the observed state of Cluster
 */
export interface ClusterStatus {
  /**
   * The preferred chip architecture of the cluster.
   * On Kubernetes, this will correspond to the kubernetes.io/arch annotation on
   * a node.
   * On Docker, this will be the Architecture of the Docker daemon.
   * Note that many clusters support multiple chipsets. This field doesn't intend
   * that this is the only architecture a cluster supports, only that it's one
   * of the architectures.
   */
  arch?: string
  /**
   * An unrecoverable error connecting to the cluster.
   * +optional
   */
  error?: string
  /**
   * ConnectedAt indicates the time at which the cluster connection was established.
   * Consumers can use this to detect when the underlying config has changed
   * and refresh their client/connection accordingly.
   * +optional
   */
  connectedAt?: string
  /**
   * Registry describes a local registry that developer tools can
   * connect to. A local registry allows clients to load images into the local
   * cluster by pushing to this registry.
   * +optional
   */
  registry?: RegistryHosting
  /**
   * Connection status for an existing cluster.
   * +optional
   */
  connection?: ClusterConnectionStatus
  /**
   * Version is a cluster-provided, human-readable version string.
   * +optional
   */
  version?: string
}
/**
 * Connection spec for an existing cluster.
 */
export interface ClusterConnectionStatus {
  /**
   * Defines connection to a Kubernetes cluster.
   */
  kubernetes?: KubernetesClusterConnectionStatus
}
/**
 * Kubernetes-specific fields for connection status
 */
export interface KubernetesClusterConnectionStatus {
  /**
   * The resolved kubeconfig context.
   */
  context: string
  /**
   * The resolved default namespace.
   */
  namespace: string
  /**
   * The resolved cluster name (as determined by the kubeconfig context).
   */
  cluster: string
  /**
   * The product name for this cluster.
   * For a complete list of possible product names, see:
   * https://pkg.go.dev/github.com/tilt-dev/clusterid#Product
   */
  product?: string
  /**
   * The resolved config path.
   * Tilt will freeze the config and write it to a temporary directory.
   * Subprocesses that depend on this cluster can find this file
   * by reading the KUBECONFIG env var.
   */
  configPath?: string
}
/**
 * ClusterImageNeeds describes the ways that a cluster
 * might need to access an image.
 * Defaults to "push".
 */
export type ClusterImageNeeds = string
/**
 * Make sure the image is pushed to the right registry
 * and accessible in the cluster.
 */
export const ClusterImageNeedsPush: ClusterImageNeeds = "push"
/**
 * The image is only needed as a base image for other
 * images that are needed in the cluster, so doesn't need to be pushed.
 */
export const ClusterImageNeedsBase: ClusterImageNeeds = "base-image"

//////////
// source: cmd_types.go

/**
 * Cmd represents a process on the host machine.
 * When the process exits, we will make a best-effort attempt
 * (within OS limitations) to kill any spawned descendant processes.
 * +k8s:openapi-gen=true
 * +tilt:starlark-gen=true
 */
export interface Cmd {
  TypeMeta: null
  metadata?: ObjectMeta
  spec?: CmdSpec
  status?: CmdStatus
}
/**
 * CmdList
 * +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
 */
export interface CmdList {
  TypeMeta: null
  metadata?: null
  items: Cmd[]
}
/**
 * CmdSpec defines how to run a local command.
 */
export interface CmdSpec {
  /**
   * Command-line arguments. Must have length at least 1.
   */
  args?: string[]
  /**
   * Process working directory.
   * If the working directory is not specified, the command is run
   * in the default Tilt working directory.
   * +optional
   * +tilt:local-path=true
   */
  dir?: string
  /**
   * Additional variables process environment.
   * Expressed as a C-style array of strings of the form ["KEY1=VALUE1", "KEY2=VALUE2", ...].
   * Environment variables are layered on top of the environment variables
   * that Tilt runs with.
   * +optional
   */
  env?: string[]
  /**
   * Periodic probe of service readiness.
   * +optional
   */
  readinessProbe?: Probe
  /**
   * Indicates objects that can trigger a restart of this command.
   * When a restart is triggered, Tilt will try to gracefully shutdown any
   * currently running process, waiting for it to exit before starting a new
   * process. If the process doesn't shutdown within the allotted time, Tilt
   * will kill the process abruptly.
   * Restarts can happen even if the command is already done.
   * Logs of the current process after the restart are discarded.
   */
  restartOn?: RestartOnSpec
  /**
   * Indicates objects that can trigger a start/restart of this command.
   * Restarts behave the same as RestartOn. The key difference is that
   * a Cmd with any StartOn triggers will not have its command run until its
   * StartOn is satisfied.
   */
  startOn?: StartOnSpec
  /**
   * Specifies how to disable this.
   * +optional
   */
  disableSource?: DisableSource
}
/**
 * CmdStatus defines the observed state of Cmd
 * Based loosely on ContainerStatus in Kubernetes
 */
export interface CmdStatus {
  /**
   * Details about a waiting process.
   * +optional
   */
  waiting?: CmdStateWaiting
  /**
   * Details about a running process.
   * +optional
   */
  running?: CmdStateRunning
  /**
   * Details about a terminated process.
   * +optional
   */
  terminated?: CmdStateTerminated
  /**
   * Specifies whether the command has passed its readiness probe.
   * Terminating the command does not change its Ready state.
   * Is always true when no readiness probe is defined.
   * +optional
   */
  ready?: boolean
  /**
   * Details about whether/why this is disabled.
   * +optional
   */
  disableStatus?: DisableStatus
}
/**
 * CmdStateWaiting is a waiting state of a local command.
 */
export interface CmdStateWaiting {
  /**
   * (brief) reason the process is not yet running.
   * +optional
   */
  reason?: string
}
/**
 * CmdStateRunning is a running state of a local command.
 */
export interface CmdStateRunning {
  /**
   * The process id of the command.
   */
  pid: number /* int32 */
  /**
   * Time at which the command was last started.
   */
  startedAt?: string
}
/**
 * CmdStateTerminated is a terminated state of a local command.
 */
export interface CmdStateTerminated {
  /**
   * The process id of the command.
   */
  pid: number /* int32 */
  /**
   * Exit status from the last termination of the command
   */
  exitCode: number /* int32 */
  /**
   * Time at which previous execution of the command started
   */
  startedAt?: string
  /**
   * Time at which the command last terminated
   */
  finishedAt?: string
  /**
   * (brief) reason the process is terminated
   * +optional
   */
  reason?: string
}

//////////
// source: cmdimage_types.go

/**
 * CmdImage describes an image to build with an arbitrary shell command.
 * +k8s:openapi-gen=true
 */
export interface CmdImage {
  TypeMeta: null
  metadata?: ObjectMeta
  spec?: CmdImageSpec
  status?: CmdImageStatus
}
/**
 * CmdImageList
 * +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
 */
export interface CmdImageList {
  TypeMeta: null
  metadata?: null
  items: CmdImage[]
}
/**
 * CmdImageSpec describes how the custom script builds images and where it puts them.
 */
export interface CmdImageSpec {
  /**
   * The named reference of the image.
   */
  ref: string
  /**
   * Command-line arguments. Must have length at least 1.
   */
  args?: string[]
  /**
   * Process working directory.
   * If the working directory is not specified, the command is run
   * in the default Tilt working directory.
   * +optional
   * +tilt:local-path=true
   */
  dir?: string
  /**
   * Additional environment variables for the build process.
   * Expressed as a C-style array of strings of the form ["KEY1=VALUE1", "KEY2=VALUE2", ...].
   * Environment variables are layered on top of the environment variables
   * that Tilt runs with.
   * +optional
   */
  env?: string[]
  /**
   * Names of image maps that this build depends on.
   * The controller will watch all the image maps, and rebuild the image
   * if any of the maps resolve to a new image.
   * +optional
   */
  imageMaps?: string[]
  /**
   * Specifies where the image is built. If not specified, we assume the image
   * was built to the local Docker image store.
   */
  outputMode?: CmdImageOutputMode
  /**
   * Tag we expect the image to be built with (we use this to check that
   * the expected image+tag has been created).
   * If empty, we create an expected tag at the beginning of CustomBuild (and
   * export $EXPECTED_REF=name:expected_tag )
   * +optional
   */
  outputTag?: string
  /**
   * Specifies a filepath where the cmd script prints the result image ref.
   * Tilt will read it out when we're done to find the image.
   * +optional
   * +tilt:local-path=true
   */
  outputsImageRefTo?: string
  /**
   * The name of the cluster we're building for.
   * We'll use the cluster to determine the architecture of the image to build,
   * and the registry to build it for.
   * If no cluster is specified, assumes the default cluster.
   * +optional
   */
  cluster?: string
  /**
   * Whether the cluster needs access to the image.
   * If not specified, assumes we have to push up to the cluster.
   * +optional
   */
  clusterNeeds?: ClusterImageNeeds
}
/**
 * CmdImageStatus describes the result of the image build.
 */
export interface CmdImageStatus {
  /**
   * A fully-qualified image reference of a built image, as seen from the local
   * network.
   * Usually includes a name and an immutable tag.
   * NB: If we're building to a particular registry, this may
   * have a different hostname from the Spec `Ref` field.
   * +optional
   */
  ref?: string
  /**
   * Details about a waiting image build.
   * +optional
   */
  waiting?: CmdImageStateWaiting
  /**
   * Details about a building image.
   * +optional
   */
  building?: CmdImageStateBuilding
  /**
   * Details about a finished image build.
   * +optional
   */
  completed?: CmdImageStateCompleted
}
/**
 * CmdImageOutputMode describes places where the image may be written.
 */
export type CmdImageOutputMode = string
/**
 * Written to the Docker image store only.
 */
export const CmdImageOutputLocalDocker: CmdImageOutputMode = "local-docker"
/**
 * Written to the Docker image store and pushed to the remote
 * destination.
 */
export const CmdImageOutputLocalDockerAndRemote: CmdImageOutputMode =
  "local-docker-and-remote"
/**
 * Written directly to the remote destination.
 */
export const CmdImageOutputRemote: CmdImageOutputMode = "remote"
/**
 * CmdImageStateWaiting expresses what we're waiting on to build an image.
 */
export interface CmdImageStateWaiting {
  /**
   * (brief) reason the image build is waiting.
   * +optional
   */
  reason?: string
}
/**
 * CmdImageStateBuilding expresses that an image build is in-progress.
 */
export interface CmdImageStateBuilding {
  /**
   * The reason why the image is building.
   * +optional
   */
  reason?: string
  /**
   * Time when the build started.
   */
  startedAt?: string
}
/**
 * CmdImageStateCompleted expresses when the image build is finished and
 * no new images need to be built.
 */
export interface CmdImageStateCompleted {
  /**
   * The reason why the image was built.
   * +optional
   */
  reason?: string
  /**
   * Error message if the build failed.
   * +optional
   */
  error?: string
  /**
   * Time when we started building an image.
   */
  startedAt?: string
  /**
   * Time when we finished building an image
   */
  finishedAt?: string
}

//////////
// source: configmap_types.go

/**
 * ConfigMap stores unstructured data that other controllers can read and write.
 * Useful for sharing data from one system and subscribing to it from another.
 * +k8s:openapi-gen=true
 * +tilt:starlark-gen=true
 */
export interface ConfigMap {
  TypeMeta: null
  metadata?: ObjectMeta
  /**
   * Data contains the configuration data.
   * Each key must consist of alphanumeric characters, '-', '_' or '.'.
   * +optional
   */
  data?: { [key: string]: string }
}
/**
 * ConfigMapList
 * +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
 */
export interface ConfigMapList {
  TypeMeta: null
  metadata?: null
  items: ConfigMap[]
}

//////////
// source: disable_types.go

/**
 * Points at a thing that can control whether something is disabled
 */
export interface DisableSource {
  /**
   * Disabled by single ConfigMap value.
   */
  configMap?: ConfigMapDisableSource
  /**
   * Disabled by multiple ConfigMap values, which must all be set to disabled
   * to disable the object.
   */
  everyConfigMap?: ConfigMapDisableSource[]
}
/**
 * Specifies a ConfigMap to control a DisableSource
 */
export interface ConfigMapDisableSource {
  /**
   * The name of the ConfigMap
   */
  name: string
  /**
   * The key where the enable/disable state is stored.
   */
  key: string
}
export interface DisableStatus {
  /**
   * Whether this is currently disabled. Deprecated in favor of `State`.
   */
  disabled: boolean
  /**
   * The last time this status was updated.
   */
  lastUpdateTime: string
  /**
   * The reason this status was updated.
   */
  reason: string
  /**
   * Whether this is currently disabled (if known)
   */
  state: DisableState
}
/**
 * Indicates what is known about whether this is disabled.
 * Possible values:
 * "" - the status is not known
 * "Enabled" - this is enabled
 * "Disabled" - this is disabled
 * "Error" - the status was not determined due to a potentially nonephemeral error (e.g., misconfiguration)
 */
export type DisableState = string
export const DisableStatePending: DisableState = ""
export const DisableStateEnabled: DisableState = "Enabled"
export const DisableStateDisabled: DisableState = "Disabled"
export const DisableStateError: DisableState = "Error"

//////////
// source: dockercomposelogstream_types.go

/**
 * DockerComposeLogStream
 * +k8s:openapi-gen=true
 */
export interface DockerComposeLogStream {
  TypeMeta: null
  metadata?: ObjectMeta
  spec?: DockerComposeLogStreamSpec
  status?: DockerComposeLogStreamStatus
}
/**
 * DockerComposeLogStreamList
 * +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
 */
export interface DockerComposeLogStreamList {
  TypeMeta: null
  metadata?: null
  items: DockerComposeLogStream[]
}
/**
 * DockerComposeLogStreamSpec defines the desired state of DockerComposeLogStream
 */
export interface DockerComposeLogStreamSpec {
  /**
   * The name of the service to stream from.
   */
  service: string
  /**
   * A specification of the project the service belongs to.
   * Each service spec keeps its own copy of the project spec.
   */
  project: DockerComposeProject
}
/**
 * DockerComposeLogStreamStatus defines the observed state of DockerComposeLogStream
 */
export interface DockerComposeLogStreamStatus {
  /**
   * When we last started the log streamer.
   */
  startedAt?: string
  /**
   * Contains an error message when the log streamer is in an error state.
   */
  error?: string
}

//////////
// source: dockercomposeservice_types.go

/**
 * DockerComposeService represents a container orchestrated by Docker Compose.
 * +k8s:openapi-gen=true
 */
export interface DockerComposeService {
  TypeMeta: null
  metadata?: ObjectMeta
  spec?: DockerComposeServiceSpec
  status?: DockerComposeServiceStatus
}
/**
 * DockerComposeServiceList
 * +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
 */
export interface DockerComposeServiceList {
  TypeMeta: null
  metadata?: null
  items: DockerComposeService[]
}
/**
 * DockerComposeServiceSpec defines the desired state a Docker Compose container.
 */
export interface DockerComposeServiceSpec {
  /**
   * The name of the service to create.
   */
  service: string
  /**
   * A specification of the project the service belongs to.
   * Each service spec keeps its own copy of the project spec.
   */
  project: DockerComposeProject
  /**
   * The image maps that this deploy depends on.
   */
  imageMaps?: string[]
  /**
   * Specifies how to disable this.
   * +optional
   */
  disableSource?: DisableSource
}
/**
 * DockerComposeServiceStatus defines the observed state of DockerComposeService,
 * continuing to watch the container after it starts.
 */
export interface DockerComposeServiceStatus {
  /**
   * Details about whether/why this is disabled.
   * +optional
   */
  disableStatus?: DisableStatus
  /**
   * How docker binds container ports to the host network for this service.
   * +optional
   */
  portBindings?: DockerPortBinding[]
  /**
   * Current state of the container for this service.
   * +optional
   */
  containerState?: DockerContainerState
  /**
   * Current container ID.
   * +optional
   */
  containerID?: string
  /**
   * Current container name.
   * +optional
   */
  containerName?: string
  /**
   * An error bringing up the container.
   * +optional
   */
  applyError?: string
  /**
   * Timestamp of when we last started bringing up this service in Docker Compose.
   * +optional
   */
  lastApplyStartTime?: string
  /**
   * Timestamp of when we last finished bringing up this service in Docker Compose.
   * When populated, must be equal or after the LastApplyStartTime field.
   * +optional
   */
  lastApplyFinishTime?: string
}
export interface DockerComposeProject {
  /**
   * Configuration files to load.
   * If both ConfigPaths and ProjectPath/YAML are specified,
   * the YAML is the source of truth, and the ConfigPaths
   * are used to print diagnostic information.
   */
  configPaths?: string[]
  /**
   * The base path of the docker-compose project.
   * Expressed in docker-compose as --project-directory.
   * When used on the command-line, the Docker Compose spec mandates that this
   * must be the directory of the first yaml file.  All additional yaml files are
   * evaluated relative to this project path.
   */
  projectPath?: string
  /**
   * The docker-compose config YAML.
   * Usually contains multiple services.
   * If you have multiple docker-compose.yaml files, you can combine them into a
   * single YAML with `docker-compose -f file1.yaml -f file2.yaml config`.
   */
  yaml?: string
  /**
   * The docker-compose project name.
   * If omitted, the default is to use the NormalizedName of the ProjectPath
   * base name.
   */
  name?: string
  /**
   * Path to an env file to use. Passed to docker-compose as `--env-file FILE`.
   */
  envFile?: string
  /**
   * Optional docker-compose profiles to use.
   * Services with defined profiles will only be included if their profile matches
   * one in this list.
   */
  profiles?: string[]
  /**
   * Optionally, pass --wait to docker compose up
   */
  wait?: boolean
}
/**
 * State of a standalone container in Docker.
 * An apiserver-compatible representation of this struct:
 * https://pkg.go.dev/github.com/docker/docker/api/types#ContainerState
 */
export interface DockerContainerState {
  /**
   * String representation of the container state.
   * Can be one of "created", "running", "paused", "restarting", "removing", "exited", or "dead".
   * +optional
   */
  status?: string
  /**
   * Whether the container is running.
   * +optional
   */
  running?: boolean
  /**
   * Whether the container is in an error state.
   * +optional
   */
  error?: string
  /**
   * The exit code, if the container has exited.
   * +optional
   */
  exitCode?: number /* int32 */
  /**
   * When the container process started.
   * +optional
   */
  startedAt?: string
  /**
   * When the container process finished.
   * +optional
   */
  finishedAt?: string
  /**
   * Status is one of Starting, Healthy or Unhealthy
   */
  healthStatus?: string
}
/**
 * How docker binds container ports to the host network
 */
export interface DockerPortBinding {
  /**
   * The port inside the container.
   */
  containerPort?: number /* int32 */
  /**
   * The port on the host machine where Docker running.
   */
  hostPort?: number /* int32 */
  /**
   * The IP on the host machine where Docker is binding the network.
   */
  hostIP?: string
}

//////////
// source: dockerimage_types.go

/**
 * DockerImage describes an image to build with Docker.
 * +k8s:openapi-gen=true
 */
export interface DockerImage {
  TypeMeta: null
  metadata?: ObjectMeta
  spec?: DockerImageSpec
  status?: DockerImageStatus
}
/**
 * DockerImageList
 * +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
 */
export interface DockerImageList {
  TypeMeta: null
  metadata?: null
  items: DockerImage[]
}
/**
 * DockerImageSpec describes how to build a Docker image with `docker_build`.
 * Most fields of this spec directly correspond to the Docker CLI.
 */
export interface DockerImageSpec {
  /**
   * The named reference of the image.
   */
  ref: string
  /**
   * Dockerfile contains the complete contents of the Dockerfile.
   * TODO(nick): We should also support referencing the Dockerfile as a path.
   * +optional
   */
  dockerfileContents?: string
  /**
   * Context specifies the Docker build context.
   * Must be an absolute path on the local filesystem.
   * +tilt:local-path=true
   */
  context?: string
  /**
   * Ignores are filters on the Docker build context.
   * The DockerImage controller will NOT read ignores from .dockerignore files.
   * Instead, all filters must be expressed in this field, which covers
   * .dockerignore files, ignore= lists in the tiltfile, only= lists in the
   * tiltfile, and more.
   */
  contextIgnores?: IgnoreDef[]
  /**
   * Args specifies the build arguments to the Dockerfile.
   * Equivalent to `--build-arg` in the docker CLI.
   * Each item should take the form "KEY" or "KEY=VALUE".
   * +optional
   */
  args?: string[]
  /**
   * Target specifies the name of the stage in the Dockerfile to build.
   * Equivalent to `--target` in the docker CLI.
   * +optional
   */
  target?: string
  /**
   * Pass SSH secrets to docker so it can clone private repos.
   * https://docs.docker.com/develop/develop-images/build_enhancements/#using-ssh-to-access-private-data-in-builds
   * Equivalent to `--ssh` in the docker CLI.
   * +optional
   */
  sshAgentConfigs?: string[]
  /**
   * Pass secrets to docker.
   * https://docs.docker.com/develop/develop-images/build_enhancements/#new-docker-build-secret-information
   * Equivalent to `--secret` in the Docker CLI.
   * +optional
   */
  secrets?: string[]
  /**
   * Set the networking mode for the RUN instructions in the docker build.
   * Equivalent to `--network` in the Docker CLI.
   * +optional
   */
  network?: string
  /**
   * Always attempt to pull a new version of the base image.
   * Equivalent to `--pull` in the Docker CLI.
   * +optional
   */
  pull?: boolean
  /**
   * Images to use as cache sources.
   * Equivalent to `--cache-from` in the Docker CLI.
   */
  cacheFrom?: string[]
  /**
   * Platform specifies architecture information for target image.
   * https://docs.docker.com/desktop/multi-arch/
   * Equivalent to `--platform` in the Docker CLI.
   */
  platform?: string
  /**
   * By default, Tilt creates a new temporary image reference for each build.
   * The user can also specify their own reference, to integrate with other tooling
   * (like build IDs for Jenkins build pipelines)
   * Equivalent to the docker build --tag flag.
   * +optional
   */
  extraTags?: string[]
  /**
   * Names of image maps that this build depends on.
   * The controller will watch all the image maps, rebuild the image if any of
   * the maps resolve to a new image, and inject them into the dockerfile.
   * +optional
   */
  imageMaps?: string[]
  /**
   * The name of the cluster we're building for.
   * We'll use the cluster to determine the architecture of the image to build,
   * and the registry to build it for.
   * If no cluster is specified, assumes the default cluster.
   * +optional
   */
  cluster?: string
  /**
   * Whether the cluster needs access to the image.
   * If not specified, assumes we have to push up to the cluster.
   * +optional
   */
  clusterNeeds?: ClusterImageNeeds
  /**
   * Other hosts to be added into a containerâ€™s /etc/hosts file
   * https://docs.docker.com/engine/reference/commandline/build/#add-host
   * Equivalent to `--add-host` in the Docker CLI.
   */
  extraHosts?: string[]
}
/**
 * DockerImageStatus defines the observed state of DockerImage
 */
export interface DockerImageStatus {
  /**
   * A fully-qualified image reference of a built image, as seen from the local
   * network.
   * Usually includes a name and an immutable tag.
   * NB: If we're building to a particular registry, this may
   * have a different hostname from the Spec `Ref` field.
   * +optional
   */
  ref?: string
  /**
   * Details about a waiting image build.
   * +optional
   */
  waiting?: DockerImageStateWaiting
  /**
   * Details about a building image.
   * +optional
   */
  building?: DockerImageStateBuilding
  /**
   * Details about a finished image build.
   * +optional
   */
  completed?: DockerImageStateCompleted
  /**
   * Status information about each individual build stage
   * of the most recent image build.
   */
  stageStatuses?: DockerImageStageStatus[]
}
/**
 * DockerImageStateWaiting expresses what we're waiting on to build an image.
 */
export interface DockerImageStateWaiting {
  /**
   * (brief) reason the image build is waiting.
   * +optional
   */
  reason?: string
}
/**
 * DockerImageStateBuilding expresses that an image build is in-progress.
 */
export interface DockerImageStateBuilding {
  /**
   * The reason why the image is building.
   * +optional
   */
  reason?: string
  /**
   * Time when the build started.
   */
  startedAt?: string
}
/**
 * DockerImageStateCompleted expresses when the image build is finished and
 * no new images need to be built.
 */
export interface DockerImageStateCompleted {
  /**
   * The reason why the image was built.
   * +optional
   */
  reason?: string
  /**
   * Error message if the build failed.
   * +optional
   */
  error?: string
  /**
   * Time when we started building an image.
   */
  startedAt?: string
  /**
   * Time when we finished building an image
   */
  finishedAt?: string
}
/**
 * DockerImageStageStatus gives detailed report of each stage
 * of the most recent image build.
 * Most stages are derived from Buildkit's StatusResponse
 * https://github.com/moby/buildkit/blob/35fcb28a009d6454b2915a5c8084b25ad851cf38/api/services/control/control.proto#L108
 * but Tilt may synthesize its own stages for the steps it
 * owns.
 * Stages may be executed in parallel.
 */
export interface DockerImageStageStatus {
  /**
   * A human-readable name of the stage.
   */
  name: string
  /**
   * Whether Buildkit was able to cache the stage based on inputs.
   * +optional
   */
  cached?: boolean
  /**
   * The timestamp when we started working on the stage.
   * +optional
   */
  startedAt?: string
  /**
   * The timetsamp when we completed the work on the stage.
   * +optional
   */
  finishedAt?: string
  /**
   * Error message if the stage failed. If empty, the stage succeeded.
   * +optional
   */
  error?: string
}

//////////
// source: extension_types.go

/**
 * Extension defines an extension that's evaluated on Tilt startup.
 * +k8s:openapi-gen=true
 * +tilt:starlark-gen=true
 */
export interface Extension {
  TypeMeta: null
  metadata?: ObjectMeta
  spec?: ExtensionSpec
  status?: ExtensionStatus
}
/**
 * ExtensionList
 * +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
 */
export interface ExtensionList {
  TypeMeta: null
  metadata?: null
  items: Extension[]
}
/**
 * ExtensionSpec defines the desired state of Extension
 */
export interface ExtensionSpec {
  /**
   * RepoName specifies the ExtensionRepo object where we should find this extension.
   * The Extension controller should watch for changes to this repo, and
   * may update if this repo is deleted or moved.
   */
  repoName: string
  /**
   * RepoPath specifies the path to the extension directory inside the repo.
   * Once the repo is downloaded, this path should point to a directory with a
   * Tiltfile as the main "entrypoint" of the extension.
   */
  repoPath: string
  /**
   * Arguments to the Tiltfile loaded by this extension.
   * Arguments can be positional (['a', 'b', 'c']) or flag-based ('--to-edit=a').
   * By default, a list of arguments indicates the list of services in the tiltfile
   * that should be enabled.
   * +optional
   */
  args?: string[]
}
/**
 * ExtensionStatus defines the observed state of Extension
 */
export interface ExtensionStatus {
  /**
   * Contains information about any problems loading the extension.
   */
  error?: string
  /**
   * The path to the extension on disk. This location should be shared
   * and readable by all Tilt instances.
   */
  path?: string
}

//////////
// source: extensionrepo_types.go

/**
 * ExtensionRepo specifies a repo or folder where a set of extensions live.
 * +k8s:openapi-gen=true
 * +tilt:starlark-gen=true
 */
export interface ExtensionRepo {
  TypeMeta: null
  metadata?: ObjectMeta
  spec?: ExtensionRepoSpec
  status?: ExtensionRepoStatus
}
/**
 * ExtensionRepoList
 * +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
 */
export interface ExtensionRepoList {
  TypeMeta: null
  metadata?: null
  items: ExtensionRepo[]
}
/**
 * ExtensionRepoSpec defines how to access the repo.
 */
export interface ExtensionRepoSpec {
  /**
   * The URL of the repo.
   * Allowed:
   * https: URLs that point to a public git repo
   * file: URLs that point to a location on disk.
   */
  url: string
  /**
   * A reference to sync the repo to. If empty, Tilt will always update
   * the repo to the latest version.
   * +optional
   */
  ref?: string
  /**
   * When set, this allows for automatically registering extensions within this repository in the
   * following conditions:
   *  - The extension is not already registered
   *  - The first component of the load path matches the load_host of an extension repository.
   * For example, an extension_repo call with load_host="internal" will support registering an
   * extension at load time that looks like:
   *  load("ext://internal/ext-name", "...")
   * +optional
   */
  loadHost?: string
  /**
   * A path within the repository root that contains all extensions. By default, all extensions
   * are expected to live at the repository root.
   * Note that it is an error for this to be set for extension repositories using file:// URLs.
   * For directory based extension repositories, you can add the subpath in the URL.
   * +optional
   */
  gitSubpath?: string
}
/**
 * ExtensionRepoStatus defines the observed state of ExtensionRepo
 */
export interface ExtensionRepoStatus {
  /**
   * Contains information about any problems loading the repo.
   */
  error?: string
  /**
   * The last time the repo was fetched and checked for validity.
   */
  lastFetchedAt?: string
  /**
   * The path to the repo on local disk.
   */
  path?: string
  /**
   * The reference that we currently have checked out.
   * On git, this is the commit hash.
   * On file repos, this is empty.
   */
  checkoutRef?: string
  /**
   * If StaleReason is non-empty, that indicates the repo failed to fetch, but
   * we were successfully able to use an on-disk copy.
   */
  staleReason?: string
}

//////////
// source: filewatch_types.go

/**
 * FileWatch
 * +k8s:openapi-gen=true
 * +tilt:starlark-gen=true
 */
export interface FileWatch {
  TypeMeta: null
  metadata?: ObjectMeta
  spec?: FileWatchSpec
  status?: FileWatchStatus
}
/**
 * FileWatchList
 * +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
 */
export interface FileWatchList {
  TypeMeta: null
  metadata?: null
  items: FileWatch[]
}
/**
 * FileWatchSpec defines the desired state of FileWatch
 */
export interface FileWatchSpec {
  /**
   * WatchedPaths are paths of directories or files to watch for changes to. It cannot be empty.
   * +tilt:local-path=true
   */
  watchedPaths: string[]
  /**
   * Ignores are optional rules to filter out a subset of changes matched by WatchedPaths.
   */
  ignores?: IgnoreDef[]
  /**
   * Specifies how to disable this.
   * +optional
   */
  disableSource?: DisableSource
}
/**
 * Describes sets of file paths that the FileWatch should ignore.
 */
export interface IgnoreDef {
  /**
   * BasePath is the base path for the patterns. It cannot be empty.
   * If no patterns are specified, everything under it will be recursively ignored.
   * +tilt:local-path=true
   */
  basePath: string
  /**
   * Patterns are dockerignore style rules. Absolute-style patterns will be rooted to the BasePath.
   * See https://docs.docker.com/engine/reference/builder/#dockerignore-file.
   */
  patterns?: string[]
}
/**
 * FileWatchStatus defines the observed state of FileWatch
 */
export interface FileWatchStatus {
  /**
   * MonitorStartTime is the timestamp of when filesystem monitor was started. It is zero if the monitor has not
   * been started yet.
   */
  monitorStartTime?: string
  /**
   * LastEventTime is the timestamp of the most recent file event. It is zero if no events have been seen yet.
   * If the specifics of which files changed are not important, this field can be used as a watermark without
   * needing to inspect FileEvents.
   */
  lastEventTime?: string
  /**
   * FileEvents summarizes batches of file changes (create, modify, or delete) that have been seen in ascending
   * chronological order. Only the most recent 20 events are included.
   */
  fileEvents?: FileEvent[]
  /**
   * Error is set if there is a problem with the filesystem watch. If non-empty, consumers should assume that
   * no filesystem events will be seen and that the file watcher is in a failed state.
   */
  error?: string
  /**
   * Details about whether/why this is disabled.
   * +optional
   */
  disableStatus?: DisableStatus
}
export interface FileEvent {
  /**
   * Time is an approximate timestamp for a batch of file changes.
   * This will NOT exactly match any inode attributes (e.g. ctime, mtime) at the filesystem level and is purely
   * informational or for use as an opaque watermark.
   */
  time: string
  /**
   * SeenFiles is a list of paths which changed (create, modify, or delete).
   */
  seenFiles: string[]
}

//////////
// source: generated.pb.go

//////////
// source: imagemap_types.go

/**
 * ImageMap expresses the mapping from an image reference to a real, pushed
 * image in an image registry that a container runtime can access.
 * Another way to think about the ImageMap is that ImageMapSpec is a mutable
 * image reference (where the image might not exist yet), but ImageMapStatus is
 * an immutable image reference (where, if an image is specified, it always
 * exists).
 * ImageMap does not specify how the image is built or who is responsible for
 * building this. But any API that builds images should produce an ImageMap.
 * For example, a builder that builds to a local image registry might create
 * a map from: 'my-apiserver:dev' to 'localhost:5000/my-apiserver:content-based-label'.
 * ImageMap doesn't follow the usual Kubernetes-style API semantics
 * (where the Status is the result of running the Spec). It's closer to a
 * ConfigMap. Though the Status does represent a real runtime result
 * (an image in a registry).
 * +k8s:openapi-gen=true
 */
export interface ImageMap {
  TypeMeta: null
  metadata?: ObjectMeta
  spec?: ImageMapSpec
  status?: ImageMapStatus
}
/**
 * ImageMapList
 * +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
 */
export interface ImageMapList {
  TypeMeta: null
  metadata?: null
  items: ImageMap[]
}
/**
 * ImageMapSpec defines the desired state of ImageMap
 */
export interface ImageMapSpec {
  /**
   * A named image reference.
   * Deployment tools expect this image reference to match an image
   * in the YAML being deployed, and will replace that image reference.
   * By default, this selector will match an image if the names match
   * (tags on both the selector and the matched reference are ignored).
   */
  selector: string
  /**
   * If specified, then tags on both the selector and the matched
   * reference are used for matching. The selector will only
   * match the reference if the tags match exactly.
   * +optional
   */
  matchExact?: boolean
  /**
   * If specified, then the selector will also match any strings
   * in container env variables.
   * +optional
   */
  matchInEnvVars?: boolean
  /**
   * If specified, the injector will replace the 'command'
   * field in the container when it replaces the image.
   * +optional
   */
  overrideCommand?: ImageMapOverrideCommand
  /**
   * If specified, the injector will replace the 'args'
   * field in the container when it replaces the image.
   * +optional
   */
  overrideArgs?: ImageMapOverrideArgs
}
/**
 * ImageMapCommandOverride defines a command to inject when the image
 * is injected. Only applies to types that embed a v1.Container
 * with a Command field.
 * https://pkg.go.dev/k8s.io/api/core/v1#Container
 */
export interface ImageMapOverrideCommand {
  /**
   * A list of command strings.
   */
  command: string[]
}
/**
 * ImageMapArgsOverride defines args to inject when the image
 * is injected. Only applies to types that embed a v1.Container
 * with a Command field.
 * https://pkg.go.dev/k8s.io/api/core/v1#Container
 */
export interface ImageMapOverrideArgs {
  /**
   * A list of args strings.
   */
  args: string[]
}
/**
 * ImageMapStatus defines the observed state of ImageMap
 */
export interface ImageMapStatus {
  /**
   * A fully-qualified image reference, including a name and an immutable tag,
   * as seen from the cluster container runtime that we're mapping this image to.
   * NB: Container images often need to be referenced from different networks,
   * including:
   * 1) The cluster container runtime
   * 2) The local network
   * 3) The cluster network
   * And each of these cases may have distinct URLs.
   * We might deprecate this field and only use fields
   * of the form `ImageFromX`.
   * For more details on image references in different networks, see:
   * https://github.com/kubernetes/enhancements/tree/master/keps/sig-cluster-lifecycle/generic/1755-communicating-a-local-registry#specification-for-localregistryhosting-v1
   */
  image?: string
  /**
   * A fully-qualified image reference, including a name and an immutable tag,
   * as seen from the local network.
   */
  imageFromLocal?: string
  /**
   * A fully-qualified image reference, including a name and an immutable tag,
   * as seen from the cluster container runtime.
   */
  imageFromCluster?: string
  /**
   * Timestamp indicating when the image started building.
   * Intended to be used to determine which file changes were picked up by the
   * image build. We can assume that any file changes before this timestamp were
   * definitely included in the image, and any file changes after this timestamp
   * may not be included in the image.
   */
  buildStartTime?: string
}

//////////
// source: kubernetesapply_types.go

export const KubernetesApplyTimeoutDefault = 30 * any /* time.Second */
/**
 * KubernetesApply specifies a blob of YAML to apply, and a set of ImageMaps
 * that the YAML depends on.
 * The KubernetesApply controller will resolve the ImageMaps into immutable image
 * references. The controller will process the spec YAML, then apply it to the cluster.
 * Those processing steps might include:
 * - Injecting the resolved image references.
 * - Adding custom labels so that Tilt can track the progress of the apply.
 * - Modifying image pull rules to ensure the image is pulled correctly.
 * The controller won't apply anything until all ImageMaps resolve to real images.
 * The controller will watch all the image maps, and redeploy the entire YAML if
 * any of the maps resolve to a new image.
 * The status field will contain both the raw applied object, and derived fields
 * to help other controllers figure out how to watch the apply progress.
 * +k8s:openapi-gen=true
 * +tilt:starlark-gen=true
 */
export interface KubernetesApply {
  TypeMeta: null
  metadata?: ObjectMeta
  spec?: KubernetesApplySpec
  status?: KubernetesApplyStatus
}
/**
 * KubernetesApplyList
 * +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
 */
export interface KubernetesApplyList {
  TypeMeta: null
  metadata?: null
  items: KubernetesApply[]
}
/**
 * KubernetesApplySpec defines the desired state of KubernetesApply
 */
export interface KubernetesApplySpec {
  /**
   * YAML to apply to the cluster.
   * Exactly one of YAML OR ApplyCmd MUST be provided.
   * +optional
   */
  yaml?: string
  /**
   * Names of image maps that this applier depends on.
   * The controller will watch all the image maps, and redeploy the entire YAML
   * if any of the maps resolve to a new image.
   * +optional
   */
  imageMaps?: string[]
  /**
   * Descriptors of how to find images in the YAML.
   * Needed when injecting images into CRDs.
   * +optional
   */
  imageLocators?: KubernetesImageLocator[]
  /**
   * The timeout on the apply operation.
   * We've had problems with both:
   * 1) CRD apiservers that take an arbitrarily long time to apply, and
   * 2) Infinite loops in the apimachinery
   * So we offer the ability to set a timeout on Kubernetes apply operations.
   * The default timeout is 30s.
   * +optional
   */
  timeout?: any /* metav1.Duration */
  /**
   * KubernetesDiscoveryTemplateSpec describes how we discover pods
   * for resources created by this Apply.
   * If not specified, the KubernetesDiscovery controller will listen to all pods,
   * and follow owner references to find the pods owned by these resources.
   * +optional
   */
  kubernetesDiscoveryTemplateSpec?: KubernetesDiscoveryTemplateSpec
  /**
   * PortForwardTemplateSpec describes the data model for port forwards
   * that KubernetesApply should set up.
   * Underneath the hood, we'll create a KubernetesDiscovery object that finds
   * the pods and sets up the port-forwarding. Only one PortForward will be
   * active at a time.
   * +optional
   */
  portForwardTemplateSpec?: PortForwardTemplateSpec
  /**
   * PodLogStreamTemplateSpec describes the data model for PodLogStreams
   * that KubernetesApply should set up.
   * Underneath the hood, we'll create a KubernetesDiscovery object that finds
   * the pods and sets up the pod log streams.
   * If no template is specified, the controller will stream all
   * pod logs available from the apiserver.
   * +optional
   */
  podLogStreamTemplateSpec?: PodLogStreamTemplateSpec
  /**
   * DiscoveryStrategy describes how we set up pod watches for the applied
   * resources. This affects all systems that attach to pods, including
   * PortForwards, PodLogStreams, resource readiness, and live-updates.
   * +optional
   */
  discoveryStrategy?: KubernetesDiscoveryStrategy
  /**
   * Specifies how to disable this.
   * +optional
   */
  disableSource?: DisableSource
  /**
   * ApplyCmd is a custom command to execute to deploy entities to the Kubernetes cluster.
   * The command must be idempotent, e.g. it must not fail if some or all entities already exist.
   * The ApplyCmd MUST return valid Kubernetes YAML for the entities it applied to the cluster.
   * Exactly one of YAML OR ApplyCmd MUST be provided.
   * +optional
   */
  applyCmd?: KubernetesApplyCmd
  /**
   * RestartOn determines external triggers that will result in an apply.
   * +optional
   */
  restartOn?: RestartOnSpec
  /**
   * DeleteCmd is a custom command to execute to delete entities created by ApplyCmd and clean up any
   * additional state.
   * +optional
   */
  deleteCmd?: KubernetesApplyCmd
  /**
   * Cluster name to determine the Kubernetes cluster.
   * If not provided, "default" will be used.
   * +optional
   */
  cluster: string
  /**
   * ServerSideApply enables kubectl server-side apply for this resource.
   * When true, kubectl will apply resources on the server instead of the client,
   * which is faster and provides better conflict resolution, especially for large objects.
   * If not provided, defaults to false (client-side apply).
   * +optional
   */
  serverSideApply?: boolean
  /**
   * ForceConflicts enables server-side apply to force changes against conflicts.
   * Only applies when ServerSideApply is true. If there are conflicting fields,
   * server-side apply will force the changes rather than returning an error.
   * +optional
   */
  forceConflicts?: boolean
  /**
   * FieldManager specifies the name of the manager tracking field ownership for server-side apply.
   * Only applies when ServerSideApply is true. If not specified, defaults to "tilt".
   * +optional
   */
  fieldManager?: string
}
/**
 * KubernetesApplyStatus defines the observed state of KubernetesApply
 */
export interface KubernetesApplyStatus {
  /**
   * The result of applying the YAML to the cluster. This should contain
   * UIDs for the applied resources.
   * +optional
   */
  resultYAML?: string
  /**
   * An error applying the YAML.
   * If there was an error, than ResultYAML should be empty (and vice versa).
   * +optional
   */
  error?: string
  /**
   * Timestamp of we last finished applying this YAML to the cluster.
   * When populated, must be equal or after the LastApplyStartTime field.
   * TODO(nick): In v1, we may rename this to LastApplyFinishTime, which
   * is more consistent with how we name this in other API objects.
   * +optional
   */
  lastApplyTime?: string
  /**
   * Timestamp of when we last started applying this YAML to the cluster.
   * +optional
   */
  lastApplyStartTime?: string
  /**
   * A base64-encoded hash of all the inputs to the apply.
   * We added this so that more procedural code can determine whether
   * their updates have been applied yet or not by the reconciler. But any code
   * using it this way should note that the reconciler may "skip" an update
   * (e.g., if two images get updated in quick succession before the reconciler
   * injects them into the YAML), so a particular ApplieInputHash might never appear.
   * +optional
   */
  appliedInputHash?: string
  /**
   * Details about whether/why this is disabled.
   * +optional
   */
  disableStatus?: DisableStatus
  /**
   * Conditions based on the result of the apply.
   * +optional
   */
  conditions?: any /* metav1.Condition */[]
}
/**
 * ApplyConditionJobComplete means the apply was for a batch/v1.Job that has already
 * run to successful completion.
 * Tilt primarily monitors Pods for resource runtime status, but no Pod
 * will be created for the Job in this scenario since it already ran in the
 * past, and it's possible that the Pod has been GC'd (e.g. due to cluster
 * settings or due to a Node being recycled). This condition allows Tilt to
 * bypass Pod monitoring for this resource.
 */
export const ApplyConditionJobComplete: string = "JobComplete"
/**
 * Finds image references in Kubernetes YAML.
 */
export interface KubernetesImageLocator {
  /**
   * Selects which objects to look in.
   */
  objectSelector: ObjectSelector
  /**
   * A JSON path to the image reference field.
   * If Object is empty, the field should be a string.
   * If Object is non-empty, the field should be an object with subfields.
   */
  path: string
  /**
   * A descriptor of the path and structure of an object that describes an image
   * reference. This is a common way to describe images in CRDs, breaking
   * them down into an object rather than an image reference string.
   * +optional
   */
  object?: KubernetesImageObjectDescriptor
}
export interface KubernetesImageObjectDescriptor {
  /**
   * The name of the field that contains the image repository.
   */
  repoField: string
  /**
   * The name of the field that contains the image tag.
   */
  tagField: string
}
export interface KubernetesDiscoveryTemplateSpec {
  /**
   * ExtraSelectors are label selectors that will force discovery of a Pod even
   * if it does not match the AncestorUID.
   * This should only be necessary in the event that a CRD creates Pods but does
   * not set an owner reference to itself.
   */
  extraSelectors?: any /* metav1.LabelSelector */[]
}
export type KubernetesDiscoveryStrategy = string
export interface KubernetesApplyCmd {
  /**
   * Args are the command-line arguments for the apply command. Must have length >= 1.
   */
  args: string[]
  /**
   * Process working directory.
   * If not specified, will default to Tilt working directory.
   * +optional
   * +tilt:local-path=true
   */
  dir: string
  /**
   * Env are additional variables for the process environment.
   * Environment variables are layered on top of the environment variables
   * that Tilt runs with.
   * +optional
   */
  env: string[]
}

//////////
// source: kubernetesdiscovery_types.go

/**
 * KubernetesDiscovery
 * +k8s:openapi-gen=true
 * +tilt:starlark-gen=true
 */
export interface KubernetesDiscovery {
  TypeMeta: null
  metadata?: ObjectMeta
  spec?: KubernetesDiscoverySpec
  status?: KubernetesDiscoveryStatus
}
/**
 * KubernetesDiscoveryList
 * +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
 */
export interface KubernetesDiscoveryList {
  TypeMeta: null
  metadata?: null
  items: KubernetesDiscovery[]
}
/**
 * KubernetesDiscoverySpec defines the desired state of KubernetesDiscovery
 */
export interface KubernetesDiscoverySpec {
  /**
   * Watches determine what resources are discovered.
   * If a discovered resource (e.g. Pod) matches the KubernetesWatchRef UID exactly, it will be reported.
   * If a discovered resource is transitively owned by the KubernetesWatchRef UID, it will be reported.
   */
  watches: KubernetesWatchRef[]
  /**
   * ExtraSelectors are label selectors that will force discovery of a Pod even if it does not match
   * the AncestorUID.
   * This should only be necessary in the event that a CRD creates Pods but does not set an owner reference
   * to itself.
   */
  extraSelectors?: any /* metav1.LabelSelector */[]
  /**
   * PortForwardTemplateSpec describes the data model for port forwards
   * that KubernetesDiscovery should set up.
   * The KubernetesDiscovery controller will choose a "best" candidate
   * for attaching the port-forwarding. Only one PortForward will be
   * active at a time.
   * +optional
   */
  portForwardTemplateSpec?: PortForwardTemplateSpec
  /**
   * PodLogStreamTemplateSpec describes the data model for PodLogStreams
   * that KubernetesDiscovery should set up.
   * The KubernetesDiscovery controller will attach PodLogStream objects
   * to all active pods it discovers.
   * If no template is specified, the controller will stream all
   * pod logs available from the apiserver.
   * +optional
   */
  podLogStreamTemplateSpec?: PodLogStreamTemplateSpec
  /**
   * Cluster name to determine the Kubernetes cluster.
   * If not provided, "default" will be used.
   * +optional
   */
  cluster: string
}
/**
 * KubernetesWatchRef is similar to v1.ObjectReference from the Kubernetes API and is used to determine
 * what objects should be reported on based on discovery.
 */
export interface KubernetesWatchRef {
  /**
   * UID is a Kubernetes object UID.
   * It should either be the exact object UID or the transitive owner.
   * +optional
   */
  uid?: string
  /**
   * Namespace is the Kubernetes namespace for discovery. Required.
   */
  namespace: string
  /**
   * Name is the Kubernetes object name.
   * This is not directly used in discovery; it is extra metadata.
   * +optional
   */
  name?: string
}
/**
 * PortForwardTemplateSpec describes common attributes for PortForwards
 * that can be shared across pods.
 */
export interface PortForwardTemplateSpec {
  /**
   * One or more port forwards to execute on the given pod. Required.
   */
  forwards: Forward[]
}
/**
 * PodLogStreamTemplateSpec describes common attributes for PodLogStreams
 * that can be shared across pods.
 */
export interface PodLogStreamTemplateSpec {
  /**
   * An RFC3339 timestamp from which to show logs. If this value
   * precedes the time a pod was started, only logs since the pod start will be returned.
   * If this value is in the future, no logs will be returned.
   * Translates directly to the underlying PodLogOptions.
   * +optional
   */
  sinceTime?: string
  /**
   * The names of containers to include in the stream.
   * If `onlyContainers` and `ignoreContainers` are not set,
   * will watch all containers in the pod.
   * +optional
   */
  onlyContainers?: string[]
  /**
   * The names of containers to exclude from the stream.
   * If `onlyContainers` and `ignoreContainers` are not set,
   * will watch all containers in the pod.
   * +optional
   */
  ignoreContainers?: string[]
}
/**
 * KubernetesDiscoveryStatus defines the observed state of KubernetesDiscovery
 */
export interface KubernetesDiscoveryStatus {
  /**
   * MonitorStartTime is the timestamp of when Kubernetes resource discovery was started.
   * It is zero if discovery has not been started yet.
   */
  monitorStartTime?: string
  /**
   * Pods that have been discovered based on the criteria in the spec.
   */
  pods: Pod[]
  /**
   * Waiting contains information about why the monitor has not started.
   * +optional
   */
  waiting?: KubernetesDiscoveryStateWaiting
  /**
   * Running contains information about the currently running monitor.
   * +optional
   */
  running?: KubernetesDiscoveryStateRunning
}
export interface KubernetesDiscoveryStateWaiting {
  /**
   * Reason the monitor has not yet been started.
   */
  reason: string
}
export interface KubernetesDiscoveryStateRunning {
  /**
   * StartTime is when Kubernetes resource discovery began.
   */
  startTime: string
}
/**
 * Pod is a collection of containers that can run on a host.
 * The Tilt API representation mirrors the Kubernetes API very closely. Irrelevant data is
 * not included, and some fields might be simplified.
 * There might also be Tilt-specific status fields.
 */
export interface Pod {
  /**
   * UID is the unique Pod UID within the K8s cluster.
   */
  uid: string
  /**
   * Name is the Pod name within the K8s cluster.
   */
  name: string
  /**
   * Namespace is the Pod namespace within the K8s cluster.
   */
  namespace: string
  /**
   * CreatedAt is when the Pod was created.
   */
  createdAt: string
  /**
   * Phase is where the Pod is at in its current lifecycle.
   * Valid values for this are v1.PodPhase values from the Kubernetes API.
   */
  phase: string
  /**
   * Deleting indicates that the Pod is in the process of being removed.
   */
  deleting: boolean
  /**
   * Conditions are various lifecycle conditions for this Pod.
   * See also v1.PodCondition in the Kubernetes API.
   */
  conditions?: PodCondition[]
  /**
   * InitContainers are containers executed prior to the Pod containers being executed.
   */
  initContainers?: Container[]
  /**
   * Containers are the containers belonging to the Pod.
   */
  containers: Container[]
  /**
   * AncestorUID is the UID from the WatchRef that matched this Pod.
   * If the Pod matched based on extra label selectors, this will be empty.
   * +optional
   */
  ancestorUID?: string
  /**
   * PodTemplateSpecHash is a hash of the Pod template spec.
   * Tilt uses this to associate Pods with the build that triggered them.
   */
  podTemplateSpecHash?: string
  /**
   * Status is a concise description for the Pod's current state.
   * This is based off the status output from `kubectl get pod` and is not an "enum-like"
   * value.
   */
  status: string
  /**
   * Errors are aggregated error messages for the Pod and its containers.
   */
  errors: string[]
  /**
   * Direct owner of this pod, if available.
   */
  owner?: PodOwner
}
/**
 * PodOwner contains information of the direct owner of the
 * pod, if available.
 * Tools that need to select a most relevant pod or set of pods
 * can use this info to group pods by owner.
 */
export interface PodOwner {
  /**
   * The name of the owner.
   */
  name: string
  /**
   * API version of the owner.
   */
  apiVersion: string
  /**
   * Kind of the owner
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   */
  kind: string
  /**
   * The creation timestamp of the owner.
   * +optional
   */
  creationTimestamp?: string
}
/**
 * PodCondition is a lifecycle condition for a Pod.
 */
export interface PodCondition {
  /**
   * Type is the type of condition.
   * Valid values for this are v1.PodConditionType values from the Kubernetes API.
   */
  type: string
  /**
   * Status is the current state of the condition (True, False, or Unknown).
   * Valid values for this are v1.PodConditionStatus values from the Kubernetes API.
   */
  status: string
  /**
   * LastTransitionTime is the last time the status changed.
   */
  lastTransitionTime?: string
  /**
   * Reason is a unique, one-word, CamelCase value for the cause of the last status change.
   */
  reason?: string
  /**
   * Message is a human-readable description of the last status change.
   */
  message?: string
}
/**
 * Container is an init or application container within a pod.
 * The Tilt API representation mirrors the Kubernetes API very closely. Irrelevant data is
 * not included, and some fields might be simplified.
 * There might also be Tilt-specific status fields.
 */
export interface Container {
  /**
   * Name is the name of the container as defined in Kubernetes.
   */
  name: string
  /**
   * ID is the normalized container ID (the `docker://` prefix is stripped).
   */
  id: string
  /**
   * Ready is true if the container is passing readiness checks (or has none defined).
   */
  ready: boolean
  /**
   * Image is the image the container is running.
   */
  image: string
  /**
   * Restarts is the number of times the container has restarted.
   * This includes restarts before the Tilt daemon was started if the container was already running.
   */
  restarts: number /* int32 */
  /**
   * State provides details about the container's current condition.
   */
  state: ContainerState
  /**
   * Ports are exposed ports as extracted from the Pod spec.
   * This is added by Tilt for convenience when managing port forwards.
   */
  ports: number /* int32 */[]
}
/**
 * ContainerState holds a possible state of container.
 * Only one of its members may be specified.
 * If none of them is specified, the default one is ContainerStateWaiting.
 */
export interface ContainerState {
  /**
   * Waiting provides details about a container that is not yet running.
   */
  waiting?: ContainerStateWaiting
  /**
   * Running provides details about a currently executing container.
   */
  running?: ContainerStateRunning
  /**
   * Terminated provides details about an exited container.
   */
  terminated?: ContainerStateTerminated
}
/**
 * ContainerStateWaiting is a waiting state of a container.
 */
export interface ContainerStateWaiting {
  /**
   * Reason is a (brief) reason the container is not yet running.
   */
  reason: string
}
/**
 * ContainerStateRunning is a running state of a container.
 */
export interface ContainerStateRunning {
  /**
   * StartedAt is the time the container began running.
   */
  startedAt: string
}
/**
 * ContainerStateTerminated is a terminated state of a container.
 */
export interface ContainerStateTerminated {
  /**
   * StartedAt is the time the container began running.
   */
  startedAt: string
  /**
   * FinishedAt is the time the container stopped running.
   */
  finishedAt: string
  /**
   * Reason is a (brief) reason the container stopped running.
   */
  reason?: string
  /**
   * ExitCode is the exit status from the termination of the container.
   * Any non-zero value indicates an error during termination.
   */
  exitCode: number /* int32 */
}

//////////
// source: liveupdate_types.go

/**
 * LiveUpdate
 * +k8s:openapi-gen=true
 */
export interface LiveUpdate {
  TypeMeta: null
  metadata?: ObjectMeta
  spec?: LiveUpdateSpec
  status?: LiveUpdateStatus
}
/**
 * LiveUpdateList
 * +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
 */
export interface LiveUpdateList {
  TypeMeta: null
  metadata?: null
  items: LiveUpdate[]
}
/**
 * LiveUpdateSpec defines the desired state of LiveUpdate
 */
export interface LiveUpdateSpec {
  /**
   * An absolute local path that serves as the basis for all
   * path calculations.
   * Relative paths in this object are calculated relative to the base path. It
   * cannot be empty.
   * +tilt:local-path=true
   */
  basePath: string
  /**
   * Specifies how this live-updater finds the containers that need live update.
   */
  selector: LiveUpdateSelector
  /**
   * Sources of files to sync.
   * Every live update must be associated with at least one Source object
   * to trigger the update. Usually, Tilt structures it so that there's
   * a Source for each image we depend on.
   */
  sources?: LiveUpdateSource[]
  /**
   * A list of relative paths that will immediately stop the live-update for the
   * current container.
   * Used to detect file changes that invalidate the entire container image,
   * forcing a complete rebuild.
   * +optional
   */
  stopPaths?: string[]
  /**
   * Specify paths that can be live-updated into the container and their destinations.
   * Any file changes observed that do not match any of these will invalidate the container image and force a complete rebuild.
   * +optional
   */
  syncs?: LiveUpdateSync[]
  /**
   * A list of commands to run inside the container after files are synced.
   * NB: In some documentation, we call these 'runs'. 'exec' more clearly
   * matches kubectl exec for remote commands.
   * +optional
   */
  execs?: LiveUpdateExec[]
  /**
   * Specifies whether Tilt should try to natively restart the container in-place
   * after syncs and execs.
   * Note that native restarts are only supported by Docker and Docker Compose
   * (and NOT docker-shim or containerd, the most common Kubernetes runtimes).
   * To restart on live-update in Kubernetes, see the guide for how
   * to apply extensions to add restart behavior:
   * https://docs.tilt.dev/live_update_reference.html
   * +optional
   */
  restart?: LiveUpdateRestartStrategy
}
/**
 * LiveUpdateStatus defines the observed state of LiveUpdate
 */
export interface LiveUpdateStatus {
  /**
   * A list of all containers that the live-updater is currently connected to.
   * +optional
   */
  containers?: LiveUpdateContainerStatus[]
  /**
   * If any of the containers are currently failing to process updates,
   * the Failed state surfaces information about what's happening and what
   * the live-updater is doing to fix the problem.
   * If all containers are updating successfully, Failed will be nil.
   * +optional
   */
  failed?: LiveUpdateStateFailed
}
/**
 * Specifies how to pull in files.
 */
export interface LiveUpdateSource {
  /**
   * The name of a FileWatch to use as a file source.
   * +optional
   */
  fileWatch?: string
  /**
   * Name of the ImageMap object to watch for which file changes from this source
   * are included in the container image.
   * If not provided, the live-updater will copy any file changes that it's aware of,
   * even if they're already included in the container.
   * +optional
   */
  imageMap?: string
}
/**
 * Specifies how to select containers to live update.
 * Every live update must be associated with some object for finding
 * containers. In the future, we expect there to be other types
 * of container discovery objects (like Docker Compose container discovery).
 */
export interface LiveUpdateSelector {
  /**
   * Finds containers in Kubernetes.
   */
  kubernetes?: LiveUpdateKubernetesSelector
  /**
   * Finds containers in Docker Compose.
   */
  dockerCompose?: LiveUpdateDockerComposeSelector
}
/**
 * Specifies how to select containers to live update inside K8s.
 */
export interface LiveUpdateKubernetesSelector {
  /**
   * The name of a KubernetesDiscovery object for finding pods.
   */
  discoveryName: string
  /**
   * ApplyName is the name of a KubernetesApply object for filtering discovered pods to prevent updating old
   * deployments.
   * If not provided, no filtering will be applied and all discovered Pods will be eligible for update.
   * +optional
   */
  applyName?: string
  /**
   * Image specifies the name of the image that we're copying files into.
   * Determines which containers in a pod to live-update.
   * Matches images by name unless tag is explicitly specified.
   * Exactly one of Image, ContainerName, or ImageMapName MUST be specified.
   * +optional
   */
  image?: string
  /**
   * ContainerName specifies the name of the container that we're copying files into.
   * Exactly one of Image, ContainerName, or ImageMapName MUST be specified.
   * +optional
   */
  containerName?: string
  /**
   * ImageMapName specifies the name of an ImageMapName object to use for determining
   * the image we're copying files into.
   * Exactly one of Image, ContainerName, or ImageMapName MUST be specified.
   * +optional
   */
  imageMapName?: string
}
/**
 * Specifies how to select containers to live update inside Docker Compose.
 */
export interface LiveUpdateDockerComposeSelector {
  /**
   * The name of a DockerComposeService object.
   * For simple projects, this is usually the same as the service
   * name in the docker-compose.yml file. (But it doesn't necessarily
   * have to be.)
   */
  service: string
}
/**
 * Determines how a local path maps into a container image.
 */
export interface LiveUpdateSync {
  /**
   * A relative path to local files. Required.
   * Computed relative to the live-update BasePath.
   */
  localPath: string
  /**
   * An absolute path inside the container. Required.
   */
  containerPath: string
}
/**
 * Runs a remote command after files have been synced to the container.
 * Commonly used for small in-container changes (like moving files
 * around, or restart processes).
 */
export interface LiveUpdateExec {
  /**
   * Command-line arguments to run inside the container. Must have length at least 1.
   */
  args: string[]
  /**
   * A list of relative paths that trigger this command exec.
   * If not specified, all file changes seen by the LiveUpdate trigger this exec.
   * Paths are specified relative to the the BasePath of the LiveUpdate.
   * +optional
   */
  triggerPaths: string[]
  echoOff: boolean
}
/**
 * Specifies whether Tilt should try to natively restart the container in-place
 * after syncs and execs.
 * Note that native restarts are only supported by Docker and Docker Compose
 * (and NOT docker-shim or containerd, the most common Kubernetes runtimes).
 * To restart on live-update in Kubernetes, see the guide for how
 * to apply extensions to add restart behavior:
 * https://docs.tilt.dev/live_update_reference.html
 */
export type LiveUpdateRestartStrategy = string
/**
 * LiveUpdateContainerStatus defines the observed state of
 * the live-update syncer for a particular container.
 */
export interface LiveUpdateContainerStatus {
  /**
   * The name of the container in the pod.
   */
  containerName: string
  /**
   * The ID of the container in the pod, in the format 'docker://<container_id>'.
   * +optional
   */
  containerID?: string
  /**
   * The name of the pod this container belongs to.
   */
  podName: string
  /**
   * The namespace of the pod this container belongs to.
   */
  namespace: string
  /**
   * The timestamp of the most recent file update successfully synced to the
   * container.
   * Must match the timestamp in a FileEvent, not the time the sync was performed.
   * +optional
   */
  lastFileTimeSynced?: string
  /**
   * Contains any error messages from the most recent sequence of Execs.
   * Empty if the most recent Execs completed successfully.
   * An ExecError is not necessarily a failure state. For example, a linter
   * error in the container is something we'd want to surface to the user, but
   * not an indication that the live-updater did something wrong.
   * +optional
   */
  lastExecError?: string
  /**
   * Details about a waiting live update.
   * A live update is waiting when the reconciler is aware of file changes
   * that need to be synced to the container, but has decided not to sync them yet.
   */
  waiting?: LiveUpdateContainerStateWaiting
}
/**
 * If any of the containers are currently failing to process updates, the
 * LiveUpdateStateFailed surfaces information about what's happening and what
 * the live-updater is doing to fix the problem.
 */
export interface LiveUpdateStateFailed {
  /**
   * One word camel-case reason why we've reached a failure state.
   * +optional
   */
  reason?: string
  /**
   * Human-readable description of what's wrong.
   * +optional
   */
  message?: string
  /**
   * When the live-updater transitioned into a Failed state.
   * +optional
   */
  lastTransitionTime?: string
}
export interface LiveUpdateContainerStateWaiting {
  /**
   * One word camel-case reason why we're in a waiting state.
   * +optional
   */
  reason?: string
  /**
   * Human-readable description of what's blocking.
   * +optional
   */
  message?: string
}

//////////
// source: objectselector.go

/**
 * Selector for any Kubernetes-style API.
 */
export interface ObjectSelector {
  /**
   * A regular expression apiVersion match.
   * +optional
   */
  apiVersionRegexp?: string
  /**
   * A regular expression kind match.
   * +optional
   */
  kindRegexp?: string
  /**
   * A regular expression name match.
   * +optional
   */
  nameRegexp?: string
  /**
   * A regular expression namespace match.
   * +optional
   */
  namespaceRegexp?: string
}

//////////
// source: podlogstream_types.go

/**
 * PodLogStream
 * Streams logs from a pod on Kubernetes into the core Tilt engine.
 * +k8s:openapi-gen=true
 */
export interface PodLogStream {
  TypeMeta: null
  metadata?: ObjectMeta
  spec?: PodLogStreamSpec
  status?: PodLogStreamStatus
}
/**
 * PodLogStreamList
 * +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
 */
export interface PodLogStreamList {
  TypeMeta: null
  metadata?: null
  items: PodLogStream[]
}
/**
 * PodLogStreamSpec defines the desired state of PodLogStream
 * Translated into a PodLog query to the current Kubernetes cluster:
 * https://pkg.go.dev/k8s.io/api/core/v1#PodLogOptions
 * TODO(nick): Should all Kubernetes types have an object that describes
 * which Kubernetes context to use?
 */
export interface PodLogStreamSpec {
  /**
   * The name of the pod to watch. Required.
   */
  pod?: string
  /**
   * The namespace of the pod to watch. Defaults to the kubecontext default namespace.
   * +optional
   */
  namespace?: string
  /**
   * An RFC3339 timestamp from which to show logs. If this value
   * precedes the time a pod was started, only logs since the pod start will be returned.
   * If this value is in the future, no logs will be returned.
   * Translates directly to the underlying PodLogOptions.
   * +optional
   */
  sinceTime?: string
  /**
   * The names of containers to include in the stream.
   * If `onlyContainers` and `ignoreContainers` are not set,
   * will watch all containers in the pod.
   * +optional
   */
  onlyContainers?: string[]
  /**
   * The names of containers to exclude from the stream.
   * If `onlyContainers` and `ignoreContainers` are not set,
   * will watch all containers in the pod.
   * +optional
   */
  ignoreContainers?: string[]
  /**
   * Cluster the Pod belongs to.
   * If not provided, "default" will be used.
   * +optional
   */
  cluster: string
}
/**
 * PodLogStreamStatus defines the observed state of PodLogStream
 */
export interface PodLogStreamStatus {
  /**
   * A list of containers being watched.
   * +optional
   */
  containerStatuses?: ContainerLogStreamStatus[]
  /**
   * Error message encountered while setting up the stream.
   * +optional
   */
  error?: string
}
/**
 * ContainerLogStreamStatus defines the current status of each individual
 * container log stream.
 */
export interface ContainerLogStreamStatus {
  /**
   * The name of the container.
   */
  name?: string
  /**
   * True when the stream is set up and streaming logs properly.
   * +optional
   */
  active?: boolean
  /**
   * True when the logs are done stream and the container is terminated.
   * +optional
   */
  terminated?: boolean
  /**
   * The last error message encountered while streaming.
   * Empty when the stream is actively streaming or successfully terminated.
   * +optional
   */
  error?: string
}

//////////
// source: portforward_types.go

/**
 * PortForward
 * +k8s:openapi-gen=true
 */
export interface PortForward {
  TypeMeta: null
  metadata?: ObjectMeta
  spec?: PortForwardSpec
  status?: PortForwardStatus
}
/**
 * PortForwardList
 * +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
 */
export interface PortForwardList {
  TypeMeta: null
  metadata?: null
  items: PortForward[]
}
/**
 * PortForwardSpec defines the desired state of PortForward
 */
export interface PortForwardSpec {
  /**
   * The name of the pod to port forward to/from. Required.
   */
  podName: string
  /**
   * The namespace of the pod to port forward to/from. Defaults to the kubecontext default namespace.
   * +optional
   */
  namespace?: string
  /**
   * One or more port forwards to execute on the given pod. Required.
   */
  forwards: Forward[]
  /**
   * Cluster to forward ports from to the local machine.
   * If not specified, the default Kubernetes cluster will be used.
   * +optional
   */
  cluster: string
}
/**
 * Forward defines a port forward to execute on a given pod.
 */
export interface Forward {
  /**
   * The port to expose on the current machine.
   * If not specified (or 0), a random free port will be chosen and can
   * be discovered via the status once established.
   * +optional
   */
  localPort?: number /* int32 */
  /**
   * The port on the Kubernetes pod to connect to. Required.
   */
  containerPort: number /* int32 */
  /**
   * Optional host to bind to on the current machine.
   * If not explicitly specified, uses the bind host of the tilt web UI (usually localhost).
   * +optional
   */
  host: string
  /**
   * Name to identify this port forward.
   * +optional
   */
  name?: string
  /**
   * Path to include as part of generated links for port forward.
   * +optional
   */
  path?: string
}
/**
 * PortForwardStatus defines the observed state of PortForward
 */
export interface PortForwardStatus {
  forwardStatuses?: ForwardStatus[]
}
export interface ForwardStatus {
  /**
   * LocalPort is the port bound to on the system running Tilt.
   */
  localPort: number /* int32 */
  /**
   * ContainerPort is the port in the container being forwarded.
   */
  containerPort: number /* int32 */
  /**
   * Addresses that the forwarder is bound to.
   * For example, a `localhost` host will bind to 127.0.0.1 and [::1].
   */
  addresses: string[]
  /**
   * StartedAt is the time at which the forward was initiated.
   * If the forwarder is not running yet, this will be zero/empty.
   */
  startedAt?: string
  /**
   * Error is a human-readable description if a problem was encountered
   * while initializing the forward.
   */
  error?: string
}

//////////
// source: probe.go

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 */
export interface HTTPHeader {
  /**
   * The header field name
   */
  name: string
  /**
   * The header field value
   */
  value: string
}
/**
 * HTTPGetAction describes an action based on HTTP Get requests.
 */
export interface HTTPGetAction {
  /**
   * Path to access on the HTTP server.
   * +optional
   */
  path?: string
  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   */
  port: number /* int32 */
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   * +optional
   */
  host?: string
  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   * +optional
   */
  scheme?: URIScheme
  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   * +optional
   */
  httpHeaders?: HTTPHeader[]
}
/**
 * URIScheme identifies the scheme used for connection to a host for Get actions
 */
export type URIScheme = string
/**
 * URISchemeHTTP means that the scheme used will be http://
 */
export const URISchemeHTTP: URIScheme = "HTTP"
/**
 * URISchemeHTTPS means that the scheme used will be https://
 */
export const URISchemeHTTPS: URIScheme = "HTTPS"
/**
 * TCPSocketAction describes an action based on opening a socket
 */
export interface TCPSocketAction {
  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   */
  port: number /* int32 */
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   * +optional
   */
  host?: string
}
/**
 * ExecAction describes a "run in container" action.
 */
export interface ExecAction {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   * +optional
   */
  command?: string[]
}
/**
 * Probe describes a health check to be performed to determine whether it is
 * alive or ready to receive traffic.
 */
export interface Probe {
  /**
   * The action taken to determine the health of a container
   */
  Handler: Handler
  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * +optional
   */
  initialDelaySeconds?: number /* int32 */
  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * +optional
   */
  timeoutSeconds?: number /* int32 */
  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   * +optional
   */
  periodSeconds?: number /* int32 */
  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   * +optional
   */
  successThreshold?: number /* int32 */
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   * +optional
   */
  failureThreshold?: number /* int32 */
}
/**
 * Handler defines a specific action that should be taken in a probe.
 */
export interface Handler {
  /**
   * One and only one of the following should be specified.
   * Exec specifies the action to take.
   * +optional
   */
  exec?: ExecAction
  /**
   * HTTPGet specifies the http request to perform.
   * +optional
   */
  httpGet?: HTTPGetAction
  /**
   * TCPSocket specifies an action involving a TCP port.
   * TCP hooks not yet supported
   * TODO: implement a realistic TCP lifecycle hook
   * +optional
   */
  tcpSocket?: TCPSocketAction
}

//////////
// source: register.go

/**
 * GroupName is the group name used in this package
 */
export const GroupName = "tilt.dev"
export const Version = "v1alpha1"
/**
 * AnnotationTargetID is an internal Tilt target ID used for the build graph.
 */
export const AnnotationTargetID = "tilt.dev/target-id"
/**
 * AnnotationManaged declares when an object is managed by a system
 * that's not entirely expressed in apiserver objects.
 */
export const AnnotationManagedBy = "tilt.dev/managed-by"
/**
 * AnnotationManifest identifies which manifest an object's logs should appear under.
 */
export const AnnotationManifest = "tilt.dev/resource"
/**
 * An annotation on any object that identifies which span id
 * its logs should appear under.
 */
export const AnnotationSpanID = "tilt.dev/log-span-id"
/**
 * Denote that the Tiltfile is the owner.
 */
export const OwnerKindTiltfile = "Tiltfile"

//////////
// source: registry_types.go

export interface RegistryHosting {
  /**
   * Host documents the host (hostname and port) of the registry, as seen from
   * outside the cluster.
   * This is the registry host that tools outside the cluster should push images
   * to.
   */
  host: string
  /**
   * HostFromClusterNetwork documents the host (hostname and port) of the
   * registry, as seen from networking inside the container pods.
   * This is the registry host that tools running on pods inside the cluster
   * should push images to. If not set, then tools inside the cluster should
   * assume the local registry is not available to them.
   * +optional
   */
  hostFromClusterNetwork?: string
  /**
   * HostFromContainerRuntime documents the host (hostname and port) of the
   * registry, as seen from the cluster's container runtime.
   * When tools apply Kubernetes objects to the cluster, this host should be
   * used for image name fields. If not set, users of this field should use the
   * value of Host instead.
   * Note that it doesn't make sense semantically to define this field, but not
   * define Host or HostFromClusterNetwork. That would imply a way to pull
   * images without a way to push images.
   * +optional
   */
  hostFromContainerRuntime?: string
  /**
   * Help contains a URL pointing to documentation for users on how to set
   * up and configure a local registry.
   * Tools can use this to nudge users to enable the registry. When possible,
   * the writer should use as permanent a URL as possible to prevent drift
   * (e.g., a version control SHA).
   * When image pushes to a registry host specified in one of the other fields
   * fail, the tool should display this help URL to the user. The help URL
   * should contain instructions on how to diagnose broken or misconfigured
   * registries.
   * +optional
   */
  help?: string
  /**
   * SingleName uses a shared image name for _all_ Tilt-built images and
   * relies on tags to distinguish between logically distinct images.
   * This is most commonly used with Amazon Elastic Container Registry (ECR),
   * which works differently than other image registries.
   * An ECR host takes the form https://aws_account_id.dkr.ecr.region.amazonaws.com.
   * Each image name in that registry must be pre-created à² _à²  and assigned
   * IAM permissions.
   * For example: https://aws_account_id.dkr.ecr.region.amazonaws.com/my-repo
   * (They call this a repo).
   * For this reason, some users using ECR prefer to push all images to a
   * single image name (ECR repo).
   * A recommended pattern here is to create a "personal" image repo for each
   * user during development.
   * See:
   * https://docs.aws.amazon.com/AmazonECR/latest/userguide/Repositories.html
   * https://github.com/tilt-dev/tilt/issues/2419
   * +optional
   */
  singleName?: string
}

//////////
// source: runtimestatus_types.go

/**
 * The RuntimeStatus is a simple, high-level summary of the runtime state of a server.
 */
export type RuntimeStatus = string
/**
 * The server runtime status hasn't been read yet.
 */
export const RuntimeStatusUnknown: RuntimeStatus = "unknown"
/**
 * The server runtime is OK and passing health checks.
 */
export const RuntimeStatusOK: RuntimeStatus = "ok"
/**
 * The server runtime is still being scheduled or waiting on health checks.
 */
export const RuntimeStatusPending: RuntimeStatus = "pending"
/**
 * The server runtime is in an error state.
 */
export const RuntimeStatusError: RuntimeStatus = "error"
/**
 * There's no server runtime for this resource and never will be.
 */
export const RuntimeStatusNotApplicable: RuntimeStatus = "not_applicable"
/**
 * This server hasn't had any reason to start yet.
 * This usually indicates that it's a manual trigger with no auto_init.
 */
export const RuntimeStatusNone: RuntimeStatus = "none"

//////////
// source: session_types.go

/**
 * Session provides introspective data about the status of the Tilt process.
 * +k8s:openapi-gen=true
 */
export interface Session {
  TypeMeta: null
  metadata?: ObjectMeta
  spec?: SessionSpec
  status?: SessionStatus
}
/**
 * SessionList is a list of Session objects.
 * +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
 */
export interface SessionList {
  TypeMeta: null
  metadata?: null
  items: Session[]
}
/**
 * SessionSpec defines the desired state of Session
 */
export interface SessionSpec {
  /**
   * TiltfilePath is the path to the Tiltfile for the run. It cannot be empty.
   */
  tiltfilePath: string
  /**
   * ExitCondition defines the criteria for Tilt to exit.
   */
  exitCondition: ExitCondition
  /**
   * Additional settings when in exitCondition=CI.
   */
  ci?: SessionCISpec
}
export interface SessionCISpec {
  /**
   * Grace period given for Kubernetes resources to recover after
   * they start failing.
   * If omitted, and in exitCondition=ci, the session will exit as soon
   * as we see a pod failure.
   */
  k8sGracePeriod?: any /* metav1.Duration */
  /**
   * Timeout for the whole CI pipeline. Defaults to 30m.
   */
  timeout?: any /* metav1.Duration */
  /**
   * Timeout for an active resource to become ready before the CI pipeline fails.
   * Measured from the time the resource is started.
   * Defaults to 5m.
   * Does not affect Kubernetes jobs.
   */
  readinessTimeout?: any /* metav1.Duration */
}
export type ExitCondition = string
/**
 * ExitConditionManual cedes control to the user and will not exit based on resource status.
 * This is used by `tilt up`.
 */
export const ExitConditionManual: ExitCondition = "manual"
/**
 * ExitConditionCI terminates upon the first encountered build or runtime failure or after all resources have been
 * started successfully.
 * This is used by `tilt ci`.
 */
export const ExitConditionCI: ExitCondition = "ci"
/**
 * SessionStatus defines the observed state of Session
 */
export interface SessionStatus {
  /**
   * PID is the process identifier for this instance of Tilt.
   */
  pid: number /* int64 */
  /**
   * StartTime is when the Tilt engine was first started.
   */
  startTime: string
  /**
   * Targets are normalized representations of the servers/jobs managed by this Session.
   * A resource from a Tiltfile might produce one or more targets. A target can also be shared across
   * multiple resources (e.g. an image referenced by multiple K8s pods).
   */
  targets: Target[]
  /**
   * Done indicates whether this Session has completed its work and is ready to exit.
   */
  done: boolean
  /**
   * Error is a non-empty string when the Session is Done but encountered a failure as defined by the ExitCondition
   * from the SessionSpec.
   * +optional
   */
  error?: string
}
/**
 * Target is a server or job whose execution is managed as part of this Session.
 */
export interface Target {
  /**
   * Name is the name of the target; this is auto-generated from Tiltfile resources.
   */
  name: string
  /**
   * Type is the execution profile for this resource.
   * Job targets run to completion (e.g. a build script or database migration script).
   * Server targets run indefinitely (e.g. an HTTP server).
   */
  type: TargetType
  /**
   * Resources are one or more Tiltfile resources that this target is associated with.
   */
  resources: string[]
  /**
   * State provides information about the current status of the target.
   */
  state: TargetState
}
/**
 * TargetType describes a high-level categorization about the expected execution behavior for the target.
 */
export type TargetType = string
/**
 * TargetTypeJob is a target that is expected to run to completion.
 */
export const TargetTypeJob: TargetType = "job"
/**
 * TargetTypeServer is a target that runs indefinitely.
 */
export const TargetTypeServer: TargetType = "server"
/**
 * TargetState describes the current execution status for a target.
 * Either EXACTLY one of Waiting, Active, Disabled, or Terminated will be populated or NONE of them will be.
 * In the event that all states are null, the target is currently inactive or disabled and should not
 * be expected to execute.
 */
export interface TargetState {
  /**
   * Waiting being non-nil indicates that the next execution of the target has been queued but not yet started.
   * +optional
   */
  waiting?: TargetStateWaiting
  /**
   * Active being non-nil indicates that the target is currently executing.
   * +optional
   */
  active?: TargetStateActive
  /**
   * Terminated being non-nil indicates that the target finished execution either normally or due to failure.
   * +optional
   */
  terminated?: TargetStateTerminated
  /**
   * Disabled being non-nil indicates that the target is disabled.
   * +optional
   */
  disabled?: TargetStateDisabled
}
/**
 * TargetStateWaiting is a target that has been enqueued for execution but has not yet started.
 */
export interface TargetStateWaiting {
  /**
   * WaitReason is a description for why the target is waiting and not yet active.
   * This is NOT the "cause" or "trigger" for the target being invoked.
   */
  waitReason: string
}
/**
 * TargetStateActive is a target that is currently running but has not yet finished.
 */
export interface TargetStateActive {
  /**
   * StartTime is when execution began.
   */
  startTime: string
  /**
   * Ready indicates that the target has passed readiness checks.
   * If the target does not use or support readiness checks, this is always true.
   */
  ready: boolean
  /**
   * LastReadyTime is when the target last passed readiness checks.
   */
  lastReadyTime: string
}
export type TargetGraceStatus = string
/**
 * No grace period applies to the target.
 */
export const TargetGraceNotApplicable: TargetGraceStatus = ""
/**
 * The target is in the error state, but has not
 * yet exceeded the grace period.
 */
export const TargetGraceTolerated: TargetGraceStatus = "Tolerated"
/**
 * The target was in an error state longer than
 * the grace perod.
 */
export const TargetGraceExceeded: TargetGraceStatus = "Exceeded"
/**
 * TargetStateTerminated is a target that finished running, either because it completed successfully or
 * encountered an error.
 */
export interface TargetStateTerminated {
  /**
   * StartTime is when the target began executing.
   */
  startTime: string
  /**
   * FinishTime is when the target stopped executing.
   */
  finishTime: string
  /**
   * Error is a non-empty string if the target encountered a failure during execution that caused it to stop.
   * For targets of type TargetTypeServer, this is always populated, as the target is expected to run indefinitely,
   * and thus any termination is an error.
   * +optional
   */
  error?: string
  /**
   * Errors may be tolerated if the target is still within a grace period set on
   * the session.
   */
  graceStatus?: TargetGraceStatus
}
/**
 * TargetStateDisabled is a target that has been disabled.
 */
export interface TargetStateDisabled {}

//////////
// source: tiltfile_types.go

/**
 * Tiltfile is the main way users add services to Tilt.
 * The Tiltfile evaluator executes the Tiltfile, then adds all the objects
 * it creates as children of the Tiltfile object.
 * +k8s:openapi-gen=true
 */
export interface Tiltfile {
  TypeMeta: null
  metadata?: ObjectMeta
  spec?: TiltfileSpec
  status?: TiltfileStatus
}
/**
 * TiltfileList
 * +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
 */
export interface TiltfileList {
  TypeMeta: null
  metadata?: null
  items: Tiltfile[]
}
/**
 * TiltfileSpec defines the desired state of Tiltfile
 */
export interface TiltfileSpec {
  /**
   * The path to the Tiltfile on disk.
   */
  path: string
  /**
   * A set of labels to apply to all objects owned by this Tiltfile.
   * +optional
   */
  labels?: { [key: string]: string }
  /**
   * Objects that can trigger a re-execution of this Tiltfile.
   * +optional
   */
  restartOn?: RestartOnSpec
  /**
   * Arguments to the Tiltfile.
   * Arguments can be positional (['a', 'b', 'c']) or flag-based ('--to-edit=a').
   * By default, a list of arguments indicates the list of services in the tiltfile
   * that should be enabled.
   * +optional
   */
  args?: string[]
  /**
   * Objects that can stop execution of this Tiltfile.
   * +optional
   */
  stopOn?: StopOnSpec
}
/**
 * TiltfileStatus defines the observed state of Tiltfile
 */
export interface TiltfileStatus {
  /**
   * Details about a waiting tiltfile.
   * +optional
   */
  waiting?: TiltfileStateWaiting
  /**
   * Details about a running tiltfile.
   * +optional
   */
  running?: TiltfileStateRunning
  /**
   * Details about a terminated tiltfile.
   * +optional
   */
  terminated?: TiltfileStateTerminated
}
/**
 * TiltfileStateWaiting is a waiting state of a tiltfile execution.
 */
export interface TiltfileStateWaiting {
  /**
   * (brief) reason the tiltfile is waiting.
   * +optional
   */
  reason?: string
}
/**
 * TiltfileStateRunning is a running state of a tiltfile execution.
 */
export interface TiltfileStateRunning {
  /**
   * The reason why this tiltfile was built.
   * May contain more than one reason.
   * +optional
   */
  reasons?: string[]
  /**
   * Time at which previous execution of the command started.
   */
  startedAt?: string
}
/**
 * TiltfileStateTerminated is a terminated state of a tiltfile execution.
 */
export interface TiltfileStateTerminated {
  /**
   * The reasons why this tiltfile was built.
   * May contain more than one reason.
   * +optional
   */
  reasons?: string[]
  /**
   * Error message if this tiltfile execution failed.
   * +optional
   */
  error?: string
  /**
   * Time at which previous execution of the command started.
   */
  startedAt?: string
  /**
   * Time at which the command last terminated.
   */
  finishedAt?: string
  /**
   * Number of warnings generated by this Tiltfile.
   * (brief) reason the process is terminated
   * +optional
   */
  warningCount?: number /* int32 */
}

//////////
// source: togglebutton_types.go

/**
 * ToggleButton
 * +k8s:openapi-gen=true
 */
export interface ToggleButton {
  TypeMeta: null
  metadata?: ObjectMeta
  spec?: ToggleButtonSpec
  status?: ToggleButtonStatus
}
/**
 * ToggleButtonList
 * +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
 */
export interface ToggleButtonList {
  TypeMeta: null
  metadata?: null
  items: ToggleButton[]
}
/**
 * ToggleButtonSpec defines the desired state of ToggleButton
 */
export interface ToggleButtonSpec {
  /**
   * Where to display the button
   */
  location: UIComponentLocation
  /**
   * Config for the button when it is "on"
   */
  on: ToggleButtonStateSpec
  /**
   * Config for the button when it is "off"
   */
  off: ToggleButtonStateSpec
  /**
   * If `StateSource` does not point at a valid value, the initial button
   * state will be "on" or "off" depending on this bool
   */
  defaultOn: boolean
  /**
   * Where the toggle button's state is stored
   */
  stateSource: StateSource
}
/**
 * Describes a state (on/off) of a ToggleButton
 */
export interface ToggleButtonStateSpec {
  /**
   * Text to appear on the button itself or as hover text (depending on button location).
   */
  text: string
  /**
   * IconName is a Material Icon to appear next to button text or on the button itself (depending on button location).
   * Valid values are icon font ligature names from the Material Icons set.
   * See https://fonts.google.com/icons for the full list of available icons.
   * If both IconSVG and IconName are specified, IconSVG will take precedence.
   * +optional
   */
  iconName?: string
  /**
   * IconSVG is an SVG to use as the icon to appear next to button text or on the button itself (depending on button
   * location).
   * This should be an <svg> element scaled for a 24x24 viewport.
   * If both IconSVG and IconName are specified, IconSVG will take precedence.
   * +optional
   */
  iconSVG?: string
  /**
   * If true, clicking the button in this state requires a second click
   * to confirm.
   * +optional
   */
  requiresConfirmation?: boolean
}
/**
 * Describes where a ToggleButton's state is stored.
 * Exactly one type of source must be set.
 */
export interface StateSource {
  /**
   * State is stored in a ConfigMap.
   * +optional
   */
  configMap?: ConfigMapStateSource
}
/**
 * Describes how a ToggleButton's state is stored in a ConfigMap.
 * The ConfigMap must be created separately - the ToggleButton will not automatically create it.
 */
export interface ConfigMapStateSource {
  /**
   * Name of the ConfigMap
   */
  name: string
  /**
   * Key within the ConfigMap
   */
  key: string
  /**
   * ConfigMap value corresponding to the button's "on" state.
   * If not specified, "true" will be used.
   * +optional
   */
  onValue?: string
  /**
   * ConfigMap value corresponding to the button's "off" state
   * If not specified, "false" will be used.
   */
  offValue?: string
}
/**
 * ToggleButtonStatus defines the observed state of ToggleButton
 */
export interface ToggleButtonStatus {
  /**
   * If healthy, empty. If non-healthy, specifies a problem the ToggleButton encountered
   * +optional
   */
  error: string
}

//////////
// source: trigger_types.go

/**
 * RestartOnSpec indicates the set of objects that can trigger a restart of this object.
 */
export interface RestartOnSpec {
  /**
   * FileWatches that can trigger a restart.
   * +optional
   */
  fileWatches?: string[]
  /**
   * UIButtons that can trigger a restart.
   * +optional
   */
  uiButtons?: string[]
}
/**
 * StartOnSpec indicates the set of objects that can trigger a start/restart of this object.
 */
export interface StartOnSpec {
  /**
   * StartAfter indicates that events before this time should be ignored.
   * +optional
   */
  startAfter?: any /* v1.Time */
  /**
   * UIButtons that can trigger a start/restart.
   */
  uiButtons: string[]
}
export interface StopOnSpec {
  /**
   * UIButtons that can trigger a stop.
   */
  uiButtons: string[]
}

//////////
// source: uibutton_types.go

/**
 * UIButton
 * +k8s:openapi-gen=true
 * +tilt:starlark-gen=true
 */
export interface UIButton {
  TypeMeta: null
  metadata?: ObjectMeta
  spec?: UIButtonSpec
  status?: UIButtonStatus
}
/**
 * UIButtonList
 * +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
 */
export interface UIButtonList {
  TypeMeta: null
  metadata?: null
  items: UIButton[]
}
/**
 * UIButtonSpec defines the desired state of UIButton
 */
export interface UIButtonSpec {
  /**
   * Location associates the button with another component for layout.
   */
  location: UIComponentLocation
  /**
   * Text to appear on the button itself or as hover text (depending on button location).
   */
  text: string
  /**
   * IconName is a Material Icon to appear next to button text or on the button itself (depending on button location).
   * Valid values are icon font ligature names from the Material Icons set.
   * See https://fonts.google.com/icons for the full list of available icons.
   * If both IconSVG and IconName are specified, IconSVG will take precedence.
   * +optional
   */
  iconName?: string
  /**
   * IconSVG is an SVG to use as the icon to appear next to button text or on the button itself (depending on button
   * location).
   * This should be an <svg> element scaled for a 24x24 viewport.
   * If both IconSVG and IconName are specified, IconSVG will take precedence.
   * +optional
   */
  iconSVG?: string
  /**
   * If true, the button will be rendered, but with an effect indicating it's
   * disabled. It will also be unclickable.
   * +optional
   */
  disabled?: boolean
  /**
   * If true, the UI will require the user to click the button a second time to
   * confirm before taking action
   * +optional
   */
  requiresConfirmation?: boolean
  /**
   * Any inputs for this button.
   * +optional
   */
  inputs?: UIInputSpec[]
}
/**
 * UIComponentLocation specifies where to put a UI component.
 */
export interface UIComponentLocation {
  /**
   * ComponentID is the identifier of the parent component to associate this component with.
   * For example, this is a resource name if the ComponentType is Resource.
   */
  componentID: string
  /**
   * ComponentType is the type of the parent component.
   */
  componentType: ComponentType
}
export type ComponentType = string
export const ComponentTypeResource: ComponentType = "Resource"
export const ComponentTypeGlobal: ComponentType = "Global"
export interface UIComponentLocationResource {
  resourceName: string
}
/**
 * used by the backend to indicate to the frontend that this button is special
 */
export const AnnotationButtonType = "tilt.dev/uibutton-type"
export const ButtonTypeDisableToggle = "DisableToggle"
export const ButtonTypeStopBuild = "StopBuild"
/**
 * Describes a text input field attached to a button.
 */
export interface UITextInputSpec {
  /**
   * Initial value for this field.
   * +optional
   */
  defaultValue?: string
  /**
   * A short hint that describes the expected input of this field.
   * +optional
   */
  placeholder?: string
}
export interface UITextInputStatus {
  /**
   * The content of the text input.
   */
  value: string
}
/**
 * Describes a boolean checkbox input field attached to a button.
 */
export interface UIBoolInputSpec {
  /**
   * Whether the input is initially true or false.
   * +optional
   */
  defaultValue?: boolean
  /**
   * If the input's value is converted to a string, use this when the value is true.
   * If unspecified, its string value will be `"true"`
   * +optional
   */
  trueString?: string
  /**
   * If the input's value is converted to a string, use this when the value is false.
   * If unspecified, its string value will be `"false"`
   * +optional
   */
  falseString?: string
}
export interface UIBoolInputStatus {
  value: boolean
}
/**
 * Describes a hidden input field attached to a button,
 * with a value to pass on any submit.
 */
export interface UIHiddenInputSpec {
  value: string
}
export interface UIHiddenInputStatus {
  value: string
}
/**
 * Describes a choice dropdown input field attached to a button
 */
export interface UIChoiceInputSpec {
  /**
   * The list of valid values for this field
   * +optional
   */
  choices: string[]
}
export interface UIChoiceInputStatus {
  value: string
}
/**
 * Defines an Input to render in the UI.
 * If UIButton is analogous to an HTML <form>,
 * UIInput is analogous to an HTML <input>.
 */
export interface UIInputSpec {
  /**
   * Name of this input. Must be unique within the UIButton.
   */
  name: string
  /**
   * A label to display next to this input in the UI.
   * +optional
   */
  label: string
  /**
   * A Text input that takes a string.
   * +optional
   */
  text?: UITextInputSpec
  /**
   * A Bool input that is true or false
   * +optional
   */
  bool?: UIBoolInputSpec
  /**
   * An input that has a constant value and does not display to the user
   * +optional
   */
  hidden?: UIHiddenInputSpec
  /**
   * A Choice input that takes a list of strings
   */
  choice?: UIChoiceInputSpec
}
/**
 * The status corresponding to a UIInputSpec
 */
export interface UIInputStatus {
  /**
   * Name of the input whose status this is. Must match the `Name` of a corresponding
   * UIInputSpec.
   */
  name: string
  /**
   * The status of the input, if it's text
   * +optional
   */
  text?: UITextInputStatus
  /**
   * The status of the input, if it's a bool
   * +optional
   */
  bool?: UIBoolInputStatus
  /**
   * The status of the input, if it's a hidden
   * +optional
   */
  hidden?: UIHiddenInputStatus
  /**
   * The status of the input, if it's a choice
   * +optional
   */
  choice?: UIChoiceInputStatus
}
/**
 * UIButtonStatus defines the observed state of UIButton
 */
export interface UIButtonStatus {
  /**
   * LastClickedAt is the timestamp of the last time the button was clicked.
   * If the button has never clicked before, this will be the zero-value/null.
   */
  lastClickedAt?: string
  /**
   * Status of any inputs on this button.
   * +optional
   */
  inputs?: UIInputStatus[]
}

//////////
// source: uiresource_types.go

/**
 * UIResource represents per-resource status data for rendering the web UI.
 * Treat this as a legacy data structure that's more intended to make transition
 * easier rather than a robust long-term API.
 * +k8s:openapi-gen=true
 */
export interface UIResource {
  TypeMeta: null
  metadata?: ObjectMeta
  spec?: UIResourceSpec
  status?: UIResourceStatus
}
/**
 * UIResourceList
 * +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
 */
export interface UIResourceList {
  TypeMeta: null
  metadata?: null
  items: UIResource[]
}
/**
 * UIResourceSpec is an empty struct.
 * UIResource is a kludge for making Tilt's internal status readable, not
 * for specifying behavior.
 */
export interface UIResourceSpec {}
/**
 * Aggregated disable status of DisableSources that belong to a resource.
 */
export interface DisableResourceStatus {
  /**
   * How many of the resource's sources are enabled.
   */
  enabledCount: number /* int32 */
  /**
   * How many of the resource's sources are disabled.
   */
  disabledCount: number /* int32 */
  /**
   * Whether this is currently disabled (if known)
   */
  state: DisableState
  /**
   * All unique sources that control the resource's objects' disable status.
   */
  sources: DisableSource[]
}
/**
 * UIResourceStatus defines the observed state of UIResource
 */
export interface UIResourceStatus {
  /**
   * The last time this resource was deployed.
   * +optional
   */
  lastDeployTime?: string
  /**
   * Bit mask representing whether this resource is run when:
   * 1) When a file changes
   * 2) When the resource initializes
   * +optional
   */
  triggerMode?: number /* int32 */
  /**
   * Past completed builds.
   * +optional
   */
  buildHistory?: UIBuildTerminated[]
  /**
   * The currently running build, if any.
   * +optional
   */
  currentBuild?: UIBuildRunning
  /**
   * When the build was put in the pending queue.
   * +optional
   */
  pendingBuildSince?: string
  /**
   * True if the build was put in the pending queue due to file changes.
   * +optional
   */
  hasPendingChanges?: boolean
  /**
   * Links attached to this resource.
   * +optional
   */
  endpointLinks?: UIResourceLink[]
  /**
   * Extra data about Kubernetes resources.
   * +optional
   */
  k8sResourceInfo?: UIResourceKubernetes
  /**
   * Extra data about Compose resources.
   * +optional
   */
  composeResourceInfo?: UIResourceCompose
  /**
   * Extra data about Local resources
   * +optional
   */
  localResourceInfo?: UIResourceLocal
  /**
   * The RuntimeStatus is a simple, high-level summary of the runtime state of a server.
   * Not all resources run servers.
   * +optional
   */
  runtimeStatus?: RuntimeStatus
  /**
   * The UpdateStatus is a simple, high-level summary of any update tasks to bring
   * the resource up-to-date.
   * If the resource runs a server, this may include both build tasks and live-update
   * syncing.
   * +optional
   */
  updateStatus?: UpdateStatus
  /**
   * Information about all the target specs that this resource summarizes.
   * +optional
   */
  specs?: UIResourceTargetSpec[]
  /**
   * Queued is a simple indicator of whether the resource is queued for an update.
   * +optional
   */
  queued?: boolean
  /**
   * Order expresses the relative order of resources in the UI when they're not
   * otherwise sorted. Lower integers go first. When two resources have the same
   * order, they should be sorted by name.
   * When UIResources are generated from the Tiltfile, we use the order they
   * were added to the Tiltfile for the Order field.
   * +optional
   */
  order?: number /* int32 */
  /**
   * Information about the resource's objects' disabled status.
   */
  disableStatus?: DisableResourceStatus
  /**
   * Waiting provides detail on why the resource is currently blocked from updating.
   * +optional
   */
  waiting?: UIResourceStateWaiting
  /**
   * Represents the latest available observations of a UIResource's current state.
   * Designed for compatibility with 'wait' and cross-resource status reporting.
   * https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#typical-status-properties
   * +optional
   */
  conditions?: UIResourceCondition[]
}
/**
 * UIResourceLink represents a link assocatiated with a UIResource.
 */
export interface UIResourceLink {
  /**
   * A URL to link to.
   * +optional
   */
  url?: string
  /**
   * The display label on a URL.
   * +optional
   */
  name?: string
}
/**
 * UIResourceTargetType identifies the different categories of
 * task in a resource.
 */
export type UIResourceTargetType = string
/**
 * The target type is unspecified.
 */
export const UIResourceTargetTypeUnspecified: UIResourceTargetType =
  "unspecified"
/**
 * The target is a container image build.
 */
export const UIResourceTargetTypeImage: UIResourceTargetType = "image"
/**
 * The target is a Kubernetes resource deployment.
 */
export const UIResourceTargetTypeKubernetes: UIResourceTargetType = "k8s"
/**
 * The target is a Docker Compose service deployment.
 */
export const UIResourceTargetTypeDockerCompose: UIResourceTargetType =
  "docker-compose"
/**
 * The target is a local command or server.
 */
export const UIResourceTargetTypeLocal: UIResourceTargetType = "local"
/**
 * UIResourceTargetSpec represents the spec of a build or deploy that a resource summarizes.
 */
export interface UIResourceTargetSpec {
  /**
   * The ID of the target.
   * +optional
   */
  id?: string
  /**
   * The type of the target.
   * +optional
   */
  type?: UIResourceTargetType
  /**
   * Whether the target has a live update associated with it.
   * +optional
   */
  hasLiveUpdate?: boolean
}
/**
 * UIBuildRunning represents an in-progress build/update in the user interface.
 */
export interface UIBuildRunning {
  /**
   * The time when the build started.
   * +optional
   */
  startTime?: string
  /**
   * The log span where the build logs are stored in the logstore.
   * +optional
   */
  spanID?: string
}
/**
 * UIBuildRunning represents a finished build/update in the user interface.
 */
export interface UIBuildTerminated {
  /**
   * A non-empty string if the build failed with an error.
   * +optional
   */
  error?: string
  /**
   * A list of warnings encountered while running the build.
   * These warnings will also be printed to the build's log.
   * +optional
   */
  warnings?: string[]
  /**
   * The time when the build started.
   * +optional
   */
  startTime?: string
  /**
   * The time when the build finished.
   * +optional
   */
  finishTime?: string
  /**
   * The log span where the build logs are stored in the logstore.
   * +optional
   */
  spanID?: string
  /**
   * A crash rebuild happens when Tilt live-updated a container, then
   * the pod crashed, wiping out the live-updates. Tilt does a full
   * build+deploy to reset the pod state to what's on disk.
   * +optional
   */
  isCrashRebuild?: boolean
}
/**
 * UIResourceKubernetes contains status information specific to Kubernetes.
 */
export interface UIResourceKubernetes {
  /**
   * The name of the active pod.
   * The active pod tends to be what Tilt defaults to for port-forwards,
   * live-updates, etc.
   * +optional
   */
  podName?: string
  /**
   * The creation time of the active pod.
   * +optional
   */
  podCreationTime?: string
  /**
   * The last update time of the active pod
   * +optional
   */
  podUpdateStartTime?: string
  /**
   * The status of the active pod.
   * +optional
   */
  podStatus?: string
  /**
   * Extra error messaging around the current status of the active pod.
   * +optional
   */
  podStatusMessage?: string
  /**
   * Whether all the containers in the pod are currently healthy
   * and have passed readiness checks.
   * +optional
   */
  allContainersReady?: boolean
  /**
   * The number of pod restarts.
   * +optional
   */
  podRestarts?: number /* int32 */
  /**
   * The span where this pod stores its logs in the Tilt logstore.
   * +optional
   */
  spanID?: string
  /**
   * The list of all resources deployed in the Kubernetes deploy
   * for this resource.
   * +optional
   */
  displayNames?: string[]
}
/**
 * UIResourceCompose contains status information specific to Docker Compose.
 */
export interface UIResourceCompose {
  /**
   * Status is one of Starting, Healthy or Unhealthy
   */
  healthStatus?: string
}
/**
 * UIResourceLocal contains status information specific to local commands.
 */
export interface UIResourceLocal {
  /**
   * The PID of the actively running local command.
   * +optional
   */
  pid?: number /* int64 */
  /**
   * Whether this represents a test job.
   * Deprecated: Users should use labels for marking services as tests.
   * +optional
   */
  isTest?: boolean
}
export interface UIResourceStateWaiting {
  /**
   * Reason is a unique, one-word reason for why the UIResource update is pending.
   */
  reason: string
  /**
   * HoldingOn is the set of objects blocking this resource from updating.
   * These objects might NOT be explicit dependencies of the current resource. For example, if an un-parallelizable
   * resource is updating, all other resources with queued updates will be holding on it with a reason of
   * `waiting-for-local`.
   * +optional
   */
  on?: UIResourceStateWaitingOnRef[]
}
export interface UIResourceStateWaitingOnRef {
  /**
   * Group for the object type being waited on.
   */
  group: string
  /**
   * APIVersion for the object type being waited on.
   */
  apiVersion: string
  /**
   * Kind of the object type being waited on.
   */
  kind: string
  /**
   * Name of the object being waiting on.
   */
  name: string
}
export type UIResourceConditionType = string
/**
 * Ready means the UI Resource has built, deployed, and passed any readiness checks.
 */
export const UIResourceReady: UIResourceConditionType = "Ready"
/**
 * UpToDate means that the UI Resource has successfully built and deployed all
 * its components. Runtime checks may not be passing yet.
 */
export const UIResourceUpToDate: UIResourceConditionType = "UpToDate"
export interface UIResourceCondition {
  /**
   * Type of UI Resource condition.
   */
  type: UIResourceConditionType
  /**
   * Status of the condition, one of True, False, Unknown.
   */
  status: any /* metav1.ConditionStatus */
  /**
   * Last time the condition transitioned from one status to another.
   * +optional
   */
  lastTransitionTime?: string
  /**
   * The reason for the condition's last transition.
   * +optional
   */
  reason?: string
  /**
   * A human readable message indicating details about the transition.
   * +optional
   */
  message?: string
}

//////////
// source: uisession_types.go

/**
 * UISession represents global status data for rendering the web UI.
 * Treat this as a legacy data structure that's more intended to make transition
 * easier rather than a robust long-term API.
 * Per-resource status data should be stored in UIResource.
 * +k8s:openapi-gen=true
 */
export interface UISession {
  TypeMeta: null
  metadata?: ObjectMeta
  spec?: UISessionSpec
  status?: UISessionStatus
}
/**
 * UISessionList
 * +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
 */
export interface UISessionList {
  TypeMeta: null
  metadata?: null
  items: UISession[]
}
/**
 * UISessionSpec is an empty struct.
 * UISession is a kludge for making Tilt's internal status readable, not
 * for specifying behavior.
 */
export interface UISessionSpec {}
/**
 * UISessionStatus defines the observed state of UISession
 */
export interface UISessionStatus {
  /**
   * FeatureFlags reports a list of experimental features that have been
   * enabled.
   * +optional
   */
  featureFlags?: UIFeatureFlag[]
  /**
   * NeedsAnalyticsNudge reports whether the UI hasn't opted in or out
   * of analytics, and the UI should nudge them to do so.
   * +optional
   */
  needsAnalyticsNudge?: boolean
  /**
   * RunningTiltBuild reports the currently running version of tilt
   * that this UI is talking to.
   * +optional
   */
  runningTiltBuild?: TiltBuild
  /**
   * SuggestedTiltVersion tells the UI the recommended version for this
   * user. If the version is different than what's running, the UI
   * may display a prompt to upgrade.
   * +optional
   */
  suggestedTiltVersion?: string
  /**
   * VersionSettings indicates whether version updates have been enabled/disabled
   * from the Tiltfile.
   * +optional
   */
  versionSettings?: VersionSettings
  /**
   * TiltCloudUsername reports the username if the user is signed into
   * TiltCloud.
   * deprecated: no longer populated
   * +optional
   */
  tiltCloudUsername?: string
  /**
   * TiltCloudUsername reports the human-readable team name if the user is
   * signed into TiltCloud and the Tiltfile declares a team.
   * deprecated: no longer populated
   * +optional
   */
  tiltCloudTeamName?: string
  /**
   * TiltCloudSchemeHost reports the base URL of the Tilt Cloud instance
   * associated with this Tilt process. Usually https://cloud.tilt.dev
   * deprecated: no longer populated
   * +optional
   */
  tiltCloudSchemeHost?: string
  /**
   * TiltCloudTeamID reports the unique team id if the user is signed into
   * TiltCloud and the Tiltfile declares a team.
   * deprecated: no longer populated
   * +optional
   */
  tiltCloudTeamID?: string
  /**
   * A FatalError is an error that forces Tilt to stop its control loop.
   * The API server will stay up and continue to serve the UI, but
   * no further builds will happen.
   * +optional
   */
  fatalError?: string
  /**
   * The time that this instance of tilt started.
   * Clients can use this to determine if the API server has restarted
   * and all the objects need to be refreshed.
   * +optional
   */
  tiltStartTime?: string
  /**
   * An identifier for the Tiltfile that is running.
   * Clients can use this to store data associated with a particular
   * project in LocalStorage or other persistent storage.
   * +optional
   */
  tiltfileKey?: string
}
/**
 * Configures Tilt to enable non-default features (e.g., experimental or
 * deprecated).
 * The Tilt features controlled by this are generally in an unfinished state,
 * and not yet documented.
 * As a Tilt user, you donâ€™t need to worry about this unless something
 * else directs you to (e.g., an experimental feature doc, or a conversation
 * with a Tilt contributor).
 */
export interface UIFeatureFlag {
  /**
   * The name of the flag.
   * +optional
   */
  name?: string
  /**
   * The value of the flag.
   * +optional
   */
  value?: boolean
}
/**
 * Information about the running tilt binary.
 */
export interface TiltBuild {
  /**
   * A semantic version string.
   * +optional
   */
  version?: string
  /**
   * The Git digest of the commit this binary was built at.
   * +optional
   */
  commitSHA?: string
  /**
   * A human-readable string representing when the binary was built.
   * +optional
   */
  date?: string
  /**
   * Indicates whether this is a development build (true) or an official release (false).
   * +optional
   */
  dev?: boolean
}
/**
 * Information about how the Tilt binary handles updates.
 */
export interface VersionSettings {
  /**
   * Whether version updates have been enabled/disabled from the Tiltfile.
   * +optional
   */
  checkUpdates?: boolean
}

//////////
// source: updatestatus_types.go

/**
 * The UpdateStatus is a simple, high-level summary of any update tasks to bring
 * the resource up-to-date.
 */
export type UpdateStatus = string
/**
 * This resource hasn't had any reason to update yet.
 * This usually indicates that it's a manual trigger with no auto_init.
 */
export const UpdateStatusNone: UpdateStatus = "none"
/**
 * An update is in progress.
 */
export const UpdateStatusInProgress: UpdateStatus = "in_progress"
/**
 * The last update succeeded.
 */
export const UpdateStatusOK: UpdateStatus = "ok"
/**
 * An update is queued.
 */
export const UpdateStatusPending: UpdateStatus = "pending"
/**
 * The last update failed.
 */
export const UpdateStatusError: UpdateStatus = "error"
/**
 * This resource doesn't have an update command.
 */
export const UpdateStatusNotApplicable: UpdateStatus = "not_applicable"

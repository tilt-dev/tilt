// Code generated by tygo. DO NOT EDIT.

//////////
// source: log.go

/**
 * LogLevel represents the severity level of a log entry.
 */
export type LogLevel = string
export const LogLevel_NONE: LogLevel = "NONE"
export const LogLevel_INFO: LogLevel = "INFO"
export const LogLevel_VERBOSE: LogLevel = "VERBOSE"
export const LogLevel_DEBUG: LogLevel = "DEBUG"
export const LogLevel_WARN: LogLevel = "WARN"
export const LogLevel_ERROR: LogLevel = "ERROR"
export interface LogSegment {
  spanId?: string
  time?: string
  text?: string
  level?: LogLevel
  /**
   * When we store warnings in the LogStore, we break them up into lines and
   * store them as a series of line segments. 'anchor' marks the beginning of a
   * series of logs that should be kept together.
   * Anchor warning1, line1
   *        warning1, line2
   * Anchor warning2, line1
   */
  anchor?: boolean
  /**
   * Context-specific optional fields for a log segment.
   * Used for experimenting with new types of log metadata.
   */
  fields?: { [key: string]: string }
}
export interface LogSpan {
  manifestName?: string
}
export interface LogList {
  spans?: { [key: string]: LogSpan | undefined }
  segments?: (LogSegment | undefined)[]
  /**
   * FromCheckpoint and ToCheckpoint express an interval on the
   * central log-store, with an inclusive start and an exclusive end
   * [FromCheckpoint, ToCheckpoint)
   * An interval of [0, 0) means that the server isn't using
   * the incremental load protocol.
   * An interval of [-1, -1) means that the server doesn't have new logs
   * to send down.
   */
  fromCheckpoint?: number /* int32 */
  toCheckpoint?: number /* int32 */
}

//////////
// source: view.go

/**
 * TargetType corresponds to implementations of the TargetSpec interface.
 */
export type TargetType = string
export const TargetType_TARGET_TYPE_UNSPECIFIED: TargetType = "unspecified"
export const TargetType_TARGET_TYPE_IMAGE: TargetType = "image"
export const TargetType_TARGET_TYPE_K8S: TargetType = "k8s"
export const TargetType_TARGET_TYPE_DOCKER_COMPOSE: TargetType =
  "docker-compose"
export const TargetType_TARGET_TYPE_LOCAL: TargetType = "local"
export interface TargetSpec {
  id?: string
  type?: TargetType
  hasLiveUpdate?: boolean
}
export interface BuildRecord {
  error?: string
  warnings?: string[]
  startTime?: string
  finishTime?: string
  isCrashRebuild?: boolean
  /**
   * The span id for this build record's logs in the main logstore.
   */
  spanId?: string
}
export interface K8SResourceInfo {
  podName?: string
  podCreationTime?: string
  podUpdateStartTime?: string
  podStatus?: string
  podStatusMessage?: string
  allContainersReady?: boolean
  podRestarts?: number /* int32 */
  /**
   * The span id for this pod's logs in the main logstore.
   */
  spanId?: string
  displayNames?: string[]
}
export interface LocalResourceInfo {
  pid?: number /* int64 */
  isTest?: boolean
}
export interface Link {
  url?: string
  name?: string
}
export interface Resource {
  name?: string
  lastDeployTime?: string
  triggerMode?: number /* int32 */
  buildHistory?: (BuildRecord | undefined)[]
  currentBuild?: BuildRecord
  pendingBuildSince?: string
  hasPendingChanges?: boolean
  endpointLinks?: (Link | undefined)[]
  podID?: string
  k8sResourceInfo?: K8SResourceInfo
  localResourceInfo?: LocalResourceInfo
  runtimeStatus?: string
  updateStatus?: string
  isTiltfile?: boolean
  specs?: (TargetSpec | undefined)[]
  queued?: boolean
}
export interface TiltBuild {
  version?: string
  commitSHA?: string
  date?: string
  dev?: boolean
}
export interface VersionSettings {
  checkUpdates?: boolean
}
/**
 * Our websocket service has two kinds of View messages:
 *  1. On initialization, we send down the complete view state
 *     (TiltStartTime, UISession, UIResources, and LogList)
 *  2. On every change, we send down the resources that have
 *     changed since the last send().
 *     (new logs and any updated UISession/UIResource objects).
 * All other fields are obsolete, but are needed for deserializing
 * old snapshots.
 */
export interface View {
  log?: string
  resources?: (Resource | undefined)[]
  featureFlags?: { [key: string]: boolean }
  needsAnalyticsNudge?: boolean
  runningTiltBuild?: TiltBuild
  suggestedTiltVersion?: string
  versionSettings?: VersionSettings
  tiltCloudUsername?: string
  tiltCloudTeamName?: string
  tiltCloudSchemeHost?: string
  tiltCloudTeamID?: string
  fatalError?: string
  logList?: LogList
  /**
   * Allows us to synchronize on a running Tilt instance,
   * so we can tell when Tilt restarted.
   */
  tiltStartTime?: string
  /**
   * An identifier for the tiltfile that is running, so that the web ui
   * can store data per tiltfile.
   */
  tiltfileKey?: string
  /**
   * New API-server based data models.
   */
  uiSession?: any /* v1alpha1.UISession */
  uiResources?: (any /* v1alpha1.UIResource */ | undefined)[]
  uiButtons?: (any /* v1alpha1.UIButton */ | undefined)[]
  clusters?: (any /* v1alpha1.Cluster */ | undefined)[]
  /**
   * Indicates that this view is a complete representation of the app.
   * If false, this view just contains deltas from a previous view.
   */
  isComplete?: boolean
}
export interface SnapshotHighlight {
  beginningLogID?: string
  endingLogID?: string
  text?: string
}
export interface Snapshot {
  view?: View
  isSidebarClosed?: boolean
  path?: string
  snapshotHighlight?: SnapshotHighlight
  snapshotLink?: string
  createdAt?: string
}
export interface UploadSnapshotResponse {
  url?: string
}
/**
 * NOTE(nick): This is obsolete.
 * Our websocket service has two kinds of messages:
 *  1. On initialization, we send down the complete view state
 *  2. On every change, we send down the resources that have
 *     changed since the last send().
 */
export interface AckWebsocketRequest {
  /**
   * The ToCheckpoint on the received LogList.
   */
  toCheckpoint?: number /* int32 */
  /**
   * Allows us to synchronize on a running Tilt instance,
   * so we can tell when we're talking to the same Tilt.
   */
  tiltStartTime?: string
}
export interface AckWebsocketResponse {}

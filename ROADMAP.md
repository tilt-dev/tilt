# Roadmap

✨ Welcome to the future! ✨

This page is for features that the Tilt team has plans to implement.

(These features are less "Wouldn't that be cool?" or "Bugs we should fix", and more "Yes! We should
implement this thing! And we've knocked around a few implementation ideas.")

Ideas are categorized by
- how much value we think they would add (P1 highest value, P3 lowest value)
- how much work they would take to implement (C1 highest cost/effort, C3 lowest cost/effort)

## Docker-Compose Support (P1, C1-2) (In progress)

`docker-compose.yml` is, by far, the most popular format for describing
sets of microservices for running locally. Kubernetes YAML is nice, but much more verbose.
Tilt should support docker-compose.yml for configuring services.

We currently have [alpha support for Docker-Compose](https://docs.tilt.dev/docker_compose_alpha.html) in recent releases. Give it a spin and [let us know](https://github.com/windmilleng/tilt#community) what you think!

Open questions:
- docker-compose support would make it easier to try Tilt with
your existing docker-compose.yml. What percentage of users would first try Tilt
this way?
- Would users stay with their docker-compose file,
or eventually convert to Kubernetes YAML?

## Tilt Init (P1, C2)

Many container tools auto-detect your server, and can auto-generate Dockerfiles and Kubernetes configs.
For example, [draft create](https://github.com/Azure/draft/blob/master/docs/reference/dep-003.md) automatically
generates Draft configs for the detected language. How could Tilt automatically detect your language
and auto-generate a Tiltfile for you?

Open questions:
- How often would people change the file generated by `tilt init`?
Would they generate it once and never look at it?
Or would they use it as a tool to figure out how to write Tiltfiles?

## Web UX (P1, C1)

The Terminal UX works well for debugging API services where there is no visual
component.

For debugging HTML services, Tilt should have an in-browser UX, so that users
can see their HTML and the Tilt status pane in the same tab.

Open questions:
- How popular would a web UX be relative to the terminal UX?

## Manual Build Triggers (P2, C3)

Tilt watches for file changes, and auto-updates your service whenever something
changes. This works well for fast-building services. For slow services, the user
wants to be more conservative about when builds start.

Tilt should have a mode where it labels services as dirty in the UX when
files have changed, but does not start building/updating
them until the user presses a key.

Given that Tilt already makes build decisions based on reactive state engine, this is
not difficult to implement.

Open questions:
- What percentage of users would use this mode?
- What distinguishes auto-update users from manual-update users? Is it just a style preference?

## VSCode Integration (P2, C2)

The Terminal UX means you need a separate window open, independently of your
editor. VSCode is the first in-editor experience we're interested in implementing,
to see how much value that adds. If it's a big win, we'd consider other editors
(e.g., IntelliJ-based editors).

A low-cost way to implement VSCode integration would be to write an HTML-based
web pane, and serve that.

## Auto-Fast Build (P2, C2)

Tilt can make builds much faster by reusing containers and artifacts from previous builds.

The syntax is different than the normal Dockerfile syntax, but you can easily convert a
Dockerfile to a fast Tilt build! The process is fairly mechanical. Could we automate it?

Open questions:
- Will users want to see and tweak the auto-generated fast build?
- When do you most see the value? Maybe users would use Auto-Fast Build to learn how to write Tiltfiles
  better, but would want to write the Tiltfiles directly after that. Maybe they would use Auto-Fast Build
  all the time, and never use the Tiltfile fast_build API.


## Domain-Specific Error Monitoring (P2, C1)

Tilt surfaces build errors, crashes, and deploy logs in one pane,
so you can get a complete view of your server status. How could Tilt include application-specific
error states, like HTTP 500 status codes, or severe logs?

There's a lot of prior art in this space, including both log-based aggregators (see
[honeytail](https://github.com/honeycombio/honeytail)) and network-based aggregators
(see [linkerd2](https://github.com/linkerd/linkerd2)).

Open questions:
- Are there common standards for this kind of error surfacing in development? How can we contribute
to more common standards?
- At what point will users need a more full-featured error-navigation tool for local development,
like a Kibana dashboard?

## Service / Deployment Monitoring (P2, C1)

We really like the [Kubespy
Trace](https://blog.pulumi.com/kubespy-trace-a-real-time-view-into-the-heart-of-a-kubernetes-service)
UI for diagnosing problems with Kubernetes services. Kubespy runs through a
checklist of common mistakes that people make when writing services. How could
Tilt make this an automatic part of your workflow when editing configs?

Open questions:
- Do people use Tilt for feedback while editing K8s configs? How important is this use-case
relative to editing your server's code?
- Could we re-use code from Kubespy? How could we contribute towards a reusable "Kubernetes doctor"
library across many tools?

## Windows Support (P3, C3)

Tilt has OS-specific dependencies on a terminal library (`tcell`) and a
filesystem-watching library (`fsnotify`). In theory, these libraries support all
major operating systems. In practice, we've spent a significant amount of time
dealing with OS-specific bugs.

Currently Tilt doesn't even compile on Windows. We need to fix the compilation
problems. We should also run unit tests on Windows in CI.

Open questions:
- How many Windows users are interested in using Tilt?

## Unit Tests (P2, C3)

Tilt already has the ability to run Kubernetes jobs. How hard would it be to provide a wrapper around jobs for running unit and integration tests? Like regular services they could be built on run when the code included in the image that runs the unit test(s) changes.

You can see a proof-of-concept implementation of this in [Tilt's Tiltfile](https://github.com/windmilleng/tilt/blob/master/Tiltfile).

Open questions:
- Could we parse output in some way to display a better view of which tests failed?
- Could we make it easy to break down one monolithic test run in to many parallel test runs?

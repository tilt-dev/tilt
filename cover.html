
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/windmilleng/tilt/internal/build/boil_steps.go (87.5%)</option>
				
				<option value="file1">github.com/windmilleng/tilt/internal/build/buildkit_printer.go (91.1%)</option>
				
				<option value="file2">github.com/windmilleng/tilt/internal/build/container_resolver.go (56.8%)</option>
				
				<option value="file3">github.com/windmilleng/tilt/internal/build/container_updater.go (68.9%)</option>
				
				<option value="file4">github.com/windmilleng/tilt/internal/build/dockerfile.go (96.3%)</option>
				
				<option value="file5">github.com/windmilleng/tilt/internal/build/error.go (0.0%)</option>
				
				<option value="file6">github.com/windmilleng/tilt/internal/build/image_builder.go (82.7%)</option>
				
				<option value="file7">github.com/windmilleng/tilt/internal/build/image_reaper.go (76.9%)</option>
				
				<option value="file8">github.com/windmilleng/tilt/internal/build/options.go (75.0%)</option>
				
				<option value="file9">github.com/windmilleng/tilt/internal/build/path_mapping.go (81.0%)</option>
				
				<option value="file10">github.com/windmilleng/tilt/internal/build/pipeline_state.go (95.0%)</option>
				
				<option value="file11">github.com/windmilleng/tilt/internal/build/tar.go (81.2%)</option>
				
				<option value="file12">github.com/windmilleng/tilt/internal/build/test_utils.go (83.5%)</option>
				
				<option value="file13">github.com/windmilleng/tilt/internal/dockerignore/ignore.go (70.6%)</option>
				
				<option value="file14">github.com/windmilleng/tilt/internal/engine/actions.go (100.0%)</option>
				
				<option value="file15">github.com/windmilleng/tilt/internal/engine/build_and_deployer.go (84.6%)</option>
				
				<option value="file16">github.com/windmilleng/tilt/internal/engine/buildcontroller.go (93.7%)</option>
				
				<option value="file17">github.com/windmilleng/tilt/internal/engine/deploy.go (90.3%)</option>
				
				<option value="file18">github.com/windmilleng/tilt/internal/engine/image_build_and_deployer.go (77.5%)</option>
				
				<option value="file19">github.com/windmilleng/tilt/internal/engine/local_container_build_and_deployer.go (83.3%)</option>
				
				<option value="file20">github.com/windmilleng/tilt/internal/engine/mode.go (80.0%)</option>
				
				<option value="file21">github.com/windmilleng/tilt/internal/engine/parse.go (0.0%)</option>
				
				<option value="file22">github.com/windmilleng/tilt/internal/engine/pod.go (100.0%)</option>
				
				<option value="file23">github.com/windmilleng/tilt/internal/engine/pod_watch.go (40.5%)</option>
				
				<option value="file24">github.com/windmilleng/tilt/internal/engine/podlogmanager.go (94.9%)</option>
				
				<option value="file25">github.com/windmilleng/tilt/internal/engine/portforwardcontroller.go (94.2%)</option>
				
				<option value="file26">github.com/windmilleng/tilt/internal/engine/service_watch.go (45.5%)</option>
				
				<option value="file27">github.com/windmilleng/tilt/internal/engine/synclet_build_and_deployer.go (77.6%)</option>
				
				<option value="file28">github.com/windmilleng/tilt/internal/engine/synclet_manager.go (42.0%)</option>
				
				<option value="file29">github.com/windmilleng/tilt/internal/engine/upper.go (83.9%)</option>
				
				<option value="file30">github.com/windmilleng/tilt/internal/engine/watchmanager.go (74.7%)</option>
				
				<option value="file31">github.com/windmilleng/tilt/internal/engine/wire_gen.go (94.7%)</option>
				
				<option value="file32">github.com/windmilleng/tilt/internal/git/gitignore.go (84.2%)</option>
				
				<option value="file33">github.com/windmilleng/tilt/internal/hud/actions.go (0.0%)</option>
				
				<option value="file34">github.com/windmilleng/tilt/internal/hud/fake_hud.go (0.0%)</option>
				
				<option value="file35">github.com/windmilleng/tilt/internal/hud/hud.go (0.0%)</option>
				
				<option value="file36">github.com/windmilleng/tilt/internal/hud/renderer.go (41.2%)</option>
				
				<option value="file37">github.com/windmilleng/tilt/internal/hud/server.go (0.0%)</option>
				
				<option value="file38">github.com/windmilleng/tilt/internal/k8s/client.go (4.3%)</option>
				
				<option value="file39">github.com/windmilleng/tilt/internal/k8s/container.go (73.0%)</option>
				
				<option value="file40">github.com/windmilleng/tilt/internal/k8s/entity.go (85.0%)</option>
				
				<option value="file41">github.com/windmilleng/tilt/internal/k8s/env.go (41.2%)</option>
				
				<option value="file42">github.com/windmilleng/tilt/internal/k8s/extract.go (83.3%)</option>
				
				<option value="file43">github.com/windmilleng/tilt/internal/k8s/fake_client.go (0.0%)</option>
				
				<option value="file44">github.com/windmilleng/tilt/internal/k8s/image.go (63.0%)</option>
				
				<option value="file45">github.com/windmilleng/tilt/internal/k8s/kubectl_runner.go (0.0%)</option>
				
				<option value="file46">github.com/windmilleng/tilt/internal/k8s/label.go (93.3%)</option>
				
				<option value="file47">github.com/windmilleng/tilt/internal/k8s/pod.go (90.7%)</option>
				
				<option value="file48">github.com/windmilleng/tilt/internal/k8s/portforward.go (0.0%)</option>
				
				<option value="file49">github.com/windmilleng/tilt/internal/k8s/serialize.go (84.6%)</option>
				
				<option value="file50">github.com/windmilleng/tilt/internal/k8s/watch.go (60.9%)</option>
				
				<option value="file51">github.com/windmilleng/tilt/internal/kustomize/dependencies.go (94.9%)</option>
				
				<option value="file52">github.com/windmilleng/tilt/internal/logger/func_logger.go (33.3%)</option>
				
				<option value="file53">github.com/windmilleng/tilt/internal/logger/logger.go (52.1%)</option>
				
				<option value="file54">github.com/windmilleng/tilt/internal/logger/prefixed_writer.go (94.7%)</option>
				
				<option value="file55">github.com/windmilleng/tilt/internal/minikube/docker.go (50.0%)</option>
				
				<option value="file56">github.com/windmilleng/tilt/internal/model/manifest.go (64.9%)</option>
				
				<option value="file57">github.com/windmilleng/tilt/internal/model/matcher.go (0.0%)</option>
				
				<option value="file58">github.com/windmilleng/tilt/internal/model/squash.go (100.0%)</option>
				
				<option value="file59">github.com/windmilleng/tilt/internal/ospath/ospath.go (35.7%)</option>
				
				<option value="file60">github.com/windmilleng/tilt/internal/rty/ansi.go (54.0%)</option>
				
				<option value="file61">github.com/windmilleng/tilt/internal/rty/canvas.go (60.3%)</option>
				
				<option value="file62">github.com/windmilleng/tilt/internal/rty/layouts.go (75.6%)</option>
				
				<option value="file63">github.com/windmilleng/tilt/internal/rty/render.go (26.5%)</option>
				
				<option value="file64">github.com/windmilleng/tilt/internal/rty/scroll.go (0.0%)</option>
				
				<option value="file65">github.com/windmilleng/tilt/internal/rty/text.go (94.0%)</option>
				
				<option value="file66">github.com/windmilleng/tilt/internal/store/build_result.go (0.0%)</option>
				
				<option value="file67">github.com/windmilleng/tilt/internal/store/engine_state.go (64.3%)</option>
				
				<option value="file68">github.com/windmilleng/tilt/internal/store/store.go (11.5%)</option>
				
				<option value="file69">github.com/windmilleng/tilt/internal/store/subscriber.go (100.0%)</option>
				
				<option value="file70">github.com/windmilleng/tilt/internal/synclet/sidecar/inject.go (82.4%)</option>
				
				<option value="file71">github.com/windmilleng/tilt/internal/synclet/sidecar/sidecar.go (100.0%)</option>
				
				<option value="file72">github.com/windmilleng/tilt/internal/tiltfile/skylarkTypes.go (65.0%)</option>
				
				<option value="file73">github.com/windmilleng/tilt/internal/tiltfile/thread_local.go (84.6%)</option>
				
				<option value="file74">github.com/windmilleng/tilt/internal/tiltfile/tiltfile.go (85.3%)</option>
				
				<option value="file75">github.com/windmilleng/tilt/internal/tracer/tracer.go (34.5%)</option>
				
				<option value="file76">github.com/windmilleng/tilt/internal/watch/features.go (14.3%)</option>
				
				<option value="file77">github.com/windmilleng/tilt/internal/watch/ospath.go (75.0%)</option>
				
				<option value="file78">github.com/windmilleng/tilt/internal/watch/temp.go (44.0%)</option>
				
				<option value="file79">github.com/windmilleng/tilt/internal/watch/watcher_darwin.go (97.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package build

import (
        "github.com/windmilleng/tilt/internal/ignore"
        "github.com/windmilleng/tilt/internal/model"
)

func BoilSteps(steps []model.Step, pathMappings []pathMapping) ([]model.Cmd, error) <span class="cov8" title="1">{
        res := []model.Cmd{}
        for _, step := range steps </span><span class="cov8" title="1">{
                if step.Triggers == nil </span><span class="cov8" title="1">{
                        res = append(res, step.Cmd)
                        continue</span>
                }
                <span class="cov8" title="1">matcher, err := ignore.CreateStepMatcher(step)
                if err != nil </span><span class="cov0" title="0">{
                        return []model.Cmd{}, err
                }</span>
                <span class="cov8" title="1">for _, pm := range pathMappings </span><span class="cov8" title="1">{
                        matches, err := matcher.Matches(pm.LocalPath, false)
                        if err != nil </span><span class="cov0" title="0">{
                                return []model.Cmd{}, err
                        }</span>
                        <span class="cov8" title="1">if matches </span><span class="cov8" title="1">{
                                res = append(res, step.Cmd)
                                break</span>
                        }
                }
        }
        <span class="cov8" title="1">return res, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package build

import (
        "fmt"
        "io"
        "strings"

        digest "github.com/opencontainers/go-digest"
        "github.com/windmilleng/tilt/internal/logger"
)

type buildkitPrinter struct {
        logger logger.Logger
        vData  map[digest.Digest]*vertexAndLogs
        vOrder []digest.Digest
}

type vertex struct {
        digest     digest.Digest
        name       string
        error      string
        started    bool
        completed  bool
        cmdPrinted bool
}

// HACK: The prefix we assume here isn't valid for RUNS in exec format
// Ex: RUN ["echo", "hello world"]
const cmdPrefix = "/bin/sh -c "
const buildPrefix = "    ╎ "

func (v *vertex) isRun() bool <span class="cov8" title="1">{
        return strings.HasPrefix(v.name, cmdPrefix)
}</span>

func (v *vertex) isError() bool <span class="cov8" title="1">{
        return len(v.error) &gt; 0
}</span>

type vertexAndLogs struct {
        vertex      *vertex
        logs        []*vertexLog
        logsPrinted int
}

type vertexLog struct {
        vertex digest.Digest
        msg    []byte
}

func newBuildkitPrinter(logger logger.Logger) *buildkitPrinter <span class="cov8" title="1">{
        return &amp;buildkitPrinter{
                logger: logger,
                vData:  map[digest.Digest]*vertexAndLogs{},
                vOrder: []digest.Digest{},
        }
}</span>

func (b *buildkitPrinter) parseAndPrint(vertexes []*vertex, logs []*vertexLog) error <span class="cov8" title="1">{
        for _, v := range vertexes </span><span class="cov8" title="1">{
                if vl, ok := b.vData[v.digest]; ok </span><span class="cov8" title="1">{
                        vl.vertex.started = v.started
                        vl.vertex.completed = v.completed

                        if v.isError() </span><span class="cov8" title="1">{
                                vl.vertex.error = v.error
                        }</span>
                } else<span class="cov8" title="1"> {
                        b.vData[v.digest] = &amp;vertexAndLogs{
                                vertex: v,
                                logs:   []*vertexLog{},
                        }

                        b.vOrder = append(b.vOrder, v.digest)
                }</span>
        }

        <span class="cov8" title="1">for _, l := range logs </span><span class="cov8" title="1">{
                if vl, ok := b.vData[l.vertex]; ok </span><span class="cov8" title="1">{
                        vl.logs = append(vl.logs, l)
                }</span>
        }

        // If the log level is at least verbose, we want to stream the output as
        // it comes in. Otherwise, we only want to dump it at the end of there's
        // an error.
        <span class="cov8" title="1">streamLogs := b.logger.Level() &gt;= logger.VerboseLvl
        for _, d := range b.vOrder </span><span class="cov8" title="1">{
                vl, ok := b.vData[d]
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("Expected to find digest %s in %+v", d, b.vData)
                }</span>
                <span class="cov8" title="1">if vl.vertex.isRun() &amp;&amp; vl.vertex.started &amp;&amp; !vl.vertex.cmdPrinted </span><span class="cov8" title="1">{
                        b.logger.Infof("%sRUNNING: %s", buildPrefix, trimCmd(vl.vertex.name))
                        vl.vertex.cmdPrinted = true
                }</span>

                <span class="cov8" title="1">if vl.vertex.isError() </span><span class="cov8" title="1">{
                        b.logger.Infof("\n%sERROR IN: %s", buildPrefix, trimCmd(vl.vertex.name))
                        if !streamLogs </span><span class="cov8" title="1">{
                                err := b.flushLogs(b.logger.Writer(logger.InfoLvl), vl)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }

                <span class="cov8" title="1">if streamLogs &amp;&amp; vl.vertex.isRun() </span><span class="cov8" title="1">{
                        err := b.flushLogs(b.logger.Writer(logger.VerboseLvl), vl)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

func (b *buildkitPrinter) flushLogs(writer io.Writer, vl *vertexAndLogs) error <span class="cov8" title="1">{
        for vl.logsPrinted &lt; len(vl.logs) </span><span class="cov8" title="1">{
                l := vl.logs[vl.logsPrinted]
                vl.logsPrinted++

                sl := strings.TrimSpace(string(l.msg))
                if len(sl) == 0 </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">msg := fmt.Sprintf("%s  → %s\n", buildPrefix, sl)
                _, err := writer.Write([]byte(msg))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func trimCmd(cmd string) string <span class="cov8" title="1">{
        return strings.TrimPrefix(cmd, cmdPrefix)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package build

import (
        "context"
        "fmt"
        "time"

        "github.com/docker/distribution/reference"
        "github.com/docker/docker/api/types"
        "github.com/docker/docker/api/types/filters"
        "github.com/opencontainers/go-digest"
        opentracing "github.com/opentracing/opentracing-go"
        "github.com/windmilleng/tilt/internal/docker"
        "github.com/windmilleng/tilt/internal/k8s"
        "github.com/windmilleng/tilt/internal/logger"
)

const containerUpTimeout = 10 * time.Second

type ContainerResolver struct {
        dcli docker.DockerClient
}

func NewContainerResolver(dcli docker.DockerClient) *ContainerResolver <span class="cov0" title="0">{
        return &amp;ContainerResolver{dcli: dcli}
}</span>

// containerIdForPod looks for the container ID associated with the pod and image ID
func (r *ContainerResolver) ContainerIDForPod(ctx context.Context, podName k8s.PodID, image reference.NamedTagged) (k8s.ContainerID, error) <span class="cov8" title="1">{
        span, ctx := opentracing.StartSpanFromContext(ctx, "ContainerResolver-containerIdForPod")
        defer span.Finish()

        // Right now, we poll the pod until the container comes up. We give up after a timeout.
        // In the future, we might want to be more clever about asking k8s if the container
        // is in the process of coming up, or if we're waiting in vain.
        ctx, cancel := context.WithTimeout(ctx, containerUpTimeout)
        defer cancel()

        var lastErr error
        for ctx.Err() == nil </span><span class="cov8" title="1">{
                id, err := r.containerIDForPodHelper(ctx, podName, image)
                if err == nil </span><span class="cov8" title="1">{
                        return id, nil
                }</span>

                <span class="cov0" title="0">_, isContainerNotFound := err.(containerNotFound)
                if !isContainerNotFound </span><span class="cov0" title="0">{
                        return "", err
                }</span>

                <span class="cov0" title="0">lastErr = err
                time.Sleep(containerUpTimeout / 10)</span>
        }

        <span class="cov0" title="0">if lastErr != nil </span><span class="cov0" title="0">{
                return "", lastErr
        }</span>
        <span class="cov0" title="0">return "", ctx.Err()</span>
}

func (r *ContainerResolver) containerIDForPodHelper(ctx context.Context, podName k8s.PodID, image reference.NamedTagged) (k8s.ContainerID, error) <span class="cov8" title="1">{

        a := filters.NewArgs()
        a.Add("name", string(podName))
        listOpts := types.ContainerListOptions{Filters: a}

        containers, err := r.dcli.ContainerList(ctx, listOpts)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("getting containers: %v", err)
        }</span>

        <span class="cov8" title="1">if len(containers) == 0 </span><span class="cov0" title="0">{
                return "", containerNotFound{
                        Message: fmt.Sprintf("no matching containers found in pod: %s", podName),
                }
        }</span>

        <span class="cov8" title="1">for _, c := range containers </span><span class="cov8" title="1">{
                if c.ID == k8s.MagicTestContainerID </span><span class="cov0" title="0">{
                        return k8s.ContainerID(c.ID), nil
                }</span>

                <span class="cov8" title="1">dig, err := digest.Parse(c.ImageID)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Get(ctx).Debugf("Skipping malformed digest %q: %v", c.ImageID, err)
                        continue</span>
                }
                <span class="cov8" title="1">if digestMatchesRef(image, dig) </span><span class="cov8" title="1">{
                        return k8s.ContainerID(c.ID), nil
                }</span>
        }

        // TODO(nick): We should have a way to wait if the container
        // simply hasn't materialized yet.
        <span class="cov0" title="0">return "", containerNotFound{
                Message: fmt.Sprintf("no containers matching: %s", image),
        }</span>
}

type containerNotFound struct {
        Message string
}

func (e containerNotFound) Error() string <span class="cov0" title="0">{
        return e.Message
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package build

import (
        "bytes"
        "context"
        "fmt"
        "io"

        "github.com/opentracing/opentracing-go"
        "github.com/windmilleng/tilt/internal/docker"
        "github.com/windmilleng/tilt/internal/k8s"
        "github.com/windmilleng/tilt/internal/logger"
        "github.com/windmilleng/tilt/internal/model"
)

type ContainerUpdater struct {
        dcli docker.DockerClient
}

func NewContainerUpdater(dcli docker.DockerClient) *ContainerUpdater <span class="cov0" title="0">{
        return &amp;ContainerUpdater{dcli: dcli}
}</span>

func (r *ContainerUpdater) UpdateInContainer(ctx context.Context, cID k8s.ContainerID, paths []pathMapping, filter model.PathMatcher, steps []model.Cmd, w io.Writer) error <span class="cov8" title="1">{
        span, ctx := opentracing.StartSpanFromContext(ctx, "daemon-UpdateInContainer")
        defer span.Finish()

        // rm files from container
        toRemove, err := MissingLocalPaths(ctx, paths)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("MissingLocalPaths: %v", err)
        }</span>

        <span class="cov8" title="1">err = r.RmPathsFromContainer(ctx, cID, toRemove)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("RmPathsFromContainer: %v", err)
        }</span>

        // copy files to container
        <span class="cov8" title="1">ab := NewArchiveBuilder(filter)
        err = ab.ArchivePathsIfExist(ctx, paths)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("archivePathsIfExists: %v", err)
        }</span>
        <span class="cov8" title="1">archive, err := ab.BytesBuffer()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">logger.Get(ctx).Debugf("Copying files to container: %s", cID.ShortStr())

        // TODO(maia): catch errors -- CopyToContainer doesn't return errors if e.g. it
        // fails to write a file b/c of permissions =(
        err = r.dcli.CopyToContainerRoot(ctx, cID.String(), bytes.NewReader(archive.Bytes()))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Exec steps on container
        <span class="cov8" title="1">for _, s := range steps </span><span class="cov8" title="1">{
                err = r.dcli.ExecInContainer(ctx, cID, s, w)
                if err != nil </span><span class="cov0" title="0">{
                        exitErr, isExitErr := err.(docker.ExitError)
                        if isExitErr </span><span class="cov0" title="0">{
                                return UserBuildFailure{ExitCode: exitErr.ExitCode}
                        }</span>
                        <span class="cov0" title="0">return fmt.Errorf("executing step %v on container %s: %v", s.Argv, cID.ShortStr(), err)</span>
                }
        }

        // Restart container so that entrypoint restarts with the updated files etc.
        <span class="cov8" title="1">err = r.dcli.ContainerRestartNoWait(ctx, cID.String())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ContainerRestart: %v", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (r *ContainerUpdater) RmPathsFromContainer(ctx context.Context, cID k8s.ContainerID, paths []pathMapping) error <span class="cov8" title="1">{
        if len(paths) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">logger.Get(ctx).Debugf("Deleting %d files from container: %s", len(paths), cID.ShortStr())

        out := bytes.NewBuffer(nil)
        err := r.dcli.ExecInContainer(ctx, cID, model.Cmd{Argv: makeRmCmd(paths)}, out)
        if err != nil </span><span class="cov0" title="0">{
                if docker.IsExitError(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("Error deleting files from container: %s", out.String())
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("Error deleting files from container: %v", err)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func makeRmCmd(paths []pathMapping) []string <span class="cov8" title="1">{
        cmd := []string{"rm", "-rf"}
        for _, p := range paths </span><span class="cov8" title="1">{
                cmd = append(cmd, p.ContainerPath)
        }</span>
        <span class="cov8" title="1">return cmd</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package build

import (
        "bytes"
        "errors"
        "fmt"
        "strings"

        "github.com/docker/distribution/reference"
        "github.com/moby/buildkit/frontend/dockerfile/parser"
        "github.com/windmilleng/tilt/internal/model"
)

var ErrAddInDockerfile = errors.New("base Dockerfile contains an ADD/COPY, " +
        "which is not currently supported -- move this to an add() call in your Tiltfile")

type Dockerfile string

// DockerfileFromExisting creates a new Dockerfile that uses the supplied image
// as its base image with a FROM statement. This is necessary for iterative
// Docker builds.
func DockerfileFromExisting(existing reference.NamedTagged) Dockerfile <span class="cov8" title="1">{
        return Dockerfile(fmt.Sprintf("FROM %s", existing.String()))
}</span>

func (d Dockerfile) join(s string) Dockerfile <span class="cov8" title="1">{
        return Dockerfile(fmt.Sprintf("%s\n%s", d, s))
}</span>

func (d Dockerfile) WithLabel(label Label, val LabelValue) Dockerfile <span class="cov8" title="1">{
        return d.join(fmt.Sprintf("LABEL %q=%q", label, val))
}</span>

func (d Dockerfile) AddAll() Dockerfile <span class="cov8" title="1">{
        return d.join("ADD . /")
}</span>

func (d Dockerfile) Run(cmd model.Cmd) Dockerfile <span class="cov8" title="1">{
        return d.join(cmd.RunStr())
}</span>

func (d Dockerfile) Entrypoint(cmd model.Cmd) Dockerfile <span class="cov8" title="1">{
        return d.join(cmd.EntrypointStr())
}</span>

func (d Dockerfile) RmPaths(pathsToRm []pathMapping) Dockerfile <span class="cov8" title="1">{
        if len(pathsToRm) == 0 </span><span class="cov8" title="1">{
                return d
        }</span>

        // Add 'rm' statements; if changed path was deleted locally, remove if from container
        <span class="cov8" title="1">rmCmd := strings.Builder{}
        rmCmd.WriteString("rm -rf")
        for _, p := range pathsToRm </span><span class="cov8" title="1">{
                rmCmd.WriteString(fmt.Sprintf(" %s", p.ContainerPath))
        }</span>
        <span class="cov8" title="1">return d.join(fmt.Sprintf("RUN %s", rmCmd.String()))</span>
}

func (d Dockerfile) ValidateBaseDockerfile() error <span class="cov8" title="1">{
        result, err := parser.Parse(bytes.NewBufferString(string(d)))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ValidateBaseDockerfile: %v", err)
        }</span>

        <span class="cov8" title="1">err = traverse(result.AST, func(node *parser.Node) error </span><span class="cov8" title="1">{
                switch strings.ToUpper(node.Value) </span>{
                case "ADD", "COPY":<span class="cov8" title="1">
                        return ErrAddInDockerfile</span>
                }
                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">return err</span>
}

func (d Dockerfile) String() string <span class="cov8" title="1">{
        return string(d)
}</span>

// Post-order traversal of the Dockerfile AST.
// Halts immediately on error.
func traverse(node *parser.Node, visit func(*parser.Node) error) error <span class="cov8" title="1">{
        for _, c := range node.Children </span><span class="cov8" title="1">{
                err := traverse(c, visit)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return visit(node)</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package build

import "fmt"

// Indicates that the build failed because the user script failed
// (as opposed to an infrastructure issue).
type UserBuildFailure struct {
        ExitCode int
}

func (e UserBuildFailure) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Command failed with exit code: %d", e.ExitCode)
}</span>

func IsUserBuildFailure(err error) bool <span class="cov0" title="0">{
        _, ok := err.(UserBuildFailure)
        return ok
}</span>

var _ error = UserBuildFailure{}
</pre>
		
		<pre class="file" id="file6" style="display: none">package build

import (
        "context"
        "encoding/json"
        "fmt"
        "io"
        "os"
        "strings"

        "github.com/dustin/go-humanize"

        "github.com/windmilleng/tilt/internal/docker"
        "github.com/windmilleng/tilt/internal/ignore"
        "github.com/windmilleng/tilt/internal/logger"
        "github.com/windmilleng/tilt/internal/model"

        "github.com/containerd/console"
        "github.com/docker/cli/cli/command"
        cliflags "github.com/docker/cli/cli/flags"
        "github.com/docker/distribution/reference"
        "github.com/docker/docker/api/types"
        "github.com/docker/docker/pkg/jsonmessage"
        "github.com/docker/docker/registry"
        controlapi "github.com/moby/buildkit/api/services/control"
        "github.com/opencontainers/go-digest"
        opentracing "github.com/opentracing/opentracing-go"
        "github.com/pkg/errors"
)

type dockerImageBuilder struct {
        dcli    docker.DockerClient
        console console.Console
        out     io.Writer

        // A set of extra labels to attach to all builds
        // created by this image builder.
        //
        // By default, all builds are labeled with a build mode.
        extraLabels Labels
}

type ImageBuilder interface {
        BuildDockerfile(ctx context.Context, ps *PipelineState, ref reference.Named, df Dockerfile, buildPath string, filter model.PathMatcher) (reference.NamedTagged, error)
        BuildImageFromScratch(ctx context.Context, ps *PipelineState, ref reference.Named, baseDockerfile Dockerfile, mounts []model.Mount, filter model.PathMatcher, steps []model.Step, entrypoint model.Cmd) (reference.NamedTagged, error)
        BuildImageFromExisting(ctx context.Context, ps *PipelineState, existing reference.NamedTagged, paths []pathMapping, filter model.PathMatcher, steps []model.Step) (reference.NamedTagged, error)
        PushImage(ctx context.Context, name reference.NamedTagged, writer io.Writer) (reference.NamedTagged, error)
        TagImage(ctx context.Context, name reference.Named, dig digest.Digest) (reference.NamedTagged, error)
}

func DefaultImageBuilder(b *dockerImageBuilder) ImageBuilder <span class="cov0" title="0">{
        return b
}</span>

func DefaultConsole() console.Console <span class="cov8" title="1">{
        out := os.Stdout
        c, _ := console.ConsoleFromFile(out)

        return c
}</span>

func DefaultOut() io.Writer <span class="cov8" title="1">{
        return os.Stdout
}</span>

type pushOutput struct {
        Tag    string
        Digest string
        Size   int
}

var _ ImageBuilder = &amp;dockerImageBuilder{}

func NewDockerImageBuilder(dcli docker.DockerClient, console console.Console, out io.Writer, extraLabels Labels) *dockerImageBuilder <span class="cov8" title="1">{
        return &amp;dockerImageBuilder{
                dcli:        dcli,
                console:     console,
                out:         out,
                extraLabels: extraLabels,
        }
}</span>

func (d *dockerImageBuilder) BuildDockerfile(ctx context.Context, ps *PipelineState, ref reference.Named, df Dockerfile, buildPath string, filter model.PathMatcher) (reference.NamedTagged, error) <span class="cov8" title="1">{
        span, ctx := opentracing.StartSpanFromContext(ctx, "dib-BuildDockerfile")
        defer span.Finish()

        paths := []pathMapping{
                {
                        LocalPath:     buildPath,
                        ContainerPath: "/",
                },
        }
        return d.buildFromDf(ctx, ps, df, paths, filter, ref)
}</span>

func (d *dockerImageBuilder) BuildImageFromScratch(ctx context.Context, ps *PipelineState, ref reference.Named, baseDockerfile Dockerfile,
        mounts []model.Mount, filter model.PathMatcher,
        steps []model.Step, entrypoint model.Cmd) (reference.NamedTagged, error) <span class="cov8" title="1">{

        span, ctx := opentracing.StartSpanFromContext(ctx, "daemon-BuildImageFromScratch")
        defer span.Finish()

        err := baseDockerfile.ValidateBaseDockerfile()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">hasEntrypoint := !entrypoint.Empty()

        paths := MountsToPathMappings(mounts)
        df := baseDockerfile
        df, steps, err = d.addConditionalSteps(df, steps, paths)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("BuildImageFromScratch: %v", err)
        }</span>

        <span class="cov8" title="1">df, err = d.addMounts(ctx, df, paths)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("BuildImageFromScratch: %v", err)
        }</span>

        <span class="cov8" title="1">df = d.addRemainingSteps(df, steps)
        if hasEntrypoint </span><span class="cov8" title="1">{
                df = df.Entrypoint(entrypoint)
        }</span>

        <span class="cov8" title="1">df = d.applyLabels(df, BuildModeScratch)
        return d.buildFromDf(ctx, ps, df, paths, filter, ref)</span>
}

func (d *dockerImageBuilder) BuildImageFromExisting(ctx context.Context, ps *PipelineState, existing reference.NamedTagged,
        paths []pathMapping, filter model.PathMatcher, steps []model.Step) (reference.NamedTagged, error) <span class="cov8" title="1">{

        span, ctx := opentracing.StartSpanFromContext(ctx, "daemon-BuildImageFromExisting")
        defer span.Finish()

        df := d.applyLabels(DockerfileFromExisting(existing), BuildModeExisting)

        // Don't worry about conditional steps on incremental builds, they've
        // already handled by the watch loop.
        df, err := d.addMounts(ctx, df, paths)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("BuildImageFromExisting: %v", err)
        }</span>

        <span class="cov8" title="1">df = d.addRemainingSteps(df, steps)
        return d.buildFromDf(ctx, ps, df, paths, filter, existing)</span>
}

func (d *dockerImageBuilder) applyLabels(df Dockerfile, buildMode LabelValue) Dockerfile <span class="cov8" title="1">{
        df = df.WithLabel(BuildMode, buildMode)
        for k, v := range d.extraLabels </span><span class="cov8" title="1">{
                df = df.WithLabel(k, v)
        }</span>
        <span class="cov8" title="1">return df</span>
}

// If the build starts with conditional steps, add the dependent files first,
// then add the runs, before we add the majority of the source.
func (d *dockerImageBuilder) addConditionalSteps(df Dockerfile, steps []model.Step, paths []pathMapping) (Dockerfile, []model.Step, error) <span class="cov8" title="1">{
        consumed := 0
        for _, step := range steps </span><span class="cov8" title="1">{
                if step.Triggers == nil </span><span class="cov8" title="1">{
                        break</span>
                }

                <span class="cov8" title="1">matcher, err := ignore.CreateStepMatcher(step)
                if err != nil </span><span class="cov0" title="0">{
                        return "", nil, err
                }</span>

                <span class="cov8" title="1">pathsToAdd, err := FilterMappings(paths, matcher)
                if err != nil </span><span class="cov0" title="0">{
                        return "", nil, err
                }</span>

                <span class="cov8" title="1">if len(pathsToAdd) == 0 </span><span class="cov0" title="0">{
                        // TODO(nick): If this happens, it means the input file has been deleted.
                        // This seems like a very late part of the pipeline to detect this
                        // error. It should have been caught way up when we were evaluating the
                        // tiltfile.
                        //
                        // For now, we're going to return an error to catch this case.
                        return "", nil, fmt.Errorf("No inputs for run: %s", step.Cmd)
                }</span>

                <span class="cov8" title="1">for _, p := range pathsToAdd </span><span class="cov8" title="1">{
                        // The tarball root is the same as the container root, so the src and dest
                        // are the same.
                        df = df.join(fmt.Sprintf("COPY %s %s", p.ContainerPath, p.ContainerPath))
                }</span>

                // After adding the inputs, run the step.
                //
                // TODO(nick): This assumes that the RUN step doesn't overwrite any input files
                // that might be added later. In that case, we might need to do something
                // clever where we stash the outputs and restore them after the final "ADD . /".
                // But let's see how this works for now.
                <span class="cov8" title="1">df = df.Run(step.Cmd)
                consumed++</span>
        }

        <span class="cov8" title="1">remainingSteps := append([]model.Step{}, steps[consumed:]...)
        return df, remainingSteps, nil</span>
}

func (d *dockerImageBuilder) addMounts(ctx context.Context, df Dockerfile, paths []pathMapping) (Dockerfile, error) <span class="cov8" title="1">{
        df = df.AddAll()
        toRemove, err := MissingLocalPaths(ctx, paths)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("addMounts: %v", err)
        }</span>

        <span class="cov8" title="1">df = df.RmPaths(toRemove)
        return df, nil</span>
}

func (d *dockerImageBuilder) addRemainingSteps(df Dockerfile, remaining []model.Step) Dockerfile <span class="cov8" title="1">{
        for _, step := range remaining </span><span class="cov8" title="1">{
                df = df.Run(step.Cmd)
        }</span>
        <span class="cov8" title="1">return df</span>
}

// Tag the digest with the given name and wm-tilt tag.
func (d *dockerImageBuilder) TagImage(ctx context.Context, ref reference.Named, dig digest.Digest) (reference.NamedTagged, error) <span class="cov8" title="1">{
        tag, err := digestAsTag(dig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("TagImage: %v", err)
        }</span>

        <span class="cov8" title="1">namedTagged, err := reference.WithTag(ref, tag)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("TagImage: %v", err)
        }</span>

        <span class="cov8" title="1">err = d.dcli.ImageTag(ctx, dig.String(), namedTagged.String())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("TagImage#ImageTag: %v", err)
        }</span>

        <span class="cov8" title="1">return namedTagged, nil</span>
}

// Naively tag the digest and push it up to the docker registry specified in the name.
//
// TODO(nick) In the future, I would like us to be smarter about checking if the kubernetes cluster
// we're running in has access to the given registry. And if it doesn't, we should either emit an
// error, or push to a registry that kubernetes does have access to (e.g., a local registry).
func (d *dockerImageBuilder) PushImage(ctx context.Context, ref reference.NamedTagged, writer io.Writer) (reference.NamedTagged, error) <span class="cov8" title="1">{
        l := logger.Get(ctx)
        l.Infof("Pushing Docker image")
        prefix := logger.Blue(l).Sprint("  │ ")

        span, ctx := opentracing.StartSpanFromContext(ctx, "daemon-PushImage")
        defer span.Finish()

        repoInfo, err := registry.ParseRepositoryInfo(ref)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("PushImage#ParseRepositoryInfo: %s", err)
        }</span>

        <span class="cov8" title="1">l.Infof("%sconnecting to repository", prefix)
        cli := command.NewDockerCli(nil, writer, writer, true)

        err = cli.Initialize(cliflags.NewClientOptions())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("PushImage#InitializeCLI: %s", err)
        }</span>
        <span class="cov8" title="1">authConfig := command.ResolveAuthConfig(ctx, cli, repoInfo.Index)
        requestPrivilege := command.RegistryAuthenticationPrivilegedFunc(cli, repoInfo.Index, "push")

        encodedAuth, err := command.EncodeAuthToBase64(authConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("PushImage#EncodeAuthToBase64: %s", err)
        }</span>

        <span class="cov8" title="1">options := types.ImagePushOptions{
                RegistryAuth:  encodedAuth,
                PrivilegeFunc: requestPrivilege,
        }

        if reference.Domain(ref) == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("PushImage: no domain in container name: %s", ref)
        }</span>

        <span class="cov8" title="1">l.Infof("%spushing the image", prefix)
        imagePushResponse, err := d.dcli.ImagePush(
                ctx,
                ref.String(),
                options)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("PushImage#ImagePush: %v", err)
        }</span>

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                err := imagePushResponse.Close()
                if err != nil </span><span class="cov0" title="0">{
                        l.Infof("unable to close imagePushResponse: %s", err)
                }</span>
        }()
        <span class="cov8" title="1">_, err = d.getDigestFromPushOutput(ctx, imagePushResponse, writer)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("Pushing image %q: %v", ref.Name(), err)
        }</span>

        <span class="cov8" title="1">return ref, nil</span>
}

func (d *dockerImageBuilder) buildFromDf(ctx context.Context, ps *PipelineState, df Dockerfile, paths []pathMapping, filter model.PathMatcher, ref reference.Named) (reference.NamedTagged, error) <span class="cov8" title="1">{
        span, ctx := opentracing.StartSpanFromContext(ctx, "daemon-buildFromDf")
        defer span.Finish()

        // TODO(Han): Extend output to print without newline
        ps.StartBuildStep(ctx, "Tarring context…")

        archive, err := tarContextAndUpdateDf(ctx, df, paths, filter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // TODO(Han): Extend output to print without newline
        <span class="cov8" title="1">ps.Printf(ctx, "Created tarball (size: %s)",
                humanize.Bytes(uint64(archive.Len())))

        ps.StartBuildStep(ctx, "Building image")
        spanBuild, ctx := opentracing.StartSpanFromContext(ctx, "daemon-ImageBuild")
        imageBuildResponse, err := d.dcli.ImageBuild(
                ctx,
                archive,
                Options(archive),
        )
        spanBuild.Finish()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                err := imageBuildResponse.Body.Close()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Get(ctx).Infof("unable to close imagePushResponse: %s", err)
                }</span>
        }()
        <span class="cov8" title="1">result, err := d.readDockerOutput(ctx, imageBuildResponse.Body, ps.Writer(ctx))
        if err != nil </span><span class="cov8" title="1">{
                return nil, errors.Wrap(err, "ImageBuild")
        }</span>
        <span class="cov8" title="1">if result == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Unable to read docker output: result is nil")
        }</span>

        <span class="cov8" title="1">digest, err := getDigestFromAux(*result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("getDigestFromAux: %v", err)
        }</span>

        <span class="cov8" title="1">nt, err := d.TagImage(ctx, ref, digest)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("PushImage: %v", err)
        }</span>

        <span class="cov8" title="1">return nt, nil</span>
}

// Docker API commands stream back a sequence of JSON messages.
//
// The result of the command is in a JSON object with field "aux".
//
// Errors are reported in a JSON object with field "errorDetail"
//
// NOTE(nick): I haven't found a good document describing this protocol
// but you can find it implemented in Docker here:
// https://github.com/moby/moby/blob/1da7d2eebf0a7a60ce585f89a05cebf7f631019c/pkg/jsonmessage/jsonmessage.go#L139
func (d *dockerImageBuilder) readDockerOutput(ctx context.Context, reader io.Reader, writer io.Writer) (*json.RawMessage, error) <span class="cov8" title="1">{
        span, ctx := opentracing.StartSpanFromContext(ctx, "daemon-readDockerOutput")
        defer span.Finish()

        var result *json.RawMessage
        decoder := json.NewDecoder(reader)
        var innerSpan opentracing.Span

        b := newBuildkitPrinter(logger.Get(ctx))

        for decoder.More() </span><span class="cov8" title="1">{
                if innerSpan != nil </span><span class="cov8" title="1">{
                        innerSpan.Finish()
                }</span>
                <span class="cov8" title="1">message := jsonmessage.JSONMessage{}
                err := decoder.Decode(&amp;message)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("decoding docker output: %v", err)
                }</span>

                <span class="cov8" title="1">if len(message.Stream) &gt; 0 &amp;&amp; message.Stream != "\n" </span><span class="cov8" title="1">{
                        msg := strings.TrimSuffix(message.Stream, "\n")
                        _, err = writer.Write([]byte(msg))
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, errors.Wrap(err, "failed to write docker output")
                        }</span>
                        <span class="cov8" title="1">if strings.HasPrefix(msg, "Step") || strings.HasPrefix(msg, "Running") </span><span class="cov8" title="1">{
                                innerSpan, ctx = opentracing.StartSpanFromContext(ctx, msg)
                        }</span>
                }

                <span class="cov8" title="1">if message.ErrorMessage != "" </span><span class="cov8" title="1">{
                        return nil, errors.New(message.ErrorMessage)
                }</span>

                <span class="cov8" title="1">if message.Error != nil </span><span class="cov0" title="0">{
                        return nil, errors.New(message.Error.Message)
                }</span>

                <span class="cov8" title="1">if messageIsFromBuildkit(message) </span><span class="cov8" title="1">{
                        err := toBuildkitStatus(message.Aux, b)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }

                <span class="cov8" title="1">if message.Aux != nil &amp;&amp; !messageIsFromBuildkit(message) </span><span class="cov8" title="1">{
                        result = message.Aux
                }</span>
        }

        <span class="cov8" title="1">if innerSpan != nil </span><span class="cov8" title="1">{
                innerSpan.Finish()
        }</span>
        <span class="cov8" title="1">if ctx.Err() != nil </span><span class="cov0" title="0">{
                return nil, ctx.Err()
        }</span>
        <span class="cov8" title="1">return result, nil</span>
}

func toBuildkitStatus(aux *json.RawMessage, b *buildkitPrinter) error <span class="cov8" title="1">{
        var resp controlapi.StatusResponse
        var dt []byte
        // ignoring all messages that are not understood
        if err := json.Unmarshal(*aux, &amp;dt); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := (&amp;resp).Unmarshal(dt); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">vertexes := []*vertex{}
        logs := []*vertexLog{}

        for _, v := range resp.Vertexes </span><span class="cov8" title="1">{
                vertexes = append(vertexes, &amp;vertex{
                        digest:    v.Digest,
                        name:      v.Name,
                        error:     v.Error,
                        started:   v.Started != nil,
                        completed: v.Completed != nil,
                })
        }</span>
        <span class="cov8" title="1">for _, v := range resp.Logs </span><span class="cov8" title="1">{
                logs = append(logs, &amp;vertexLog{
                        vertex: v.Vertex,
                        msg:    v.Msg,
                })
        }</span>

        <span class="cov8" title="1">return b.parseAndPrint(vertexes, logs)</span>
}

func messageIsFromBuildkit(msg jsonmessage.JSONMessage) bool <span class="cov8" title="1">{
        return msg.ID == "moby.buildkit.trace"
}</span>

func (d *dockerImageBuilder) getDigestFromBuildOutput(ctx context.Context, reader io.Reader, writer io.Writer) (digest.Digest, error) <span class="cov8" title="1">{
        aux, err := d.readDockerOutput(ctx, reader, writer)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">if aux == nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("getDigestFromBuildOutput: No results found in docker output")
        }</span>
        <span class="cov8" title="1">return getDigestFromAux(*aux)</span>
}

func (d *dockerImageBuilder) getDigestFromPushOutput(ctx context.Context, reader io.Reader, writer io.Writer) (digest.Digest, error) <span class="cov8" title="1">{
        aux, err := d.readDockerOutput(ctx, reader, writer)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">if aux == nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no digest found in push output")
        }</span>

        <span class="cov8" title="1">dig := pushOutput{}
        err = json.Unmarshal(*aux, &amp;dig)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("getDigestFromPushOutput#Unmarshal: %v, json string: %+v", err, aux)
        }</span>

        <span class="cov8" title="1">if dig.Digest == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("getDigestFromPushOutput: Digest not found in %+v", aux)
        }</span>

        <span class="cov8" title="1">return digest.Digest(dig.Digest), nil</span>
}

func getDigestFromAux(aux json.RawMessage) (digest.Digest, error) <span class="cov8" title="1">{
        digestMap := make(map[string]string, 0)
        err := json.Unmarshal(aux, &amp;digestMap)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("getDigestFromAux: %v", err)
        }</span>

        <span class="cov8" title="1">id, ok := digestMap["ID"]
        if !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf("getDigestFromAux: ID not found")
        }</span>
        <span class="cov8" title="1">return digest.Digest(id), nil</span>
}

func digestAsTag(d digest.Digest) (string, error) <span class="cov8" title="1">{
        str := d.Encoded()
        if len(str) &lt; 16 </span><span class="cov8" title="1">{
                return "", fmt.Errorf("Digest too short: %s", str)
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%s%s", ImageTagPrefix, str[:16]), nil</span>
}

func digestMatchesRef(ref reference.NamedTagged, digest digest.Digest) bool <span class="cov8" title="1">{
        digestHash := digest.Encoded()
        tag := ref.Tag()
        if len(tag) &lt;= len(ImageTagPrefix) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">tagHash := tag[len(ImageTagPrefix):]
        return strings.HasPrefix(digestHash, tagHash)</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package build

import (
        "context"
        "fmt"
        "time"

        "golang.org/x/sync/errgroup"

        "github.com/docker/distribution/reference"
        "github.com/docker/docker/api/types"
        "github.com/docker/docker/api/types/filters"
        "github.com/docker/docker/client"
        "github.com/windmilleng/tilt/internal/docker"
)

type ImageReaper struct {
        docker docker.DockerClient
}

func FilterByLabel(label Label) filters.KeyValuePair <span class="cov8" title="1">{
        return filters.Arg("label", string(label))
}</span>

func FilterByLabelValue(label Label, val LabelValue) filters.KeyValuePair <span class="cov0" title="0">{
        return filters.Arg("label", fmt.Sprintf("%s=%s", label, val))
}</span>

func FilterByRefName(ref reference.Named) filters.KeyValuePair <span class="cov0" title="0">{
        return filters.Arg("reference", fmt.Sprintf("%s:*", ref.Name()))
}</span>

func NewImageReaper(docker docker.DockerClient) ImageReaper <span class="cov8" title="1">{
        return ImageReaper{
                docker: docker,
        }
}</span>

// Delete all Tilt builds
//
// For safety reasons, we only delete images with the tilt.buildMode label,
// but we let the caller set additional filters.
func (r ImageReaper) RemoveTiltImages(ctx context.Context, createdBefore time.Time, force bool, extraFilters ...filters.KeyValuePair) error <span class="cov8" title="1">{
        defaultFilter := FilterByLabel(BuildMode)
        filterList := append([]filters.KeyValuePair{defaultFilter}, extraFilters...)
        listOptions := types.ImageListOptions{
                Filters: filters.NewArgs(filterList...),
        }

        summaries, err := r.docker.ImageList(ctx, listOptions)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("RemoveTiltImages: %v", err)
        }</span>

        <span class="cov8" title="1">g, ctx := errgroup.WithContext(ctx)
        rmOptions := types.ImageRemoveOptions{
                PruneChildren: true,
                Force:         force,
        }
        for _, summary := range summaries </span><span class="cov8" title="1">{
                id := summary.ID
                created := time.Unix(summary.Created, 0)
                if !created.Before(createdBefore) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">g.Go(func() error </span><span class="cov8" title="1">{
                        _, err := r.docker.ImageRemove(ctx, id, rmOptions)
                        if client.IsErrNotFound(err) </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        <span class="cov8" title="1">return err</span>
                })
        }

        <span class="cov8" title="1">err = g.Wait()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("RemoveTiltImages: %v", err)
        }</span>
        <span class="cov8" title="1">return err</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package build

import (
        "flag"
        "io"

        "github.com/docker/docker/api/types"
)

func Options(archive io.Reader) types.ImageBuildOptions <span class="cov8" title="1">{
        return types.ImageBuildOptions{
                Context:    archive,
                Dockerfile: "Dockerfile",
                Remove:     shouldRemoveImage(),
                Version:    types.BuilderBuildKit,
        }
}</span>

func shouldRemoveImage() bool <span class="cov8" title="1">{
        if flag.Lookup("test.v") == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package build

import (
        "context"
        "fmt"
        "os"
        "path/filepath"

        "github.com/opentracing/opentracing-go"
        "github.com/windmilleng/tilt/internal/model"
        "github.com/windmilleng/tilt/internal/ospath"
)

// pathMapping represents a mapping from the local path to the tarball path
//
// To send a local file into a container, we copy it into a tarball, send the
// tarball to docker, and then run a sequence of steps to unpack the tarball in
// the container file system.
//
// That means every file has 3 paths:
// 1) LocalPath
// 2) TarballPath
// 3) ContainerPath
//
// In incremental builds, TarballPath and ContainerPath are always the
// same, so it was correct to use TarballPath and ContainerPath interchangeably.
//
// In static builds, this is no longer the case.
//
// TODO(nick): Do a pass on renaming all the path types
type pathMapping struct {
        LocalPath     string
        ContainerPath string
}

func (m pathMapping) Filter(matcher model.PathMatcher) ([]pathMapping, error) <span class="cov8" title="1">{
        result := make([]pathMapping, 0)
        err := filepath.Walk(m.LocalPath, func(path string, info os.FileInfo, err error) error </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">match, err := matcher.Matches(path, info.IsDir())
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">if !match </span><span class="cov8" title="1">{
                        return nil
                }</span>

                <span class="cov8" title="1">rp, err := filepath.Rel(m.LocalPath, path)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">result = append(result, pathMapping{
                        LocalPath:     path,
                        ContainerPath: filepath.Join(m.ContainerPath, rp),
                })
                return nil</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return result, nil</span>
}

func FilterMappings(mappings []pathMapping, matcher model.PathMatcher) ([]pathMapping, error) <span class="cov8" title="1">{
        result := make([]pathMapping, 0)
        for _, mapping := range mappings </span><span class="cov8" title="1">{
                filtered, err := mapping.Filter(matcher)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">result = append(result, filtered...)</span>
        }
        <span class="cov8" title="1">return result, nil</span>
}

// FilesToPathMappings converts a list of absolute local filepaths into pathMappings (i.e.
// associates local filepaths with their mounts and destination paths).
func FilesToPathMappings(files []string, mounts []model.Mount) ([]pathMapping, error) <span class="cov8" title="1">{
        pms, err := filesToPathMappings(files, mounts)
        if err != nil </span><span class="cov8" title="1">{
                return pms, err
        }</span>
        <span class="cov8" title="1">return pms, nil</span>
}

func filesToPathMappings(files []string, mounts []model.Mount) ([]pathMapping, *PathMappingErr) <span class="cov8" title="1">{
        var pms []pathMapping
        for _, f := range files </span><span class="cov8" title="1">{
                pm, err := fileToPathMapping(f, mounts)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">pms = append(pms, pm)</span>
        }

        <span class="cov8" title="1">return pms, nil</span>
}

func fileToPathMapping(file string, mounts []model.Mount) (pathMapping, *PathMappingErr) <span class="cov8" title="1">{
        for _, m := range mounts </span><span class="cov8" title="1">{
                // Open Q: can you mount inside of mounts?! o_0
                // TODO(maia): are symlinks etc. gonna kick our asses here? If so, will
                // need ospath.RealChild -- but then can't deal with deleted local files.
                relPath, isChild := ospath.Child(m.LocalPath, file)
                if isChild </span><span class="cov8" title="1">{
                        return pathMapping{
                                LocalPath:     file,
                                ContainerPath: filepath.Join(m.ContainerPath, relPath),
                        }, nil
                }</span>
        }
        <span class="cov8" title="1">return pathMapping{}, pathMappingErrf("file %s matches no mounts", file)</span>
}

func FileBelongsToMount(file string, mounts []model.Mount) bool <span class="cov0" title="0">{
        _, err := fileToPathMapping(file, mounts)
        return err == nil
}</span>

func MountsToPathMappings(mounts []model.Mount) []pathMapping <span class="cov8" title="1">{
        pms := make([]pathMapping, len(mounts))
        for i, m := range mounts </span><span class="cov8" title="1">{
                pms[i] = pathMapping{
                        LocalPath:     m.LocalPath,
                        ContainerPath: m.ContainerPath,
                }
        }</span>
        <span class="cov8" title="1">return pms</span>
}

// Return all the path mappings for local paths that do not exist.
func MissingLocalPaths(ctx context.Context, mappings []pathMapping) ([]pathMapping, error) <span class="cov8" title="1">{
        span, ctx := opentracing.StartSpanFromContext(ctx, "MissingLocalPaths")
        defer span.Finish()
        result := make([]pathMapping, 0)
        for _, mapping := range mappings </span><span class="cov8" title="1">{
                _, err := os.Stat(mapping.LocalPath)
                if err == nil </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">if os.IsNotExist(err) </span><span class="cov8" title="1">{
                        result = append(result, mapping)
                }</span> else<span class="cov0" title="0"> {
                        return nil, fmt.Errorf("MissingLocalPaths: %v", err)
                }</span>
        }
        <span class="cov8" title="1">return result, nil</span>
}

func PathMappingsToContainerPaths(mappings []pathMapping) []string <span class="cov0" title="0">{
        res := make([]string, len(mappings))
        for i, m := range mappings </span><span class="cov0" title="0">{
                res[i] = m.ContainerPath
        }</span>
        <span class="cov0" title="0">return res</span>
}

type PathMappingErr struct {
        s string
}

func (e *PathMappingErr) Error() string <span class="cov8" title="1">{ return e.s }</span>

var _ error = &amp;PathMappingErr{}

func pathMappingErrf(format string, a ...interface{}) *PathMappingErr <span class="cov8" title="1">{
        return &amp;PathMappingErr{s: fmt.Sprintf(format, a...)}
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package build

import (
        "context"
        "fmt"
        "io"
        "strings"
        "time"

        "github.com/windmilleng/tilt/internal/logger"
)

type PipelineState struct {
        curPipelineStep        int
        curBuildStep           int
        totalPipelineStepCount int
        pipelineStepDurations  []time.Duration
        curPipelineStart       time.Time
        curPipelineStepStart   time.Time
}

const buildStepOutputPrefix = "    ╎ "

func NewPipelineState(ctx context.Context, totalStepCount int) *PipelineState <span class="cov8" title="1">{
        return &amp;PipelineState{
                curPipelineStep:        1,
                totalPipelineStepCount: totalStepCount,
                curPipelineStart:       time.Now(),
        }
}</span>

// NOTE(maia): this func should always be deferred in a closure, so that the `err` arg
// is bound at the time of calling rather than at the time of deferring. I.e., do:
//     defer func() { ps.End(err) }()
// and NOT:
//     defer ps.End(err)
func (ps *PipelineState) End(ctx context.Context, err error) <span class="cov8" title="1">{
        l := logger.Get(ctx)
        prefix := logger.Blue(l).Sprint("  │ ")

        elapsed := time.Now().Sub(ps.curPipelineStart)

        if err != nil </span><span class="cov8" title="1">{
                prefix := logger.Red(l).Sprint("ERROR:")
                l.Infof("%s %s", prefix, err.Error())
                ps.curPipelineStep = 0
                ps.curBuildStep = 0
                return
        }</span>

        <span class="cov8" title="1">for i, duration := range ps.pipelineStepDurations </span><span class="cov8" title="1">{
                l.Infof("%sStep %d - %.3fs", prefix, i+1, duration.Seconds())
        }</span>

        <span class="cov8" title="1">l.Infof("%sDone in: %.3fs \n", prefix, elapsed.Seconds())
        ps.curPipelineStep = 0
        ps.curBuildStep = 0</span>
}

func (ps *PipelineState) StartPipelineStep(ctx context.Context, format string, a ...interface{}) <span class="cov8" title="1">{
        l := logger.Get(ctx)
        line := logger.Blue(l).Sprintf("STEP %d/%d — ", ps.curPipelineStep, ps.totalPipelineStepCount)
        l.Infof("%s%s", line, fmt.Sprintf(format, a...))
        ps.curPipelineStep++
        ps.curBuildStep = 1
        ps.curPipelineStepStart = time.Now()
}</span>

func (ps *PipelineState) EndPipelineStep(ctx context.Context) <span class="cov8" title="1">{
        l := logger.Get(ctx)
        elapsed := time.Now().Sub(ps.curPipelineStepStart)
        l.Infof("    (Done %.3fs)\n", elapsed.Seconds())
        ps.pipelineStepDurations = append(ps.pipelineStepDurations, elapsed)
}</span>

func (ps *PipelineState) StartBuildStep(ctx context.Context, format string, a ...interface{}) <span class="cov8" title="1">{
        l := logger.Get(ctx)
        p := logger.Blue(l).Sprint("  │ ")
        l.Infof("%s%s", p, fmt.Sprintf(format, a...))
        ps.curBuildStep++
}</span>

func (ps *PipelineState) Printf(ctx context.Context, format string, a ...interface{}) <span class="cov8" title="1">{
        l := logger.Get(ctx)
        if ps.curBuildStep == 0 </span><span class="cov0" title="0">{
                l.Infof(format, a...)
        }</span> else<span class="cov8" title="1"> {
                message := fmt.Sprintf(format, a...)
                message = strings.Replace(message, "\n", "\n"+buildStepOutputPrefix, -1)
                l.Infof("%s%s", buildStepOutputPrefix, message)
        }</span>
}

func (ps *PipelineState) Writer(ctx context.Context) io.Writer <span class="cov8" title="1">{
        l := logger.Get(ctx)
        underlying := l.Writer(logger.InfoLvl)
        if ps.curBuildStep == 0 </span><span class="cov0" title="0">{
                return underlying
        }</span> else<span class="cov8" title="1"> {
                return logger.NewPrefixedWriter(buildStepOutputPrefix, underlying)
        }</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package build

import (
        "archive/tar"
        "bytes"
        "context"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "strings"
        "time"

        "github.com/windmilleng/tilt/internal/model"

        opentracing "github.com/opentracing/opentracing-go"
)

type ArchiveBuilder struct {
        tw     *tar.Writer
        buf    *bytes.Buffer
        filter model.PathMatcher
}

func NewArchiveBuilder(filter model.PathMatcher) *ArchiveBuilder <span class="cov8" title="1">{
        buf := new(bytes.Buffer)
        tw := tar.NewWriter(buf)
        if filter == nil </span><span class="cov0" title="0">{
                filter = model.EmptyMatcher
        }</span>

        <span class="cov8" title="1">return &amp;ArchiveBuilder{tw: tw, buf: buf, filter: filter}</span>
}

func (a *ArchiveBuilder) close() error <span class="cov8" title="1">{
        return a.tw.Close()
}</span>

func (a *ArchiveBuilder) archiveDf(ctx context.Context, df Dockerfile) error <span class="cov8" title="1">{
        span, ctx := opentracing.StartSpanFromContext(ctx, "daemon-archiveDf")
        defer span.Finish()
        tarHeader := &amp;tar.Header{
                Name:       "Dockerfile",
                Typeflag:   tar.TypeReg,
                Size:       int64(len(df)),
                ModTime:    time.Now(),
                AccessTime: time.Now(),
                ChangeTime: time.Now(),
        }
        err := a.tw.WriteHeader(tarHeader)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">_, err = a.tw.Write([]byte(df))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ArchivePathsIfExist creates a tar archive of all local files in `paths`. It quietly skips any paths that don't exist.
func (a *ArchiveBuilder) ArchivePathsIfExist(ctx context.Context, paths []pathMapping) error <span class="cov8" title="1">{
        span, ctx := opentracing.StartSpanFromContext(ctx, "daemon-ArchivePathsIfExist")
        defer span.Finish()
        for _, p := range paths </span><span class="cov8" title="1">{
                err := a.tarPath(ctx, p.LocalPath, p.ContainerPath)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("tarPath '%s': %v", p.LocalPath, err)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (a *ArchiveBuilder) BytesBuffer() (*bytes.Buffer, error) <span class="cov8" title="1">{
        err := a.close()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return a.buf, nil</span>
}

// tarPath writes the given source path into tarWriter at the given dest (recursively for directories).
// e.g. tarring my_dir --&gt; dest d: d/file_a, d/file_b
// If source path does not exist, quietly skips it and returns no err
func (a *ArchiveBuilder) tarPath(ctx context.Context, source, dest string) error <span class="cov8" title="1">{
        span, ctx := opentracing.StartSpanFromContext(ctx, fmt.Sprintf("daemon-tarPath-%s", source))
        span.SetTag("source", source)
        span.SetTag("dest", dest)
        defer span.Finish()
        sourceInfo, err := os.Stat(source)

        if err != nil </span><span class="cov8" title="1">{
                if os.IsNotExist(err) </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("%s: stat: %v", source, err)</span>
        }

        <span class="cov8" title="1">sourceIsDir := sourceInfo.IsDir()
        if sourceIsDir </span><span class="cov8" title="1">{
                // Make sure we can trim this off filenames to get valid relative filepaths
                if !strings.HasSuffix(source, "/") </span><span class="cov8" title="1">{
                        source += "/"
                }</span>
        }

        <span class="cov8" title="1">dest = strings.TrimPrefix(dest, "/")

        err = filepath.Walk(source, func(path string, info os.FileInfo, err error) error </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error walking to %s: %v", path, err)
                }</span>

                <span class="cov8" title="1">matches, err := a.filter.Matches(path, info.IsDir())
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span> else<span class="cov8" title="1"> if matches </span><span class="cov8" title="1">{
                        return nil
                }</span>

                <span class="cov8" title="1">header, err := tar.FileInfoHeader(info, path)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("%s: making header: %v", path, err)
                }</span>

                <span class="cov8" title="1">if sourceIsDir </span><span class="cov8" title="1">{
                        // Name of file in tar should be relative to source directory...
                        header.Name = strings.TrimPrefix(path, source)
                        // ...and live inside `dest`
                        header.Name = filepath.Join(dest, header.Name)
                }</span> else<span class="cov8" title="1"> {
                        header.Name = dest
                }</span>

                <span class="cov8" title="1">err = a.tw.WriteHeader(header)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("%s: writing header: %v", path, err)
                }</span>

                <span class="cov8" title="1">if info.IsDir() </span><span class="cov8" title="1">{
                        return nil
                }</span>

                <span class="cov8" title="1">if header.Typeflag == tar.TypeReg </span><span class="cov8" title="1">{
                        file, err := os.Open(path)
                        if err != nil </span><span class="cov0" title="0">{
                                // In case the file has been deleted since we last looked at it.
                                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                                        return nil
                                }</span>
                                <span class="cov0" title="0">return fmt.Errorf("%s: open: %v", path, err)</span>
                        }
                        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                                _ = file.Close()
                        }</span>()

                        <span class="cov8" title="1">_, err = io.CopyN(a.tw, file, info.Size())
                        if err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                                return fmt.Errorf("%s: copying Contents: %v", path, err)
                        }</span>
                }
                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">return err</span>
}

func (a *ArchiveBuilder) len() int <span class="cov8" title="1">{
        return a.buf.Len()
}</span>

func tarContextAndUpdateDf(ctx context.Context, df Dockerfile, paths []pathMapping, filter model.PathMatcher) (*bytes.Buffer, error) <span class="cov8" title="1">{
        span, ctx := opentracing.StartSpanFromContext(ctx, "daemon-tarContextAndUpdateDf")
        defer span.Finish()

        ab := NewArchiveBuilder(filter)
        err := ab.ArchivePathsIfExist(ctx, paths)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("archivePaths: %v", err)
        }</span>

        <span class="cov8" title="1">err = ab.archiveDf(ctx, df)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("archiveDf: %v", err)
        }</span>

        <span class="cov8" title="1">return ab.BytesBuffer()</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package build

import (
        "archive/tar"
        "bytes"
        "context"
        "fmt"
        "log"
        "os/exec"
        "path/filepath"
        "strings"
        "testing"
        "time"

        "github.com/docker/distribution/reference"
        "github.com/docker/docker/api/types"
        "github.com/docker/docker/api/types/container"
        "github.com/docker/docker/client"
        "github.com/windmilleng/tilt/internal/docker"
        "github.com/windmilleng/tilt/internal/k8s"
        "github.com/windmilleng/tilt/internal/model"
        "github.com/windmilleng/tilt/internal/testutils"
        "github.com/windmilleng/tilt/internal/testutils/bufsync"
        "github.com/windmilleng/tilt/internal/testutils/output"
        "github.com/windmilleng/tilt/internal/testutils/tempdir"
)

type dockerBuildFixture struct {
        *tempdir.TempDirFixture
        t            testing.TB
        ctx          context.Context
        dcli         *docker.DockerCli
        fakeDocker   *docker.FakeDockerClient
        b            *dockerImageBuilder
        registry     *exec.Cmd
        reaper       ImageReaper
        containerIDs []k8s.ContainerID
        ps           *PipelineState
}

func newDockerBuildFixture(t testing.TB) *dockerBuildFixture <span class="cov8" title="1">{
        ctx := output.CtxForTest()
        dcli, err := docker.DefaultDockerClient(ctx, k8s.EnvGKE)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatal(err)
        }</span>

        <span class="cov8" title="1">ps := NewPipelineState(ctx, 3)

        labels := Labels(map[Label]LabelValue{
                TestImage: "1",
        })
        return &amp;dockerBuildFixture{
                TempDirFixture: tempdir.NewTempDirFixture(t),
                t:              t,
                ctx:            ctx,
                dcli:           dcli,
                b:              NewDockerImageBuilder(dcli, DefaultConsole(), DefaultOut(), labels),
                reaper:         NewImageReaper(dcli),
                ps:             ps,
        }</span>
}

func newFakeDockerBuildFixture(t testing.TB) *dockerBuildFixture <span class="cov8" title="1">{
        ctx := output.CtxForTest()
        dcli := docker.NewFakeDockerClient()
        labels := Labels(map[Label]LabelValue{
                TestImage: "1",
        })

        ps := NewPipelineState(ctx, 3)

        return &amp;dockerBuildFixture{
                TempDirFixture: tempdir.NewTempDirFixture(t),
                t:              t,
                ctx:            ctx,
                fakeDocker:     dcli,
                b:              NewDockerImageBuilder(dcli, DefaultConsole(), DefaultOut(), labels),
                reaper:         NewImageReaper(dcli),
                ps:             ps,
        }
}</span>

func (f *dockerBuildFixture) teardown() <span class="cov8" title="1">{
        for _, cID := range f.containerIDs </span><span class="cov8" title="1">{
                // ignore failures
                _ = f.dcli.ContainerRemove(f.ctx, string(cID), types.ContainerRemoveOptions{
                        Force: true,
                })
        }</span>

        // ignore failures
        <span class="cov8" title="1">_ = f.reaper.RemoveTiltImages(f.ctx, time.Now(), true /*force*/, FilterByLabel(TestImage))

        if f.registry != nil &amp;&amp; f.registry.Process != nil </span><span class="cov8" title="1">{
                go func() </span><span class="cov8" title="1">{
                        err := f.registry.Process.Kill()
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("killing the registry failed: %v\n", err)
                        }</span>
                }()

                // ignore the error. we expect it to be killed
                <span class="cov8" title="1">_ = f.registry.Wait()

                _ = exec.Command("docker", "kill", "tilt-registry").Run()
                _ = exec.Command("docker", "rm", "tilt-registry").Run()</span>
        }
        <span class="cov8" title="1">f.TempDirFixture.TearDown()</span>
}

func (f *dockerBuildFixture) getNameFromTest() reference.Named <span class="cov8" title="1">{
        x := fmt.Sprintf("windmill.build/%s", strings.ToLower(f.t.Name()))
        name, err := reference.WithName(x)
        if err != nil </span><span class="cov0" title="0">{
                f.t.Fatal(err)
        }</span>

        <span class="cov8" title="1">return name</span>
}

func (f *dockerBuildFixture) startRegistry() <span class="cov8" title="1">{
        stdout := bufsync.NewThreadSafeBuffer()
        stderr := &amp;bytes.Buffer{}
        cmd := exec.Command("docker", "run", "--name", "tilt-registry", "-p", "5005:5000", "registry:2")
        cmd.Stdout = stdout
        cmd.Stderr = stderr
        f.registry = cmd

        err := cmd.Start()
        if err != nil </span><span class="cov0" title="0">{
                f.t.Fatal(err)
        }</span>

        <span class="cov8" title="1">err = stdout.WaitUntilContains("listening on", 5*time.Second)
        if err != nil </span><span class="cov0" title="0">{
                f.t.Fatalf("Registry didn't start: %v", err)
        }</span>
}

type expectedFile = testutils.ExpectedFile

func (f *dockerBuildFixture) assertImageExists(ref reference.NamedTagged) <span class="cov8" title="1">{
        _, _, err := f.dcli.ImageInspectWithRaw(f.ctx, ref.String())
        if err != nil </span><span class="cov0" title="0">{
                f.t.Errorf("Expected image %q to exist, got: %v", ref, err)
        }</span>
}

func (f *dockerBuildFixture) assertImageNotExists(ref reference.NamedTagged) <span class="cov8" title="1">{
        _, _, err := f.dcli.ImageInspectWithRaw(f.ctx, ref.String())
        if err == nil || !client.IsErrNotFound(err) </span><span class="cov0" title="0">{
                f.t.Errorf("Expected image %q to fail with ErrNotFound, got: %v", ref, err)
        }</span>
}

func (f *dockerBuildFixture) assertFilesInImage(ref reference.NamedTagged, expectedFiles []expectedFile) <span class="cov8" title="1">{
        cID := f.startContainer(f.ctx, containerConfigRunCmd(ref, model.Cmd{}))
        f.assertFilesInContainer(f.ctx, cID, expectedFiles)
}</span>

func (f *dockerBuildFixture) assertFilesInContainer(
        ctx context.Context, cID k8s.ContainerID, expectedFiles []expectedFile) <span class="cov8" title="1">{
        for _, expectedFile := range expectedFiles </span><span class="cov8" title="1">{
                reader, _, err := f.dcli.CopyFromContainer(ctx, cID.String(), expectedFile.Path)
                if expectedFile.Missing </span><span class="cov8" title="1">{
                        if err == nil </span><span class="cov0" title="0">{
                                f.t.Errorf("Expected path %q to not exist", expectedFile.Path)
                        }</span> else<span class="cov8" title="1"> if !strings.Contains(err.Error(), "No such container:path") </span><span class="cov0" title="0">{
                                f.t.Errorf("Expected path %q to not exist, but got a different error: %v", expectedFile.Path, err)
                        }</span>

                        <span class="cov8" title="1">continue</span>
                }

                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        f.t.Fatal(err)
                }</span>

                // When you copy a single file out of a container, you get
                // back a tarball with 1 entry, the file basename.
                <span class="cov8" title="1">adjustedFile := expectedFile
                adjustedFile.Path = filepath.Base(adjustedFile.Path)
                testutils.AssertFileInTar(f.t, tar.NewReader(reader), adjustedFile)</span>
        }
}

// startContainer starts a container from the given config
func (f *dockerBuildFixture) startContainer(ctx context.Context, config *container.Config) k8s.ContainerID <span class="cov8" title="1">{
        resp, err := f.dcli.ContainerCreate(ctx, config, nil, nil, "")
        if err != nil </span><span class="cov0" title="0">{
                f.t.Fatalf("startContainer: %v", err)
        }</span>
        <span class="cov8" title="1">cID := resp.ID

        err = f.dcli.ContainerStart(ctx, cID, types.ContainerStartOptions{})
        if err != nil </span><span class="cov0" title="0">{
                f.t.Fatalf("startContainer: %v", err)
        }</span>

        <span class="cov8" title="1">result := k8s.ContainerID(cID)
        f.containerIDs = append(f.containerIDs, result)
        return result</span>
}

// Get a container config to run a container with a given command instead of
// the existing entrypoint. If cmd is nil, we run nothing.
func containerConfigRunCmd(imgRef reference.NamedTagged, cmd model.Cmd) *container.Config <span class="cov8" title="1">{
        config := containerConfig(imgRef)

        // In Docker, both the Entrypoint and the Cmd are used to determine what
        // process the container runtime uses, where Entrypoint takes precedence over
        // command. We set both here to ensure that we don't get weird results due
        // to inheritance.
        //
        // If cmd is nil, we use a fake cmd that does nothing.
        //
        // https://github.com/opencontainers/image-spec/blob/master/config.md#properties
        if cmd.Empty() </span><span class="cov8" title="1">{
                config.Cmd = model.ToShellCmd("# NOTE(nick): a fake cmd").Argv
        }</span> else<span class="cov0" title="0"> {
                config.Cmd = cmd.Argv
        }</span>
        <span class="cov8" title="1">config.Entrypoint = []string{}
        return config</span>
}

// Get a container config to run a container as-is.
func containerConfig(imgRef reference.NamedTagged) *container.Config <span class="cov8" title="1">{
        return &amp;container.Config{Image: imgRef.String()}
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package dockerignore

import (
        "os"
        "path/filepath"
        "strings"

        "github.com/docker/docker/builder/dockerignore"
        "github.com/docker/docker/pkg/fileutils"
)

type dockerPathMatcher struct {
        repoRoot string
        matcher  *fileutils.PatternMatcher
}

func (i dockerPathMatcher) Matches(f string, isDir bool) (bool, error) <span class="cov8" title="1">{
        rp, err := filepath.Rel(i.repoRoot, f)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">return i.matcher.Matches(rp)</span>
}

func (i dockerPathMatcher) AsMatchPatterns() []string <span class="cov8" title="1">{
        result := []string{}
        for _, p := range i.matcher.Patterns() </span><span class="cov8" title="1">{
                result = append(result, p.String())
        }</span>
        <span class="cov8" title="1">return result</span>
}

func NewDockerIgnoreTester(repoRoot string) (*dockerPathMatcher, error) <span class="cov8" title="1">{
        absRoot, err := filepath.Abs(repoRoot)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">patterns, err := readDockerignorePatterns(absRoot)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return NewDockerPatternMatcher(absRoot, patterns)</span>
}

func NewDockerPatternMatcher(repoRoot string, patterns []string) (*dockerPathMatcher, error) <span class="cov8" title="1">{
        absRoot, err := filepath.Abs(repoRoot)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">pm, err := fileutils.NewPatternMatcher(patterns)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;dockerPathMatcher{
                repoRoot: absRoot,
                matcher:  pm,
        }, nil</span>
}

func readDockerignorePatterns(repoRoot string) ([]string, error) <span class="cov8" title="1">{
        var excludes []string

        f, err := os.Open(filepath.Join(repoRoot, ".dockerignore"))
        switch </span>{
        case os.IsNotExist(err):<span class="cov8" title="1">
                return excludes, nil</span>
        case err != nil:<span class="cov0" title="0">
                return nil, err</span>
        }
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{ _ = f.Close() }</span>()

        <span class="cov8" title="1">return dockerignore.ReadAll(f)</span>
}

func DockerIgnoreTesterFromContents(repoRoot string, contents string) (*dockerPathMatcher, error) <span class="cov0" title="0">{
        patterns, err := dockerignore.ReadAll(strings.NewReader(contents))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return NewDockerPatternMatcher(repoRoot, patterns)</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package engine

import (
        "time"

        "github.com/windmilleng/tilt/internal/k8s"
        "github.com/windmilleng/tilt/internal/model"
        "github.com/windmilleng/tilt/internal/store"
        "k8s.io/api/core/v1"
)

type ErrorAction struct {
        Error error
}

func (ErrorAction) Action() {<span class="cov0" title="0">}</span>

func NewErrorAction(err error) ErrorAction <span class="cov8" title="1">{
        return ErrorAction{Error: err}
}</span>

type PodChangeAction struct {
        Pod *v1.Pod
}

func (PodChangeAction) Action() {<span class="cov0" title="0">}</span>

func NewPodChangeAction(pod *v1.Pod) PodChangeAction <span class="cov8" title="1">{
        return PodChangeAction{Pod: pod}
}</span>

type ServiceChangeAction struct {
        Service *v1.Service
}

func (ServiceChangeAction) Action() {<span class="cov0" title="0">}</span>

func NewServiceChangeAction(service *v1.Service) ServiceChangeAction <span class="cov8" title="1">{
        return ServiceChangeAction{Service: service}
}</span>

type PodLogAction struct {
        ManifestName model.ManifestName

        PodID k8s.PodID
        Log   []byte
}

func (PodLogAction) Action() {<span class="cov0" title="0">}</span>

type BuildCompleteAction struct {
        Result store.BuildResult
        Error  error
}

func (BuildCompleteAction) Action() {<span class="cov0" title="0">}</span>

func NewBuildCompleteAction(result store.BuildResult, err error) BuildCompleteAction <span class="cov8" title="1">{
        return BuildCompleteAction{
                Result: result,
                Error:  err,
        }
}</span>

type InitAction struct {
        WatchMounts bool
        Manifests   []model.Manifest
}

func (InitAction) Action() {<span class="cov0" title="0">}</span>

type ManifestReloadedAction struct {
        OldManifest model.Manifest
        NewManifest model.Manifest
        Error       *manifestErr
}

func (ManifestReloadedAction) Action() {<span class="cov0" title="0">}</span>

type BuildStartedAction struct {
        Manifest     model.Manifest
        StartTime    time.Time
        FilesChanged []string
}

func (BuildStartedAction) Action() {<span class="cov0" title="0">}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package engine

import (
        "context"

        "github.com/windmilleng/tilt/internal/store"

        "github.com/pkg/errors"
        "github.com/windmilleng/tilt/internal/build"
        "github.com/windmilleng/tilt/internal/k8s"
        "github.com/windmilleng/tilt/internal/logger"
        "github.com/windmilleng/tilt/internal/model"
)

type BuildAndDeployer interface {
        // BuildAndDeploy builds and deployed the specified manifest.
        //
        // Returns a BuildResult that expresses the output of the build.
        //
        // BuildResult can be used to construct a BuildState, which contains
        // the last successful build and the files changed since that build.
        BuildAndDeploy(ctx context.Context, manifest model.Manifest, currentState store.BuildState) (store.BuildResult, error)

        // PostProcessBuild gets any info about the build that we'll need for subsequent builds.
        // In general, we'll store this info ON the BuildAndDeployer that needs it.
        // Each implementation of PostProcessBuild is responsible for executing long-running steps async.
        PostProcessBuild(ctx context.Context, result, prevResult store.BuildResult)
}

type BuildOrder []BuildAndDeployer
type FallbackTester func(error) bool

// CompositeBuildAndDeployer tries to run each builder in order.  If a builder
// emits an error, it uses the FallbackTester to determine whether the error is
// critical enough to stop the whole pipeline, or to fallback to the next
// builder.
type CompositeBuildAndDeployer struct {
        builders       BuildOrder
        shouldFallBack FallbackTester
}

var _ BuildAndDeployer = &amp;CompositeBuildAndDeployer{}

func DefaultShouldFallBack() FallbackTester <span class="cov0" title="0">{
        return FallbackTester(shouldImageBuild)
}</span>

func NewCompositeBuildAndDeployer(builders BuildOrder, shouldFallBack FallbackTester) *CompositeBuildAndDeployer <span class="cov8" title="1">{
        return &amp;CompositeBuildAndDeployer{
                builders:       builders,
                shouldFallBack: shouldFallBack,
        }
}</span>

func (composite *CompositeBuildAndDeployer) BuildAndDeploy(ctx context.Context, manifest model.Manifest, currentState store.BuildState) (store.BuildResult, error) <span class="cov8" title="1">{
        var lastErr error
        for _, builder := range composite.builders </span><span class="cov8" title="1">{
                br, err := builder.BuildAndDeploy(ctx, manifest, currentState)
                if err == nil </span><span class="cov8" title="1">{
                        // TODO(maia): maybe this only needs to be called after certain builds?
                        // I.e. should be called after image build but not after a successful container build?
                        composite.PostProcessBuild(ctx, br, currentState.LastResult)
                        return br, err
                }</span>

                <span class="cov8" title="1">if !composite.shouldFallBack(err) </span><span class="cov8" title="1">{
                        return store.BuildResult{}, err
                }</span>
                <span class="cov8" title="1">logger.Get(ctx).Verbosef("falling back to next build and deploy method after error: %v", err)
                lastErr = err</span>
        }
        <span class="cov0" title="0">return store.BuildResult{}, lastErr</span>
}

// A permanent error indicates that the whole build pipeline needs to stop.
// It will never recover, even on subsequent rebuilds.
func isPermanentError(err error) bool <span class="cov8" title="1">{
        if _, ok := err.(*model.ValidateErr); ok </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">cause := errors.Cause(err)
        if cause == context.Canceled </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

// Given the error from our initial BuildAndDeploy attempt, shouldImageBuild determines
// whether we should fall back to an ImageBuild.
func shouldImageBuild(err error) bool <span class="cov8" title="1">{
        if _, ok := err.(*build.PathMappingErr); ok </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if isPermanentError(err) </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">if build.IsUserBuildFailure(err) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}

func (composite *CompositeBuildAndDeployer) PostProcessBuild(ctx context.Context, result, prevResult store.BuildResult) <span class="cov8" title="1">{
        for _, builder := range composite.builders </span><span class="cov8" title="1">{
                builder.PostProcessBuild(ctx, result, prevResult)
        }</span>
}

func DefaultBuildOrder(sbad *SyncletBuildAndDeployer, cbad *LocalContainerBuildAndDeployer, ibad *ImageBuildAndDeployer, env k8s.Env, mode UpdateMode) BuildOrder <span class="cov8" title="1">{
        if mode == UpdateModeImage || mode == UpdateModeNaive </span><span class="cov0" title="0">{
                return BuildOrder{ibad}
        }</span>

        <span class="cov8" title="1">if mode == UpdateModeContainer </span><span class="cov0" title="0">{
                return BuildOrder{cbad, ibad}
        }</span>

        <span class="cov8" title="1">if mode == UpdateModeSynclet </span><span class="cov0" title="0">{
                ibad.SetInjectSynclet(true)
                return BuildOrder{sbad, ibad}
        }</span>

        <span class="cov8" title="1">if env.IsLocalCluster() </span><span class="cov8" title="1">{
                return BuildOrder{cbad, ibad}
        }</span>

        <span class="cov8" title="1">ibad.SetInjectSynclet(true)
        return BuildOrder{sbad, ibad}</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package engine

import (
        "context"
        "sort"
        "time"

        "github.com/windmilleng/tilt/internal/logger"
        "github.com/windmilleng/tilt/internal/model"
        "github.com/windmilleng/tilt/internal/ospath"
        "github.com/windmilleng/tilt/internal/store"
        "github.com/windmilleng/tilt/internal/tiltfile"
)

type BuildController struct {
        b               BuildAndDeployer
        lastActionCount int
}

type buildEntry struct {
        ctx               context.Context
        manifest          model.Manifest
        buildState        store.BuildState
        filesChanged      []string
        firstBuild        bool
        needsConfigReload bool
}

func NewBuildController(b BuildAndDeployer) *BuildController <span class="cov8" title="1">{
        return &amp;BuildController{
                b:               b,
                lastActionCount: -1,
        }
}</span>

func (c *BuildController) needsBuild(ctx context.Context, st *store.Store) (buildEntry, bool) <span class="cov8" title="1">{
        state := st.RLockState()
        defer st.RUnlockState()

        if len(state.ManifestsToBuild) == 0 </span><span class="cov8" title="1">{
                return buildEntry{}, false
        }</span>

        <span class="cov8" title="1">if c.lastActionCount == state.BuildControllerActionCount </span><span class="cov8" title="1">{
                return buildEntry{}, false
        }</span>

        <span class="cov8" title="1">mn := state.ManifestsToBuild[0]
        c.lastActionCount = state.BuildControllerActionCount
        ms := state.ManifestStates[mn]
        manifest := ms.Manifest
        firstBuild := !ms.HasBeenBuilt

        filesChanged := make([]string, 0, len(ms.PendingFileChanges))
        for file, _ := range ms.PendingFileChanges </span><span class="cov8" title="1">{
                filesChanged = append(filesChanged, file)
        }</span>
        <span class="cov8" title="1">sort.Strings(filesChanged)

        buildState := store.NewBuildState(ms.LastBuild, filesChanged)

        needsConfigReload := ms.ConfigIsDirty

        // TODO(nick): This is...not great, because it modifies the build log in place.
        // A better solution would dispatch actions (like PodLogManager does) so that
        // they go thru the state loop and immediately update in the UX.
        ctx = logger.CtxWithForkedOutput(ctx, ms.CurrentBuildLog)

        return buildEntry{
                ctx:               ctx,
                manifest:          manifest,
                firstBuild:        firstBuild,
                buildState:        buildState,
                filesChanged:      filesChanged,
                needsConfigReload: needsConfigReload,
        }, true</span>
}

func (c *BuildController) OnChange(ctx context.Context, st *store.Store) <span class="cov8" title="1">{
        entry, ok := c.needsBuild(ctx, st)
        if !ok </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                if entry.needsConfigReload </span><span class="cov8" title="1">{
                        newManifest, err := getNewManifestFromTiltfile(entry.ctx, entry.manifest.Name)
                        st.Dispatch(ManifestReloadedAction{
                                OldManifest: entry.manifest,
                                NewManifest: newManifest,
                                Error:       err,
                        })
                        return
                }</span>

                <span class="cov8" title="1">st.Dispatch(BuildStartedAction{
                        Manifest:     entry.manifest,
                        StartTime:    time.Now(),
                        FilesChanged: entry.filesChanged,
                })
                c.logBuildEntry(entry.ctx, entry)
                result, err := c.b.BuildAndDeploy(entry.ctx, entry.manifest, entry.buildState)
                st.Dispatch(NewBuildCompleteAction(result, err))</span>
        }()
}

func (c *BuildController) logBuildEntry(ctx context.Context, entry buildEntry) <span class="cov8" title="1">{
        firstBuild := entry.firstBuild
        manifest := entry.manifest
        buildState := entry.buildState

        l := logger.Get(ctx)
        if firstBuild </span><span class="cov8" title="1">{
                p := logger.Blue(l).Sprintf("──┤ Building: ")
                s := logger.Blue(l).Sprintf(" ├──────────────────────────────────────────────")
                l.Infof("%s%s%s", p, manifest.Name, s)
        }</span> else<span class="cov8" title="1"> {
                changedFiles := buildState.FilesChanged()
                var changedPathsToPrint []string
                if len(changedFiles) &gt; maxChangedFilesToPrint </span><span class="cov0" title="0">{
                        changedPathsToPrint = append(changedPathsToPrint, changedFiles[:maxChangedFilesToPrint]...)
                        changedPathsToPrint = append(changedPathsToPrint, "...")
                }</span> else<span class="cov8" title="1"> {
                        changedPathsToPrint = changedFiles
                }</span>

                <span class="cov8" title="1">if len(changedFiles) &gt; 0 </span><span class="cov8" title="1">{
                        p := logger.Green(l).Sprintf("\n%d changed: ", len(changedFiles))
                        l.Infof("%s%v\n", p, ospath.TryAsCwdChildren(changedPathsToPrint))
                }</span>

                <span class="cov8" title="1">rp := logger.Blue(l).Sprintf("──┤ Rebuilding: ")
                rs := logger.Blue(l).Sprintf(" ├────────────────────────────────────────────")
                l.Infof("%s%s%s", rp, manifest.Name, rs)</span>
        }
}

func getNewManifestFromTiltfile(ctx context.Context, name model.ManifestName) (model.Manifest, *manifestErr) <span class="cov8" title="1">{
        // Sends any output to the CurrentBuildLog
        writer := logger.Get(ctx).Writer(logger.InfoLvl)
        t, err := tiltfile.Load(tiltfile.FileName, writer)
        if err != nil </span><span class="cov8" title="1">{
                return model.Manifest{}, manifestErrf(err.Error())
        }</span>
        <span class="cov8" title="1">newManifests, err := t.GetManifestConfigs(string(name))
        if err != nil </span><span class="cov0" title="0">{
                return model.Manifest{}, manifestErrf(err.Error())
        }</span>
        <span class="cov8" title="1">if len(newManifests) != 1 </span><span class="cov0" title="0">{
                return model.Manifest{}, manifestErrf("Expected there to be 1 manifest for %s, got %d", name, len(newManifests))
        }</span>
        <span class="cov8" title="1">newManifest := newManifests[0]

        return newManifest, nil</span>
}

var _ store.Subscriber = &amp;BuildController{}
</pre>
		
		<pre class="file" id="file17" style="display: none">package engine

import (
        "context"
        "fmt"
        "sync"

        "github.com/docker/distribution/reference"
        "github.com/opentracing/opentracing-go"
        "github.com/pkg/errors"
        "github.com/windmilleng/tilt/internal/docker"
        "github.com/windmilleng/tilt/internal/k8s"
        "github.com/windmilleng/tilt/internal/logger"
        "github.com/windmilleng/tilt/internal/store"
)

// Looks up containers after they've been deployed.
type DeployDiscovery struct {
        kCli       k8s.Client
        store      *store.Store
        deployInfo map[docker.ImgNameAndTag]*deployInfoEntry
        mu         sync.Mutex
}

func NewDeployDiscovery(kCli k8s.Client, store *store.Store) *DeployDiscovery <span class="cov8" title="1">{
        return &amp;DeployDiscovery{
                kCli:       kCli,
                deployInfo: make(map[docker.ImgNameAndTag]*deployInfoEntry),
                store:      store,
        }
}</span>

func (d *DeployDiscovery) EnsureDeployInfoFetchStarted(ctx context.Context, img reference.NamedTagged, ns k8s.Namespace) <span class="cov8" title="1">{
        d.mu.Lock()
        defer d.mu.Unlock()

        _, ok := d.deployInfo[docker.ToImgNameAndTag(img)]
        if !ok </span><span class="cov8" title="1">{
                deployInfo := newDeployInfoEntry()
                d.deployInfo[docker.ToImgNameAndTag(img)] = deployInfo

                go func() </span><span class="cov8" title="1">{
                        err := d.populateDeployInfo(ctx, img, ns, deployInfo)
                        if err != nil </span><span class="cov8" title="1">{
                                // There's a variety of reasons why we might not be able to get the deploy info.
                                // The cluster could be in a transient bad state, or the pod
                                // could be in a crash loop because the user wrote some code that
                                // segfaults. Don't worry too much about it, we'll fall back to an image build.
                                logger.Get(ctx).Debugf("failed to get deployInfo: %v", err)
                        }</span>
                }()
        }
}

func (d *DeployDiscovery) DeployInfoForImageBlocking(ctx context.Context, img reference.NamedTagged) (DeployInfo, error) <span class="cov8" title="1">{
        d.mu.Lock()
        deployInfo := d.deployInfo[docker.ToImgNameAndTag(img)]
        d.mu.Unlock()

        if deployInfo == nil </span><span class="cov8" title="1">{
                return DeployInfo{}, nil
        }</span>

        <span class="cov8" title="1">deployInfo.waitUntilReady(ctx)
        return deployInfo.DeployInfo, deployInfo.err</span>
}

// Returns the deploy info that was forgotten, if any.
func (d *DeployDiscovery) ForgetImage(img reference.NamedTagged) DeployInfo <span class="cov8" title="1">{
        d.mu.Lock()
        defer d.mu.Unlock()
        key := docker.ToImgNameAndTag(img)
        deployInfo := d.deployInfo[key]
        delete(d.deployInfo, key)
        if deployInfo == nil </span><span class="cov0" title="0">{
                return DeployInfo{}
        }</span>
        <span class="cov8" title="1">return deployInfo.DeployInfo</span>
}

// TODO(nick): Delete this method. Ideally, the state management that this function
// does should be part of the handlePodEvent state reducer, and this class will
// simply manage control flow (i.e., closing the ready channel when the container is ready.)
func (d *DeployDiscovery) populateDeployInfo(ctx context.Context, image reference.NamedTagged, ns k8s.Namespace, info *deployInfoEntry) (err error) <span class="cov8" title="1">{
        span, ctx := opentracing.StartSpanFromContext(ctx, "DeployDiscovery-populateDeployInfo")
        defer span.Finish()

        defer func() </span><span class="cov8" title="1">{
                info.err = err
                info.markReady()
        }</span>()

        <span class="cov8" title="1">nID, pID, cID, cName, err := podInfoForImage(ctx, d.kCli, image, ns)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">info.nodeID = nID
        info.podID = pID
        info.containerID = cID
        info.containerName = cName

        return nil</span>
}

func podInfoForImage(ctx context.Context, kCli k8s.Client, image reference.NamedTagged, ns k8s.Namespace) (k8s.NodeID, k8s.PodID, k8s.ContainerID, k8s.ContainerName, error) <span class="cov8" title="1">{
        // get pod running the image we just deployed.
        //
        // We fetch the pod by the NamedTagged, to ensure we get a pod
        // in the most recent Deployment, and not the pods in the process
        // of being terminated from previous Deployments.
        pods, err := kCli.PollForPodsWithImage(
                ctx, image, ns,
                []k8s.LabelPair{TiltRunLabel()}, podPollTimeoutSynclet)
        if err != nil </span><span class="cov8" title="1">{
                return "", "", "", "", errors.Wrapf(err, "PodsWithImage (img = %s)", image)
        }</span>

        // If there's more than one pod, two possible things could be happening:
        // 1) K8s is in a transition state.
        // 2) The user is running a configuration where they want multiple replicas
        //    of the same pod (e.g., a cockroach developer testing primary/replica).
        // If this happens, don't bother populating the deployInfo.
        // We want to fall back to image builds rather than managing the complexity
        // of multiple replicas.
        <span class="cov8" title="1">if len(pods) != 1 </span><span class="cov0" title="0">{
                logger.Get(ctx).Debugf("Found too many pods (%d), skipping container updates: %s", len(pods), image)
                return "", "", "", "", nil
        }</span>

        <span class="cov8" title="1">pod := &amp;(pods[0])
        pID := k8s.PodIDFromPod(pod)
        nID := k8s.NodeIDFromPod(pod)

        // Make sure that the deployed image is ready and not crashlooping.
        cStatus, err := k8s.WaitForContainerReady(ctx, kCli, pod, image)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", "", "", errors.Wrapf(err, "WaitForContainerReady (pod = %s)", pID)
        }</span>

        <span class="cov8" title="1">cID, err := k8s.ContainerIDFromContainerStatus(cStatus)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", "", "", errors.Wrapf(err, "populateDeployInfo")
        }</span> else<span class="cov8" title="1"> if cID == "" </span><span class="cov0" title="0">{
                return "", "", "", "", fmt.Errorf("missing container ID: %+v", cStatus)
        }</span>

        <span class="cov8" title="1">cName := k8s.ContainerNameFromContainerStatus(cStatus)

        return nID, pID, cID, cName, nil</span>
}

type DeployInfo struct {
        nodeID        k8s.NodeID
        podID         k8s.PodID
        containerID   k8s.ContainerID
        containerName k8s.ContainerName
}

func (d DeployInfo) Empty() bool <span class="cov8" title="1">{
        return d == DeployInfo{}
}</span>

type deployInfoEntry struct {
        DeployInfo

        ready chan struct{} // Close this channel when the DeployInfo is populated
        err   error         // error encountered when populating (if any)
}

func newDeployInfoEntry() *deployInfoEntry <span class="cov8" title="1">{
        return &amp;deployInfoEntry{ready: make(chan struct{})}
}</span>

func (di *deployInfoEntry) markReady() <span class="cov8" title="1">{ close(di.ready) }</span>
func (di *deployInfoEntry) waitUntilReady(ctx context.Context) <span class="cov8" title="1">{
        select </span>{
        case &lt;-di.ready:<span class="cov8" title="1"></span>
        case &lt;-ctx.Done():<span class="cov0" title="0"></span>
        }
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package engine

import (
        context "context"
        "fmt"
        "time"

        "github.com/windmilleng/tilt/internal/store"

        "github.com/pkg/errors"

        "github.com/docker/distribution/reference"
        opentracing "github.com/opentracing/opentracing-go"
        "github.com/windmilleng/tilt/internal/build"
        "github.com/windmilleng/tilt/internal/ignore"
        "github.com/windmilleng/tilt/internal/k8s"
        "github.com/windmilleng/tilt/internal/model"
        "github.com/windmilleng/tilt/internal/synclet/sidecar"
        "github.com/windmilleng/wmclient/pkg/analytics"
        "k8s.io/api/core/v1"
)

var _ BuildAndDeployer = &amp;ImageBuildAndDeployer{}

type ImageBuildAndDeployer struct {
        b             build.ImageBuilder
        k8sClient     k8s.Client
        env           k8s.Env
        analytics     analytics.Analytics
        updateMode    UpdateMode
        injectSynclet bool
}

func NewImageBuildAndDeployer(b build.ImageBuilder, k8sClient k8s.Client, env k8s.Env, analytics analytics.Analytics, updateMode UpdateMode) *ImageBuildAndDeployer <span class="cov8" title="1">{
        return &amp;ImageBuildAndDeployer{
                b:          b,
                k8sClient:  k8sClient,
                env:        env,
                analytics:  analytics,
                updateMode: updateMode,
        }
}</span>

// Turn on synclet injection. Should be called before any builds.
func (ibd *ImageBuildAndDeployer) SetInjectSynclet(inject bool) <span class="cov8" title="1">{
        ibd.injectSynclet = inject
}</span>

func (ibd *ImageBuildAndDeployer) BuildAndDeploy(ctx context.Context, manifest model.Manifest, state store.BuildState) (br store.BuildResult, err error) <span class="cov8" title="1">{
        span, ctx := opentracing.StartSpanFromContext(ctx, "daemon-ImageBuildAndDeployer-BuildAndDeploy")
        defer span.Finish()

        startTime := time.Now()
        defer func() </span><span class="cov8" title="1">{
                incremental := "0"
                if state.HasImage() </span><span class="cov8" title="1">{
                        incremental = "1"
                }</span>
                <span class="cov8" title="1">tags := map[string]string{"incremental": incremental}
                ibd.analytics.Timer("build.image", time.Since(startTime), tags)</span>
        }()

        // TODO - currently hardcoded that we have 2 pipeline steps. This might end up being dynamic? drop it from the output?
        <span class="cov8" title="1">ps := build.NewPipelineState(ctx, 2)
        defer func() </span><span class="cov8" title="1">{ ps.End(ctx, err) }</span>()

        <span class="cov8" title="1">err = manifest.Validate()
        if err != nil </span><span class="cov0" title="0">{
                return store.BuildResult{}, err
        }</span>

        <span class="cov8" title="1">ref, err := ibd.build(ctx, manifest, state, ps)
        if err != nil </span><span class="cov0" title="0">{
                return store.BuildResult{}, err
        }</span>

        <span class="cov8" title="1">k8sEntities, namespace, err := ibd.deploy(ctx, ps, manifest, ref)
        if err != nil </span><span class="cov0" title="0">{
                return store.BuildResult{}, err
        }</span>

        <span class="cov8" title="1">return store.BuildResult{
                Image:     ref,
                Namespace: namespace,
                Entities:  k8sEntities,
        }, nil</span>
}

func (ibd *ImageBuildAndDeployer) build(ctx context.Context, manifest model.Manifest, state store.BuildState, ps *build.PipelineState) (reference.NamedTagged, error) <span class="cov8" title="1">{
        var n reference.NamedTagged

        name := manifest.DockerRef
        if manifest.IsStaticBuild() </span><span class="cov0" title="0">{
                ps.StartPipelineStep(ctx, "Building Dockerfile: [%s]", name)
                defer ps.EndPipelineStep(ctx)

                df := build.Dockerfile(manifest.StaticDockerfile)
                ref, err := ibd.b.BuildDockerfile(ctx, ps, name, df, manifest.StaticBuildPath, ignore.CreateBuildContextFilter(manifest))

                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">n = ref</span>

        } else<span class="cov8" title="1"> if !state.HasImage() || ibd.updateMode == UpdateModeNaive </span><span class="cov8" title="1">{
                // No existing image to build off of, need to build from scratch
                ps.StartPipelineStep(ctx, "Building from scratch: [%s]", name)
                defer ps.EndPipelineStep(ctx)

                df := build.Dockerfile(manifest.BaseDockerfile)
                steps := manifest.Steps
                ref, err := ibd.b.BuildImageFromScratch(ctx, ps, name, df, manifest.Mounts, ignore.CreateBuildContextFilter(manifest), steps, manifest.Entrypoint)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">n = ref</span>

        } else<span class="cov8" title="1"> {
                changed, err := state.FilesChangedSinceLastResultImage()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">cf, err := build.FilesToPathMappings(changed, manifest.Mounts)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">ps.StartPipelineStep(ctx, "Building from existing: [%s]", name)
                defer ps.EndPipelineStep(ctx)

                steps := manifest.Steps
                ref, err := ibd.b.BuildImageFromExisting(ctx, ps, state.LastResult.Image, cf, ignore.CreateBuildContextFilter(manifest), steps)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">n = ref</span>
        }

        <span class="cov8" title="1">if !ibd.canSkipPush() </span><span class="cov8" title="1">{
                var err error
                n, err = ibd.b.PushImage(ctx, n, ps.Writer(ctx))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">return n, nil</span>
}

// Returns: the entities deployed and the namespace of the pod with the given image name/tag.
func (ibd *ImageBuildAndDeployer) deploy(ctx context.Context, ps *build.PipelineState, manifest model.Manifest, n reference.NamedTagged) ([]k8s.K8sEntity, k8s.Namespace, error) <span class="cov8" title="1">{
        ps.StartPipelineStep(ctx, "Deploying")
        defer ps.EndPipelineStep(ctx)

        ps.StartBuildStep(ctx, "Parsing Kubernetes config YAML")

        // TODO(nick): The parsed YAML should probably be a part of the model?
        // It doesn't make much sense to re-parse it and inject labels on every deploy.
        entities, err := k8s.ParseYAMLFromString(manifest.K8sYaml)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", err
        }</span>

        <span class="cov8" title="1">didReplace := false
        newK8sEntities := []k8s.K8sEntity{}
        namespace := k8s.DefaultNamespace
        for _, e := range entities </span><span class="cov8" title="1">{
                e, err = k8s.InjectLabels(e, []k8s.LabelPair{TiltRunLabel(), {Key: ManifestNameLabel, Value: manifest.Name.String()}})
                if err != nil </span><span class="cov0" title="0">{
                        return nil, "", errors.Wrap(err, "deploy")
                }</span>

                // For development, image pull policy should never be set to "Always",
                // even if it might make sense to use "Always" in prod. People who
                // set "Always" for development are shooting their own feet.
                <span class="cov8" title="1">e, err = k8s.InjectImagePullPolicy(e, v1.PullIfNotPresent)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, "", err
                }</span>

                // When working with a local k8s cluster, we set the pull policy to Never,
                // to ensure that k8s fails hard if the image is missing from docker.
                <span class="cov8" title="1">policy := v1.PullIfNotPresent
                if ibd.canSkipPush() </span><span class="cov8" title="1">{
                        policy = v1.PullNever
                }</span>
                <span class="cov8" title="1">e, replaced, err := k8s.InjectImageDigest(e, n, policy)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, "", err
                }</span>
                <span class="cov8" title="1">if replaced </span><span class="cov8" title="1">{
                        didReplace = true
                        namespace = e.Namespace()

                        if ibd.injectSynclet </span><span class="cov8" title="1">{
                                e, replaced, err = sidecar.InjectSyncletSidecar(e, n)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, "", err
                                }</span> else<span class="cov8" title="1"> if !replaced </span><span class="cov0" title="0">{
                                        return nil, "", fmt.Errorf("Could not inject synclet: %v", e)
                                }</span>
                        }
                }

                <span class="cov8" title="1">newK8sEntities = append(newK8sEntities, e)</span>
        }

        <span class="cov8" title="1">if !didReplace </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("Docker image missing from yaml: %s", manifest.DockerRef)
        }</span>

        <span class="cov8" title="1">err = ibd.k8sClient.Upsert(ctx, newK8sEntities)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", err
        }</span>
        <span class="cov8" title="1">return newK8sEntities, namespace, nil</span>
}

// If we're using docker-for-desktop as our k8s backend,
// we don't need to push to the central registry.
// The k8s will use the image already available
// in the local docker daemon.
func (ibd *ImageBuildAndDeployer) canSkipPush() bool <span class="cov8" title="1">{
        return ibd.env.IsLocalCluster()
}</span>

func (ibd *ImageBuildAndDeployer) PostProcessBuild(ctx context.Context, result, previousResult store.BuildResult) <span class="cov8" title="1">{
        // No-op: ImageBuildAndDeployer doesn't currently need any extra info for a given build result.
        return
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package engine

import (
        "context"
        "fmt"
        "time"

        "github.com/opentracing/opentracing-go"
        "github.com/pkg/errors"

        "github.com/windmilleng/tilt/internal/build"
        "github.com/windmilleng/tilt/internal/ignore"
        "github.com/windmilleng/tilt/internal/logger"
        "github.com/windmilleng/tilt/internal/model"
        "github.com/windmilleng/tilt/internal/store"
        "github.com/windmilleng/wmclient/pkg/analytics"
)

var _ BuildAndDeployer = &amp;LocalContainerBuildAndDeployer{}

const podPollTimeoutLocal = time.Second * 3

type LocalContainerBuildAndDeployer struct {
        cu        *build.ContainerUpdater
        analytics analytics.Analytics
        dd        *DeployDiscovery
}

func NewLocalContainerBuildAndDeployer(cu *build.ContainerUpdater,
        analytics analytics.Analytics, dd *DeployDiscovery) *LocalContainerBuildAndDeployer <span class="cov8" title="1">{
        return &amp;LocalContainerBuildAndDeployer{
                cu:        cu,
                analytics: analytics,
                dd:        dd,
        }
}</span>

func (cbd *LocalContainerBuildAndDeployer) BuildAndDeploy(ctx context.Context, manifest model.Manifest, state store.BuildState) (result store.BuildResult, err error) <span class="cov8" title="1">{
        span, ctx := opentracing.StartSpanFromContext(ctx, "LocalContainerBuildAndDeployer-BuildAndDeploy")
        span.SetTag("manifest", manifest.Name.String())
        defer span.Finish()

        startTime := time.Now()
        defer func() </span><span class="cov8" title="1">{
                cbd.analytics.Timer("build.container", time.Since(startTime), nil)
        }</span>()

        // TODO(maia): proper output for this stuff

        // TODO(maia): put manifest.Validate() upstream if we're gonna want to call it regardless
        // of implementation of BuildAndDeploy?
        <span class="cov8" title="1">err = manifest.Validate()
        if err != nil </span><span class="cov0" title="0">{
                return store.BuildResult{}, err
        }</span>

        // LocalContainerBuildAndDeployer doesn't support initial build
        <span class="cov8" title="1">if state.IsEmpty() </span><span class="cov8" title="1">{
                return store.BuildResult{}, fmt.Errorf("prev. build state is empty; container build does not support initial deploy")
        }</span>

        <span class="cov8" title="1">if manifest.IsStaticBuild() </span><span class="cov0" title="0">{
                return store.BuildResult{}, fmt.Errorf("container build does not support static dockerfiles")
        }</span>

        // Otherwise, manifest has already been deployed; try to update in the running container
        <span class="cov8" title="1">deployInfo, err := cbd.dd.DeployInfoForImageBlocking(ctx, state.LastResult.Image)
        if err != nil </span><span class="cov0" title="0">{
                return store.BuildResult{}, errors.Wrap(err, "deploy info fetch failed")
        }</span> else<span class="cov8" title="1"> if deployInfo.Empty() </span><span class="cov0" title="0">{
                return store.BuildResult{}, fmt.Errorf("no deploy info")
        }</span>

        <span class="cov8" title="1">cf, err := build.FilesToPathMappings(state.FilesChanged(), manifest.Mounts)
        if err != nil </span><span class="cov0" title="0">{
                return store.BuildResult{}, err
        }</span>
        <span class="cov8" title="1">logger.Get(ctx).Infof("  → Updating container…")
        boiledSteps, err := build.BoilSteps(manifest.Steps, cf)
        if err != nil </span><span class="cov0" title="0">{
                return store.BuildResult{}, err
        }</span>

        // TODO - use PipelineState here when we actually do pipeline output for container builds
        <span class="cov8" title="1">writer := logger.Get(ctx).Writer(logger.InfoLvl)

        err = cbd.cu.UpdateInContainer(ctx, deployInfo.containerID, cf, ignore.CreateBuildContextFilter(manifest), boiledSteps, writer)
        if err != nil </span><span class="cov8" title="1">{
                return store.BuildResult{}, err
        }</span>
        <span class="cov8" title="1">logger.Get(ctx).Infof("  → Container updated!")

        res := state.LastResult.ShallowCloneForContainerUpdate(state.FilesChangedSet)
        res.ContainerID = deployInfo.containerID // the container we deployed on top of
        return res, nil</span>
}

func (cbd *LocalContainerBuildAndDeployer) PostProcessBuild(ctx context.Context, result, previousResult store.BuildResult) <span class="cov8" title="1">{
        span, ctx := opentracing.StartSpanFromContext(ctx, "LocalContainerBuildAndDeployer-PostProcessBuild")
        span.SetTag("image", result.Image.String())
        defer span.Finish()

        if previousResult.HasImage() &amp;&amp; (!result.HasImage() || result.Image != previousResult.Image) </span><span class="cov8" title="1">{
                _ = cbd.dd.ForgetImage(previousResult.Image)
        }</span>

        <span class="cov8" title="1">if !result.HasImage() </span><span class="cov0" title="0">{
                // This is normal condition if the previous build failed.
                return
        }</span>

        <span class="cov8" title="1">cbd.dd.EnsureDeployInfoFetchStarted(ctx, result.Image, result.Namespace)</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package engine

import (
        "fmt"

        k8s "github.com/windmilleng/tilt/internal/k8s"
)

type UpdateMode string

// A type to bind to flag values that need validation.
type UpdateModeFlag UpdateMode

var (
        // Auto-pick the build mode based on
        UpdateModeAuto UpdateMode = "auto"

        // Only do image builds
        UpdateModeImage UpdateMode = "image"

        // Only do image builds from scratch
        UpdateModeNaive UpdateMode = "naive"

        // Deploy a synclet to make container updates faster
        UpdateModeSynclet UpdateMode = "synclet"

        // Update containers in-place. This mode only works with DockerForDesktop and Minikube.
        // If you try to use this mode with a different K8s cluster type, we will return an error
        UpdateModeContainer UpdateMode = "container"
)

var AllUpdateModes = []UpdateMode{
        UpdateModeAuto,
        UpdateModeImage,
        UpdateModeNaive,
        UpdateModeSynclet,
        UpdateModeContainer,
}

func ProvideUpdateMode(flag UpdateModeFlag, env k8s.Env) (UpdateMode, error) <span class="cov8" title="1">{
        valid := false
        for _, mode := range AllUpdateModes </span><span class="cov8" title="1">{
                if mode == UpdateMode(flag) </span><span class="cov8" title="1">{
                        valid = true
                }</span>
        }

        <span class="cov8" title="1">if !valid </span><span class="cov0" title="0">{
                return "", fmt.Errorf("Unknown update mode %q. Valid Values: %v", flag, AllUpdateModes)
        }</span>

        <span class="cov8" title="1">mode := UpdateMode(flag)
        if mode == UpdateModeContainer &amp;&amp; !env.IsLocalCluster() </span><span class="cov0" title="0">{
                return "", fmt.Errorf("Update mode %q is only valid with local clusters like Minikube or DockerForDesktop", flag)
        }</span>

        <span class="cov8" title="1">return mode, nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package engine

import (
        "github.com/windmilleng/tilt/internal/k8s"
        "github.com/windmilleng/tilt/internal/model"
)

func ParseYAMLFromManifests(manifests ...model.Manifest) ([]k8s.K8sEntity, error) <span class="cov0" title="0">{
        allEntities := []k8s.K8sEntity{}
        for _, m := range manifests </span><span class="cov0" title="0">{
                entities, err := k8s.ParseYAMLFromString(m.K8sYaml)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">allEntities = append(allEntities, entities...)</span>
        }
        <span class="cov0" title="0">return allEntities, nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package engine

import (
        "github.com/google/uuid"
        k8s "github.com/windmilleng/tilt/internal/k8s"
)

const TiltRunIDLabel = "tilt-runid"

var TiltRunID = uuid.New().String()

const ManifestNameLabel = "tilt-manifest"

func TiltRunLabel() k8s.LabelPair <span class="cov8" title="1">{
        return k8s.LabelPair{
                Key:   TiltRunIDLabel,
                Value: TiltRunID,
        }
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package engine

import (
        "context"
        "fmt"

        "github.com/windmilleng/tilt/internal/store"

        "github.com/windmilleng/tilt/internal/k8s"
        "k8s.io/api/core/v1"
)

func makePodWatcher(ctx context.Context, kCli k8s.Client, st *store.Store) error <span class="cov0" title="0">{
        ch, err := kCli.WatchPods(ctx, []k8s.LabelPair{TiltRunLabel()})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">go dispatchPodChangesLoop(ctx, ch, st)

        return nil</span>
}

func dispatchPodChangesLoop(ctx context.Context, ch &lt;-chan *v1.Pod, st *store.Store) <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                select </span>{
                case pod, ok := &lt;-ch:<span class="cov8" title="1">
                        if !ok </span><span class="cov8" title="1">{
                                return
                        }</span>
                        <span class="cov8" title="1">st.Dispatch(NewPodChangeAction(pod))</span>
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        return</span>
                }
        }
}

// copied from https://github.com/kubernetes/kubernetes/blob/aedeccda9562b9effe026bb02c8d3c539fc7bb77/pkg/kubectl/resource_printer.go#L692-L764
// to match the status column of `kubectl get pods`
func podStatusToString(pod v1.Pod) string <span class="cov8" title="1">{
        reason := string(pod.Status.Phase)
        if pod.Status.Reason != "" </span><span class="cov0" title="0">{
                reason = pod.Status.Reason
        }</span>

        <span class="cov8" title="1">initializing := false
        for i := range pod.Status.InitContainerStatuses </span><span class="cov0" title="0">{
                container := pod.Status.InitContainerStatuses[i]
                switch </span>{
                case container.State.Terminated != nil &amp;&amp; container.State.Terminated.ExitCode == 0:<span class="cov0" title="0">
                        continue</span>
                case container.State.Terminated != nil:<span class="cov0" title="0">
                        // initialization is failed
                        if len(container.State.Terminated.Reason) == 0 </span><span class="cov0" title="0">{
                                if container.State.Terminated.Signal != 0 </span><span class="cov0" title="0">{
                                        reason = fmt.Sprintf("Init:Signal:%d", container.State.Terminated.Signal)
                                }</span> else<span class="cov0" title="0"> {
                                        reason = fmt.Sprintf("Init:ExitCode:%d", container.State.Terminated.ExitCode)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                reason = "Init:" + container.State.Terminated.Reason
                        }</span>
                        <span class="cov0" title="0">initializing = true</span>
                case container.State.Waiting != nil &amp;&amp; len(container.State.Waiting.Reason) &gt; 0 &amp;&amp; container.State.Waiting.Reason != "PodInitializing":<span class="cov0" title="0">
                        reason = "Init:" + container.State.Waiting.Reason
                        initializing = true</span>
                default:<span class="cov0" title="0">
                        reason = fmt.Sprintf("Init:%d/%d", i, len(pod.Spec.InitContainers))
                        initializing = true</span>
                }
                <span class="cov0" title="0">break</span>
        }
        <span class="cov8" title="1">if !initializing </span><span class="cov8" title="1">{
                for i := len(pod.Status.ContainerStatuses) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                        container := pod.Status.ContainerStatuses[i]

                        if container.State.Waiting != nil &amp;&amp; container.State.Waiting.Reason != "" </span><span class="cov0" title="0">{
                                reason = container.State.Waiting.Reason
                        }</span> else<span class="cov8" title="1"> if container.State.Terminated != nil &amp;&amp; container.State.Terminated.Reason != "" </span><span class="cov0" title="0">{
                                reason = container.State.Terminated.Reason
                        }</span> else<span class="cov8" title="1"> if container.State.Terminated != nil &amp;&amp; container.State.Terminated.Reason == "" </span><span class="cov0" title="0">{
                                if container.State.Terminated.Signal != 0 </span><span class="cov0" title="0">{
                                        reason = fmt.Sprintf("Signal:%d", container.State.Terminated.Signal)
                                }</span> else<span class="cov0" title="0"> {
                                        reason = fmt.Sprintf("ExitCode:%d", container.State.Terminated.ExitCode)
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return reason</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package engine

import (
        "context"
        "fmt"
        "io"
        "strings"

        "github.com/windmilleng/tilt/internal/k8s"
        "github.com/windmilleng/tilt/internal/logger"
        "github.com/windmilleng/tilt/internal/model"
        "github.com/windmilleng/tilt/internal/store"
        "k8s.io/api/core/v1"
)

// Collects logs from deployed containers.
type PodLogManager struct {
        kClient k8s.Client

        watches map[podLogKey]PodLogWatch
}

func NewPodLogManager(kClient k8s.Client) *PodLogManager <span class="cov8" title="1">{
        return &amp;PodLogManager{
                kClient: kClient,
                watches: make(map[podLogKey]PodLogWatch),
        }
}</span>

// Diff the current watches against the state store of what
// we're supposed to be watching, returning the changes
// we need to make.
func (m *PodLogManager) diff(ctx context.Context, st *store.Store) (setup []PodLogWatch, teardown []PodLogWatch) <span class="cov8" title="1">{
        state := st.RLockState()
        defer st.RUnlockState()

        // If we're not watching the mounts, then don't bother watching logs.
        if !state.WatchMounts </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">stateWatches := make(map[podLogKey]bool, 0)
        for _, ms := range state.ManifestStates </span><span class="cov8" title="1">{
                pod := ms.Pod
                if pod.PodID == "" || pod.ContainerName == "" || pod.ContainerID == "" </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Only fetch pod logs if the pod is running.
                // Otherwise it will reject our connection.
                <span class="cov8" title="1">if ms.Pod.Phase != v1.PodRunning </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Key the log watcher by the container id, so we auto-restart the
                // watching if the container crashes.
                <span class="cov8" title="1">key := podLogKey{
                        podID: pod.PodID,
                        cID:   pod.ContainerID,
                }
                stateWatches[key] = true

                _, isActive := m.watches[key]
                if isActive </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">ctx, cancel := context.WithCancel(ctx)
                w := PodLogWatch{
                        ctx:       ctx,
                        cancel:    cancel,
                        name:      ms.Manifest.Name,
                        podID:     pod.PodID,
                        cID:       pod.ContainerID,
                        cName:     pod.ContainerName,
                        namespace: pod.Namespace,
                }
                m.watches[key] = w
                setup = append(setup, w)</span>
        }

        <span class="cov8" title="1">for key, value := range m.watches </span><span class="cov8" title="1">{
                _, inState := stateWatches[key]
                if !inState </span><span class="cov8" title="1">{
                        delete(m.watches, key)
                        teardown = append(teardown, value)
                }</span>
        }

        <span class="cov8" title="1">return setup, teardown</span>
}

func (m *PodLogManager) OnChange(ctx context.Context, st *store.Store) <span class="cov8" title="1">{
        setup, teardown := m.diff(ctx, st)
        for _, watch := range teardown </span><span class="cov8" title="1">{
                watch.cancel()
        }</span>

        <span class="cov8" title="1">for _, watch := range setup </span><span class="cov8" title="1">{
                go m.consumeLogs(watch, st)
        }</span>
}

func (m *PodLogManager) consumeLogs(watch PodLogWatch, st *store.Store) <span class="cov8" title="1">{
        name := watch.name
        pID := watch.podID
        containerName := watch.cName
        ns := watch.namespace
        readCloser, err := m.kClient.ContainerLogs(watch.ctx, pID, containerName, ns)
        if err != nil </span><span class="cov8" title="1">{
                logger.Get(watch.ctx).Infof("Error streaming %s logs: %v", name, err)
                return
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                _ = readCloser.Close()
        }</span>()

        <span class="cov8" title="1">logWriter := logger.Get(watch.ctx).Writer(logger.InfoLvl)
        prefix := logPrefix(name.String())
        prefixLogWriter := logger.NewPrefixedWriter(prefix, logWriter)
        actionWriter := PodLogActionWriter{
                store:        st,
                manifestName: name,
                podID:        pID,
        }
        multiWriter := io.MultiWriter(prefixLogWriter, actionWriter)

        _, err = io.Copy(multiWriter, readCloser)
        if err != nil </span><span class="cov0" title="0">{
                logger.Get(watch.ctx).Infof("Error streaming %s logs: %v", name, err)
                return
        }</span>
}

func logPrefix(n string) string <span class="cov8" title="1">{
        max := 12
        spaces := ""
        if len(n) &gt; max </span><span class="cov0" title="0">{
                n = n[:max-1] + "…"
        }</span> else<span class="cov8" title="1"> {
                spaces = strings.Repeat(" ", max-len(n))
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%s%s┊ ", n, spaces)</span>
}

type PodLogWatch struct {
        ctx    context.Context
        cancel func()

        name      model.ManifestName
        podID     k8s.PodID
        namespace k8s.Namespace
        cID       k8s.ContainerID
        cName     k8s.ContainerName
}

type podLogKey struct {
        podID k8s.PodID
        cID   k8s.ContainerID
}

type PodLogActionWriter struct {
        store        *store.Store
        podID        k8s.PodID
        manifestName model.ManifestName
}

func (w PodLogActionWriter) Write(p []byte) (n int, err error) <span class="cov8" title="1">{
        w.store.Dispatch(PodLogAction{
                PodID:        w.podID,
                ManifestName: w.manifestName,
                Log:          append([]byte{}, p...),
        })
        return len(p), nil
}</span>

var _ store.Subscriber = &amp;PodLogManager{}
</pre>
		
		<pre class="file" id="file25" style="display: none">package engine

import (
        "context"

        "github.com/windmilleng/tilt/internal/k8s"
        "github.com/windmilleng/tilt/internal/logger"
        "github.com/windmilleng/tilt/internal/model"
        "github.com/windmilleng/tilt/internal/store"
        "k8s.io/api/core/v1"
)

type PortForwardController struct {
        kClient k8s.Client

        activeForwards map[k8s.PodID]portForwardEntry
}

func NewPortForwardController(kClient k8s.Client) *PortForwardController <span class="cov8" title="1">{
        return &amp;PortForwardController{
                kClient:        kClient,
                activeForwards: make(map[k8s.PodID]portForwardEntry),
        }
}</span>

// Figure out the diff between what's in the data store and
// what port-forwarding is currently active.
func (m *PortForwardController) diff(ctx context.Context, st *store.Store) (toStart []portForwardEntry, toShutdown []portForwardEntry) <span class="cov8" title="1">{
        state := st.RLockState()
        defer st.RUnlockState()

        statePods := make(map[k8s.PodID]bool, len(state.ManifestStates))

        // Find all the port-forwards that need to be created.
        for _, ms := range state.ManifestStates </span><span class="cov8" title="1">{
                podID := ms.Pod.PodID
                if podID == "" </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Only do port-forwarding if the pod is running.
                <span class="cov8" title="1">if ms.Pod.Phase != v1.PodRunning </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">forwards := PopulatePortForwards(ms.Manifest, ms.Pod)
                if len(forwards) == 0 </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">statePods[podID] = true

                _, isActive := m.activeForwards[podID]
                if isActive </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">ctx, cancel := context.WithCancel(ctx)
                entry := portForwardEntry{
                        podID:     podID,
                        name:      ms.Manifest.Name,
                        namespace: ms.Pod.Namespace,
                        forwards:  forwards,
                        ctx:       ctx,
                        cancel:    cancel,
                }

                toStart = append(toStart, entry)
                m.activeForwards[podID] = entry</span>
        }

        // Find all the port-forwards that aren't in the manifest anymore
        // and need to be shutdown.
        <span class="cov8" title="1">for key, value := range m.activeForwards </span><span class="cov8" title="1">{
                _, inState := statePods[key]
                if inState </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">toShutdown = append(toShutdown, value)
                delete(m.activeForwards, key)</span>
        }

        <span class="cov8" title="1">return toStart, toShutdown</span>
}

func (m *PortForwardController) OnChange(ctx context.Context, st *store.Store) <span class="cov8" title="1">{
        toStart, toShutdown := m.diff(ctx, st)
        for _, entry := range toShutdown </span><span class="cov8" title="1">{
                entry.cancel()
        }</span>

        <span class="cov8" title="1">for _, entry := range toStart </span><span class="cov8" title="1">{
                entry := entry
                ns := entry.namespace
                podID := entry.podID
                for _, forward := range entry.forwards </span><span class="cov8" title="1">{
                        // TODO(nick): Handle the case where DockerForDesktop is handling
                        // the port-forwarding natively already
                        _, closer, err := m.kClient.ForwardPort(ctx, ns, podID, forward.LocalPort, forward.ContainerPort)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Get(ctx).Infof("Error port-forwarding %s: %v", entry.name, err)
                                continue</span>
                        }

                        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                                &lt;-entry.ctx.Done()
                                closer()
                        }</span>()
                }
        }
}

var _ store.Subscriber = &amp;PortForwardController{}

type portForwardEntry struct {
        name               model.ManifestName
        namespace          k8s.Namespace
        podID              k8s.PodID
        firstContainerPort int32
        forwards           []model.PortForward
        ctx                context.Context
        cancel             func()
}

// Extract the port-forward specs from the manifest. If any of them
// have ContainerPort = 0, populate them with the default port in the pod spec.
// Quietly drop forwards that we can't populate.
func PopulatePortForwards(m model.Manifest, pod store.Pod) []model.PortForward <span class="cov8" title="1">{
        cPorts := pod.ContainerPorts
        forwards := make([]model.PortForward, 0, len(m.PortForwards))
        for _, forward := range m.PortForwards </span><span class="cov8" title="1">{
                if forward.ContainerPort == 0 </span><span class="cov8" title="1">{
                        if len(cPorts) == 0 </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov8" title="1">forward.ContainerPort = int(cPorts[0])</span>
                }
                <span class="cov8" title="1">forwards = append(forwards, forward)</span>
        }
        <span class="cov8" title="1">return forwards</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package engine

import (
        "context"

        "github.com/windmilleng/tilt/internal/store"

        "github.com/windmilleng/tilt/internal/k8s"
        "k8s.io/api/core/v1"
)

func makeServiceWatcher(ctx context.Context, kCli k8s.Client, st *store.Store) error <span class="cov0" title="0">{
        ch, err := kCli.WatchServices(ctx, []k8s.LabelPair{TiltRunLabel()})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">go dispatchServiceChangesLoop(ctx, ch, st)

        return nil</span>
}

func dispatchServiceChangesLoop(ctx context.Context, ch &lt;-chan *v1.Service, st *store.Store) <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                select </span>{
                case service, ok := &lt;-ch:<span class="cov8" title="1">
                        if !ok </span><span class="cov8" title="1">{
                                return
                        }</span>
                        <span class="cov0" title="0">st.Dispatch(NewServiceChangeAction(service))</span>
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        return</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package engine

import (
        "context"
        "fmt"
        "time"

        "github.com/docker/distribution/reference"
        "github.com/opentracing/opentracing-go"
        "github.com/pkg/errors"

        "github.com/windmilleng/tilt/internal/build"
        "github.com/windmilleng/tilt/internal/ignore"
        "github.com/windmilleng/tilt/internal/logger"
        "github.com/windmilleng/tilt/internal/model"
        "github.com/windmilleng/tilt/internal/store"
)

const podPollTimeoutSynclet = time.Second * 30

var _ BuildAndDeployer = &amp;SyncletBuildAndDeployer{}

type SyncletBuildAndDeployer struct {
        sm SyncletManager
        dd *DeployDiscovery
}

func NewSyncletBuildAndDeployer(dd *DeployDiscovery, sm SyncletManager) *SyncletBuildAndDeployer <span class="cov8" title="1">{
        return &amp;SyncletBuildAndDeployer{
                dd: dd,
                sm: sm,
        }
}</span>

func (sbd *SyncletBuildAndDeployer) forgetImage(ctx context.Context, img reference.NamedTagged) error <span class="cov8" title="1">{
        deployInfo := sbd.dd.ForgetImage(img)
        if deployInfo.podID != "" </span><span class="cov8" title="1">{
                return sbd.sm.ForgetPod(ctx, deployInfo.podID)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (sbd *SyncletBuildAndDeployer) BuildAndDeploy(ctx context.Context, manifest model.Manifest, state store.BuildState) (store.BuildResult, error) <span class="cov8" title="1">{
        span, ctx := opentracing.StartSpanFromContext(ctx, "SyncletBuildAndDeployer-BuildAndDeploy")
        span.SetTag("manifest", manifest.Name.String())
        defer span.Finish()

        // TODO(maia): proper output for this stuff

        if err := sbd.canSyncletBuild(ctx, manifest, state); err != nil </span><span class="cov8" title="1">{
                return store.BuildResult{}, err
        }</span>

        <span class="cov8" title="1">return sbd.updateViaSynclet(ctx, manifest, state)</span>
}

// canSyncletBuild returns an error if we CAN'T build this manifest via the synclet
func (sbd *SyncletBuildAndDeployer) canSyncletBuild(ctx context.Context,
        manifest model.Manifest, state store.BuildState) error <span class="cov8" title="1">{

        // TODO(maia): put manifest.Validate() upstream if we're gonna want to call it regardless
        // of implementation of BuildAndDeploy?
        err := manifest.Validate()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // SyncletBuildAndDeployer doesn't support initial build
        <span class="cov8" title="1">if state.IsEmpty() </span><span class="cov8" title="1">{
                return fmt.Errorf("prev. build state is empty; synclet build does not support initial deploy")
        }</span>

        <span class="cov8" title="1">if manifest.IsStaticBuild() </span><span class="cov0" title="0">{
                return fmt.Errorf("container build does not support static dockerfiles")
        }</span>

        // Can't do container update if we don't know what container manifest is running in.
        <span class="cov8" title="1">info, err := sbd.dd.DeployInfoForImageBlocking(ctx, state.LastResult.Image)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "deploy info fetch failed")
        }</span> else<span class="cov8" title="1"> if info.Empty() </span><span class="cov0" title="0">{
                return fmt.Errorf("no deploy info")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (sbd *SyncletBuildAndDeployer) updateViaSynclet(ctx context.Context,
        manifest model.Manifest, state store.BuildState) (store.BuildResult, error) <span class="cov8" title="1">{
        span, ctx := opentracing.StartSpanFromContext(ctx, "SyncletBuildAndDeployer-updateViaSynclet")
        defer span.Finish()

        paths, err := build.FilesToPathMappings(
                state.FilesChanged(), manifest.Mounts)
        if err != nil </span><span class="cov0" title="0">{
                return store.BuildResult{}, err
        }</span>

        // archive files to copy to container
        <span class="cov8" title="1">ab := build.NewArchiveBuilder(ignore.CreateBuildContextFilter(manifest))
        err = ab.ArchivePathsIfExist(ctx, paths)
        if err != nil </span><span class="cov0" title="0">{
                return store.BuildResult{}, fmt.Errorf("archivePathsIfExists: %v", err)
        }</span>
        <span class="cov8" title="1">archive, err := ab.BytesBuffer()
        if err != nil </span><span class="cov0" title="0">{
                return store.BuildResult{}, err
        }</span>

        // get files to rm
        <span class="cov8" title="1">toRemove, err := build.MissingLocalPaths(ctx, paths)
        if err != nil </span><span class="cov0" title="0">{
                return store.BuildResult{}, fmt.Errorf("missingLocalPaths: %v", err)
        }</span>
        // TODO(maia): can refactor MissingLocalPaths to just return ContainerPaths?
        <span class="cov8" title="1">containerPathsToRm := build.PathMappingsToContainerPaths(toRemove)

        deployInfo, err := sbd.dd.DeployInfoForImageBlocking(ctx, state.LastResult.Image)

        // We theoretically already checked this condition :(
        if err != nil </span><span class="cov0" title="0">{
                return store.BuildResult{}, errors.Wrap(err, "deploy info fetch failed")
        }</span> else<span class="cov8" title="1"> if deployInfo.Empty() </span><span class="cov0" title="0">{
                return store.BuildResult{}, fmt.Errorf("no deploy info")
        }</span>

        <span class="cov8" title="1">cmds, err := build.BoilSteps(manifest.Steps, paths)
        if err != nil </span><span class="cov0" title="0">{
                return store.BuildResult{}, err
        }</span>

        <span class="cov8" title="1">sCli, err := sbd.sm.ClientForPod(ctx, deployInfo.podID, state.LastResult.Namespace)
        if err != nil </span><span class="cov0" title="0">{
                return store.BuildResult{}, err
        }</span>

        <span class="cov8" title="1">err = sCli.UpdateContainer(ctx, deployInfo.containerID, archive.Bytes(), containerPathsToRm, cmds)
        if err != nil </span><span class="cov8" title="1">{
                return store.BuildResult{}, err
        }</span>

        <span class="cov8" title="1">res := state.LastResult.ShallowCloneForContainerUpdate(state.FilesChangedSet)
        res.ContainerID = deployInfo.containerID // the container we deployed on top of
        return res, nil</span>
}

func (sbd *SyncletBuildAndDeployer) PostProcessBuild(ctx context.Context, result, previousResult store.BuildResult) <span class="cov8" title="1">{
        span, ctx := opentracing.StartSpanFromContext(ctx, "SyncletBuildAndDeployer-PostProcessBuild")
        span.SetTag("image", result.Image.String())
        defer span.Finish()

        if previousResult.HasImage() &amp;&amp; (!result.HasImage() || result.Image != previousResult.Image) </span><span class="cov8" title="1">{
                err := sbd.forgetImage(ctx, previousResult.Image)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Get(ctx).Debugf("failed to get clean up image-related state: %v", err)
                }</span>
        }

        <span class="cov8" title="1">if !result.HasImage() </span><span class="cov0" title="0">{
                // This is normal if the previous build failed.
                return
        }</span>

        <span class="cov8" title="1">sbd.dd.EnsureDeployInfoFetchStarted(ctx, result.Image, result.Namespace)</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package engine

import (
        "context"
        "fmt"
        "sync"

        opentracing "github.com/opentracing/opentracing-go"
        "github.com/windmilleng/tilt/internal/logger"
        "github.com/windmilleng/tilt/internal/options"
        "github.com/windmilleng/tilt/internal/synclet/sidecar"

        "github.com/pkg/errors"
        "github.com/windmilleng/tilt/internal/k8s"
        "github.com/windmilleng/tilt/internal/synclet"
        "google.golang.org/grpc"
)

type newCliFn func(ctx context.Context, kCli k8s.Client, podID k8s.PodID, ns k8s.Namespace) (synclet.SyncletClient, error)
type SyncletManager struct {
        kCli      k8s.Client
        mutex     *sync.Mutex
        clients   map[k8s.PodID]synclet.SyncletClient
        newClient newCliFn
}

type tunneledSyncletClient struct {
        synclet.SyncletClient
        tunnelCloser func()
}

var _ synclet.SyncletClient = tunneledSyncletClient{}

func (t tunneledSyncletClient) Close() error <span class="cov0" title="0">{
        err := t.SyncletClient.Close()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">t.tunnelCloser()

        return nil</span>
}

func NewSyncletManager(kCli k8s.Client) SyncletManager <span class="cov0" title="0">{
        return SyncletManager{
                kCli:      kCli,
                mutex:     new(sync.Mutex),
                clients:   make(map[k8s.PodID]synclet.SyncletClient),
                newClient: newSyncletClient,
        }
}</span>

func NewSyncletManagerForTests(kCli k8s.Client, fakeCli synclet.SyncletClient) SyncletManager <span class="cov8" title="1">{
        newClientFn := func(ctx context.Context, kCli k8s.Client, podID k8s.PodID, ns k8s.Namespace) (synclet.SyncletClient, error) </span><span class="cov8" title="1">{
                fake, ok := fakeCli.(*synclet.FakeSyncletClient)
                if ok </span><span class="cov8" title="1">{
                        fake.PodID = podID
                        fake.Namespace = ns
                }</span>
                <span class="cov8" title="1">return fakeCli, nil</span>
        }

        <span class="cov8" title="1">return SyncletManager{
                kCli:      kCli,
                mutex:     new(sync.Mutex),
                clients:   make(map[k8s.PodID]synclet.SyncletClient),
                newClient: newClientFn,
        }</span>
}

func (sm SyncletManager) ClientForPod(ctx context.Context, podID k8s.PodID, ns k8s.Namespace) (synclet.SyncletClient, error) <span class="cov8" title="1">{
        sm.mutex.Lock()
        defer sm.mutex.Unlock()

        client, ok := sm.clients[podID]
        if ok </span><span class="cov0" title="0">{
                return client, nil
        }</span>

        <span class="cov8" title="1">client, err := sm.newClient(ctx, sm.kCli, podID, ns)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "error creating synclet client")
        }</span>
        <span class="cov8" title="1">sm.clients[podID] = client

        return client, nil</span>
}

func (sm SyncletManager) ForgetPod(ctx context.Context, podID k8s.PodID) error <span class="cov8" title="1">{
        sm.mutex.Lock()
        defer sm.mutex.Unlock()

        client, ok := sm.clients[podID]
        if !ok </span><span class="cov0" title="0">{
                // if we don't know about the pod, it's already forgotten - noop
                return nil
        }</span>

        <span class="cov8" title="1">delete(sm.clients, podID)

        return client.Close()</span>
}

func newSyncletClient(ctx context.Context, kCli k8s.Client, podID k8s.PodID, ns k8s.Namespace) (synclet.SyncletClient, error) <span class="cov0" title="0">{
        span, ctx := opentracing.StartSpanFromContext(ctx, "SidecarSyncletManager-newSidecarSyncletClient")
        defer span.Finish()

        pod, err := kCli.PodByID(ctx, podID, ns)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "newSyncletClient")
        }</span>

        // Make sure that the synclet container is ready and not crashlooping.
        <span class="cov0" title="0">_, err = k8s.WaitForContainerReady(ctx, kCli, pod, sidecar.SyncletImageRef)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "newSyncletClient")
        }</span>

        // TODO(nick): We need a better way to kill the client when the pod dies.
        <span class="cov0" title="0">tunneledPort, tunnelCloser, err := kCli.ForwardPort(ctx, ns, podID, 0, synclet.Port)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrapf(err, "failed opening tunnel to synclet pod '%s'", podID)
        }</span>

        <span class="cov0" title="0">logger.Get(ctx).Verbosef("tunneling to synclet client at %s (local port %d)", podID.String(), tunneledPort)

        t := opentracing.GlobalTracer()

        opts := options.MaxMsgDial()
        opts = append(opts, grpc.WithInsecure())
        opts = append(opts, options.TracingInterceptorsDial(t)...)

        conn, err := grpc.DialContext(ctx, fmt.Sprintf("127.0.0.1:%d", tunneledPort), opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "connecting to synclet")
        }</span>

        <span class="cov0" title="0">return tunneledSyncletClient{synclet.NewGRPCClient(conn), tunnelCloser}, nil</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package engine

import (
        "bytes"
        "context"
        "fmt"
        "log"
        "net/url"
        "time"

        "github.com/docker/distribution/reference"
        "github.com/opentracing/opentracing-go"
        "k8s.io/api/core/v1"

        "github.com/windmilleng/tilt/internal/build"
        "github.com/windmilleng/tilt/internal/hud"
        "github.com/windmilleng/tilt/internal/k8s"
        "github.com/windmilleng/tilt/internal/logger"
        "github.com/windmilleng/tilt/internal/model"
        "github.com/windmilleng/tilt/internal/ospath"
        "github.com/windmilleng/tilt/internal/store"
        "github.com/windmilleng/tilt/internal/watch"
)

// When we see a file change, wait this long to see if any other files have changed, and bundle all changes together.
// 200ms is not the result of any kind of research or experimentation
// it might end up being a significant part of deployment delay, if we get the total latency &lt;2s
// it might also be long enough that it misses some changes if the user has some operation involving a large file
//   (e.g., a binary dependency in git), but that's hopefully less of a problem since we'd get it in the next build
const watchBufferMinRestInMs = 200

// When waiting for a `watchBufferDurationInMs`-long break in file modifications to aggregate notifications,
// if we haven't seen a break by the time `watchBufferMaxTimeInMs` has passed, just send off whatever we've got
const watchBufferMaxTimeInMs = 10000

var watchBufferMinRestDuration = watchBufferMinRestInMs * time.Millisecond
var watchBufferMaxDuration = watchBufferMaxTimeInMs * time.Millisecond

// When we kick off a build because some files changed, only print the first `maxChangedFilesToPrint`
const maxChangedFilesToPrint = 5

// TODO(nick): maybe this should be called 'BuildEngine' or something?
// Upper seems like a poor and undescriptive name.
type Upper struct {
        b                   BuildAndDeployer
        timerMaker          timerMaker
        podWatcherMaker     PodWatcherMaker
        serviceWatcherMaker ServiceWatcherMaker
        k8s                 k8s.Client
        reaper              build.ImageReaper
        hud                 hud.HeadsUpDisplay
        store               *store.Store
        hudErrorCh          chan error
}

type FsWatcherMaker func() (watch.Notify, error)
type ServiceWatcherMaker func(context.Context, *store.Store) error
type PodWatcherMaker func(context.Context, *store.Store) error
type timerMaker func(d time.Duration) &lt;-chan time.Time

func ProvidePodWatcherMaker(kCli k8s.Client) PodWatcherMaker <span class="cov0" title="0">{
        return func(ctx context.Context, store *store.Store) error </span><span class="cov0" title="0">{
                return makePodWatcher(ctx, kCli, store)
        }</span>
}

func ProvideServiceWatcherMaker(kCli k8s.Client) ServiceWatcherMaker <span class="cov0" title="0">{
        return func(ctx context.Context, store *store.Store) error </span><span class="cov0" title="0">{
                return makeServiceWatcher(ctx, kCli, store)
        }</span>
}

func ProvideFsWatcherMaker() FsWatcherMaker <span class="cov0" title="0">{
        return func() (watch.Notify, error) </span><span class="cov0" title="0">{
                return watch.NewWatcher()
        }</span>
}

func ProvideTimerMaker() timerMaker <span class="cov0" title="0">{
        return func(t time.Duration) &lt;-chan time.Time </span><span class="cov0" title="0">{
                return time.After(t)
        }</span>
}

func NewUpper(ctx context.Context, b BuildAndDeployer, k8s k8s.Client,
        reaper build.ImageReaper, hud hud.HeadsUpDisplay, pwm PodWatcherMaker, swm ServiceWatcherMaker,
        st *store.Store, plm *PodLogManager, pfc *PortForwardController, fwm *WatchManager, fswm FsWatcherMaker, bc *BuildController) Upper <span class="cov8" title="1">{

        st.AddSubscriber(bc)
        st.AddSubscriber(hud)
        st.AddSubscriber(pfc)
        st.AddSubscriber(plm)
        st.AddSubscriber(fwm)

        return Upper{
                b:                   b,
                podWatcherMaker:     pwm,
                serviceWatcherMaker: swm,
                timerMaker:          time.After,
                k8s:                 k8s,
                reaper:              reaper,
                hud:                 hud,
                store:               st,
                hudErrorCh:          make(chan error),
        }
}</span>

func (u Upper) RunHud(ctx context.Context) error <span class="cov8" title="1">{
        err := u.hud.Run(ctx, u.store, hud.DefaultRefreshInterval)
        u.hudErrorCh &lt;- err
        close(u.hudErrorCh)
        return err
}</span>

func (u Upper) CreateManifests(ctx context.Context, manifests []model.Manifest, watchMounts bool) error <span class="cov8" title="1">{
        span, ctx := opentracing.StartSpanFromContext(ctx, "daemon-Up")
        defer span.Finish()

        u.store.Dispatch(InitAction{
                WatchMounts: watchMounts,
                Manifests:   manifests,
        })

        defer func() </span><span class="cov8" title="1">{
                u.hud.Close()
                // make sure the hud has had a chance to clean up
                &lt;-u.hudErrorCh
        }</span>()

        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        return ctx.Err()</span>

                        // Reducers
                case action := &lt;-u.store.Actions():<span class="cov8" title="1">
                        state := u.store.LockMutableState()
                        err := u.reduceAction(ctx, state, action)
                        if err != nil </span><span class="cov8" title="1">{
                                state.PermanentError = err
                        }</span>
                        <span class="cov8" title="1">u.store.UnlockMutableState()</span>
                }

                // Subscribers
                <span class="cov8" title="1">done, err := maybeFinished(u.store)
                if done </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">u.store.NotifySubscribers(ctx)</span>
        }
}

func (u Upper) reduceAction(ctx context.Context, state *store.EngineState, action store.Action) error <span class="cov8" title="1">{
        switch action := action.(type) </span>{
        case InitAction:<span class="cov8" title="1">
                return u.handleInitAction(ctx, state, action)</span>
        case ErrorAction:<span class="cov8" title="1">
                return action.Error</span>
        case manifestFilesChangedAction:<span class="cov8" title="1">
                handleFSEvent(ctx, state, action)</span>
        case PodChangeAction:<span class="cov8" title="1">
                handlePodEvent(ctx, state, action.Pod)</span>
        case ServiceChangeAction:<span class="cov8" title="1">
                handleServiceEvent(ctx, state, action.Service)</span>
        case PodLogAction:<span class="cov8" title="1">
                handlePodLogAction(state, action)</span>
        case BuildCompleteAction:<span class="cov8" title="1">
                return handleCompletedBuild(ctx, state, action)</span>
        case hud.ShowErrorAction:<span class="cov8" title="1">
                showError(ctx, state, action.ResourceNumber)</span>
        case BuildStartedAction:<span class="cov8" title="1">
                handleBuildStarted(ctx, state, action)</span>
        case ManifestReloadedAction:<span class="cov8" title="1">
                handleManifestReloaded(ctx, state, action)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unrecognized action: %T", action)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func maybeFinished(st *store.Store) (bool, error) <span class="cov8" title="1">{
        state := st.RLockState()
        defer st.RUnlockState()

        if len(state.ManifestStates) == 0 </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov8" title="1">if state.PermanentError != nil </span><span class="cov8" title="1">{
                return true, state.PermanentError
        }</span>

        <span class="cov8" title="1">finished := !state.WatchMounts &amp;&amp; len(state.ManifestsToBuild) == 0 &amp;&amp; state.CurrentlyBuilding == ""
        return finished, nil</span>
}

func handleManifestReloaded(ctx context.Context, state *store.EngineState, action ManifestReloadedAction) <span class="cov8" title="1">{
        state.BuildControllerActionCount++

        ms, ok := state.ManifestStates[action.OldManifest.Name]
        if !ok </span><span class="cov0" title="0">{
                state.PermanentError = fmt.Errorf("handleManifestReloaded: Missing manifest state: %s", action.OldManifest.Name)
                return
        }</span>

        <span class="cov8" title="1">err := action.Error
        if err != nil </span><span class="cov8" title="1">{
                logger.Get(ctx).Infof("getting new manifest error: %v", err)
                ms.LastError = err
                ms.LastBuildFinishTime = time.Now()
                ms.LastBuildDuration = 0

                err := removeFromManifestsToBuild(state, ms.Manifest.Name)
                if err != nil </span><span class="cov0" title="0">{
                        state.PermanentError = fmt.Errorf("handleManifestReloaded: %v", err)
                        return
                }</span>
                <span class="cov8" title="1">return</span>
        }

        <span class="cov8" title="1">newManifest := action.NewManifest
        if newManifest.Equal(ms.Manifest) </span><span class="cov8" title="1">{
                logger.Get(ctx).Debugf("Detected config change, but manifest %s hasn't changed",
                        ms.Manifest.Name)

                if _, ok := ms.LastError.(*manifestErr); ok </span><span class="cov8" title="1">{
                        // Last err indicates failure to make a new manifest b/c of bad config files.
                        // Manifest is now back to normal (the new one we just got is the same as the
                        // one we previously had) so clear this error.
                        ms.LastError = nil
                }</span>

                <span class="cov8" title="1">mountedChangedFiles, err := ms.PendingFileChangesWithoutUnmountedConfigFiles(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Get(ctx).Infof(err.Error())
                        return
                }</span>
                <span class="cov8" title="1">ms.PendingFileChanges = mountedChangedFiles

                if len(ms.PendingFileChanges) == 0 </span><span class="cov8" title="1">{
                        ms.ConfigIsDirty = false
                        err = removeFromManifestsToBuild(state, ms.Manifest.Name)
                        if err != nil </span><span class="cov0" title="0">{
                                state.PermanentError = fmt.Errorf("handleManifestReloaded: %v", err)
                        }</span>
                        <span class="cov8" title="1">return</span>
                }
        } else<span class="cov8" title="1"> {
                // Manifest has changed, ensure we do an image build so that we apply the changes
                ms.LastBuild = store.BuildResult{}
                ms.Manifest = newManifest
        }</span>

        <span class="cov8" title="1">ms.ConfigIsDirty = false</span>
}

func removeFromManifestsToBuild(state *store.EngineState, mn model.ManifestName) error <span class="cov8" title="1">{
        for i, n := range state.ManifestsToBuild </span><span class="cov8" title="1">{
                if n == mn </span><span class="cov8" title="1">{
                        state.ManifestsToBuild = append(state.ManifestsToBuild[:i], state.ManifestsToBuild[i+1:]...)
                        return nil
                }</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("Missing manifest %s", mn)</span>
}

func handleBuildStarted(ctx context.Context, state *store.EngineState, action BuildStartedAction) <span class="cov8" title="1">{
        mn := action.Manifest.Name
        err := removeFromManifestsToBuild(state, mn)
        if err != nil </span><span class="cov0" title="0">{
                state.PermanentError = fmt.Errorf("handleBuildStarted: %v", err)
                return
        }</span>

        <span class="cov8" title="1">ms := state.ManifestStates[mn]
        ms.QueueEntryTime = time.Time{}

        ms.CurrentlyBuildingFileChanges = append([]string{}, action.FilesChanged...)
        for _, file := range action.FilesChanged </span><span class="cov8" title="1">{
                delete(ms.PendingFileChanges, file)
        }</span>
        <span class="cov8" title="1">ms.CurrentBuildStartTime = action.StartTime
        ms.Pod.Log = []byte{}

        // TODO(nick): It would be better if we reversed the relationship
        // between CurrentlyBuilding and BuildController. BuildController should dispatch
        // a StartBuildAction, and that should change the state of CurrentlyBuilding
        // (rather than BuildController starting in response to CurrentlyBuilding).
        state.CurrentlyBuilding = mn</span>
}

func handleCompletedBuild(ctx context.Context, engineState *store.EngineState, cb BuildCompleteAction) error <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{
                engineState.CurrentlyBuilding = ""
        }</span>()

        <span class="cov8" title="1">engineState.CompletedBuildCount++
        engineState.BuildControllerActionCount++

        defer func() </span><span class="cov8" title="1">{
                if engineState.CompletedBuildCount == engineState.InitialBuildCount </span><span class="cov8" title="1">{
                        logger.Get(ctx).Debugf("[timing.py] finished initial build") // hook for timing.py
                }</span>
        }()

        <span class="cov8" title="1">err := cb.Error

        ms := engineState.ManifestStates[engineState.CurrentlyBuilding]
        ms.HasBeenBuilt = true
        ms.LastError = err
        ms.LastBuildFinishTime = time.Now()
        ms.LastBuildDuration = time.Since(ms.CurrentBuildStartTime)
        ms.CurrentBuildStartTime = time.Time{}
        ms.LastBuildLog = ms.CurrentBuildLog
        ms.CurrentBuildLog = &amp;bytes.Buffer{}
        ms.CrashRebuildInProg = false

        if err != nil </span><span class="cov8" title="1">{
                // Put the files that failed to build back into the pending queue.
                for _, file := range ms.CurrentlyBuildingFileChanges </span><span class="cov8" title="1">{
                        ms.PendingFileChanges[file] = true
                }</span>
                <span class="cov8" title="1">ms.CurrentlyBuildingFileChanges = nil

                if isPermanentError(err) </span><span class="cov8" title="1">{
                        return err
                }</span> else<span class="cov8" title="1"> if engineState.WatchMounts </span><span class="cov8" title="1">{
                        l := logger.Get(ctx)
                        p := logger.Red(l).Sprintf("Build Failed:")
                        l.Infof("%s %v", p, err)
                }</span> else<span class="cov8" title="1"> {
                        return fmt.Errorf("Build Failed: %v", err)
                }</span>
        } else<span class="cov8" title="1"> {
                ms.LastSuccessfulDeployTime = time.Now()
                ms.LastBuild = cb.Result
                ms.LastSuccessfulDeployEdits = ms.CurrentlyBuildingFileChanges
                ms.CurrentlyBuildingFileChanges = nil

                ms.Pod.OldRestarts = ms.Pod.ContainerRestarts // # of pod restarts from old code (shouldn't be reflected in HUD)
        }</span>

        <span class="cov8" title="1">if engineState.WatchMounts </span><span class="cov8" title="1">{
                logger.Get(ctx).Debugf("[timing.py] finished build from file change") // hook for timing.py

                if len(engineState.ManifestsToBuild) == 0 </span><span class="cov8" title="1">{
                        l := logger.Get(ctx)
                        l.Infof("%s", logger.Green(l).Sprintf("Awaiting changes…\n"))
                }</span>

                <span class="cov8" title="1">if cb.Result.ContainerID != "" </span><span class="cov8" title="1">{
                        if ms, ok := engineState.ManifestStates[ms.Manifest.Name]; ok </span><span class="cov8" title="1">{
                                ms.ExpectedContainerID = cb.Result.ContainerID
                                log.Printf("got expectedCID: %s", ms.ExpectedContainerID.ShortStr())
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

func handleFSEvent(
        ctx context.Context,
        state *store.EngineState,
        event manifestFilesChangedAction) <span class="cov8" title="1">{
        manifest := state.ManifestStates[event.manifestName].Manifest

        if eventContainsConfigFiles(manifest, event) </span><span class="cov8" title="1">{
                logger.Get(ctx).Debugf("Event contains config files")
                state.ManifestStates[event.manifestName].ConfigIsDirty = true
        }</span>

        <span class="cov8" title="1">ms := state.ManifestStates[event.manifestName]

        for _, f := range event.files </span><span class="cov8" title="1">{
                ms.PendingFileChanges[f] = true
        }</span>

        <span class="cov8" title="1">spurious, err := onlySpuriousChanges(ms.PendingFileChanges)
        if err != nil </span><span class="cov0" title="0">{
                logger.Get(ctx).Infof("build watch error: %v", err)
        }</span>

        <span class="cov8" title="1">if spurious </span><span class="cov8" title="1">{
                // TODO(nick): I think we probably want to log when this happens?
                return
        }</span>

        // if the name is already in the queue, we don't need to add it again
        <span class="cov8" title="1">for _, mn := range state.ManifestsToBuild </span><span class="cov0" title="0">{
                if mn == event.manifestName </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        <span class="cov8" title="1">enqueueBuild(state, event.manifestName)</span>
}

func enqueueBuild(state *store.EngineState, mn model.ManifestName) <span class="cov8" title="1">{
        state.ManifestsToBuild = append(state.ManifestsToBuild, mn)
        state.ManifestStates[mn].QueueEntryTime = time.Now()
}</span>

// Get a pointer to a mutable manifest state,
// ensuring that some Pod exists on the state.
//
// Intended as a helper for pod-mutating events.
func ensureManifestStateWithPod(state *store.EngineState, pod *v1.Pod) *store.ManifestState <span class="cov8" title="1">{
        manifestName := model.ManifestName(pod.ObjectMeta.Labels[ManifestNameLabel])
        if manifestName == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">podID := k8s.PodIDFromPod(pod)
        startedAt := pod.CreationTimestamp.Time
        status := podStatusToString(*pod)
        ns := k8s.NamespaceFromPod(pod)

        ms, ok := state.ManifestStates[manifestName]
        if !ok </span><span class="cov0" title="0">{
                // This is OK. The user could have edited the manifest recently.
                return nil
        }</span>

        // If the pod is empty, or older then the current pod, replace it.
        <span class="cov8" title="1">if ms.Pod.PodID == "" || ms.Pod.StartedAt.Before(startedAt) </span><span class="cov8" title="1">{
                ms.Pod = store.Pod{
                        PodID:     podID,
                        StartedAt: startedAt,
                        Status:    status,
                        Namespace: ns,
                }
        }</span>

        <span class="cov8" title="1">return ms</span>
}

// Fill in container fields on the pod state.
func populateContainerStatus(ctx context.Context, ms *store.ManifestState, pod *v1.Pod, cStatus v1.ContainerStatus) <span class="cov8" title="1">{
        cName := k8s.ContainerNameFromContainerStatus(cStatus)
        ms.Pod.ContainerName = cName
        ms.Pod.ContainerReady = cStatus.Ready

        cID, err := k8s.ContainerIDFromContainerStatus(cStatus)
        if err != nil </span><span class="cov0" title="0">{
                logger.Get(ctx).Debugf("Error parsing container ID: %v", err)
                return
        }</span>
        <span class="cov8" title="1">ms.Pod.ContainerID = cID

        ports := make([]int32, 0)
        cSpec := k8s.ContainerSpecOf(pod, cStatus)
        for _, cPort := range cSpec.Ports </span><span class="cov8" title="1">{
                ports = append(ports, cPort.ContainerPort)
        }</span>
        <span class="cov8" title="1">ms.Pod.ContainerPorts = ports

        forwards := PopulatePortForwards(ms.Manifest, ms.Pod)
        if len(forwards) &lt; len(ms.Manifest.PortForwards) </span><span class="cov0" title="0">{
                logger.Get(ctx).Infof(
                        "WARNING: Resource %s is using port forwards, but no container ports on pod %s",
                        ms.Manifest.Name, ms.Pod.PodID)
        }</span>
}

func handlePodEvent(ctx context.Context, state *store.EngineState, pod *v1.Pod) <span class="cov8" title="1">{
        ms := ensureManifestStateWithPod(state, pod)
        if ms == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">podID := k8s.PodIDFromPod(pod)
        if ms.Pod.PodID != podID </span><span class="cov0" title="0">{
                // This is an event from an old pod.
                return
        }</span>

        // Update the status
        <span class="cov8" title="1">ms.Pod.Phase = pod.Status.Phase
        ms.Pod.Status = podStatusToString(*pod)

        // Check if the container is ready.
        cStatus, err := k8s.ContainerMatching(pod, ms.Manifest.DockerRef)
        if err != nil </span><span class="cov0" title="0">{
                logger.Get(ctx).Debugf("Error matching container: %v", err)
                return
        }</span> else<span class="cov8" title="1"> if cStatus.Name == "" </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">populateContainerStatus(ctx, ms, pod, cStatus)
        if ms.ExpectedContainerID != "" &amp;&amp; ms.ExpectedContainerID != ms.Pod.ContainerID &amp;&amp; !ms.CrashRebuildInProg </span><span class="cov8" title="1">{
                log.Printf("should start image build")
                ms.CrashRebuildInProg = true
                ms.ExpectedContainerID = ""
                enqueueBuild(state, ms.Manifest.Name)
        }</span>

        <span class="cov8" title="1">if int(cStatus.RestartCount) &gt; ms.Pod.ContainerRestarts </span><span class="cov8" title="1">{
                ms.Pod.PreRestartLog = append([]byte{}, ms.Pod.Log...)
                ms.Pod.Log = []byte{}
        }</span>
        <span class="cov8" title="1">ms.Pod.ContainerRestarts = int(cStatus.RestartCount)</span>
}

func handlePodLogAction(state *store.EngineState, action PodLogAction) <span class="cov8" title="1">{
        manifestName := action.ManifestName
        ms, ok := state.ManifestStates[manifestName]

        if !ok </span><span class="cov0" title="0">{
                // This is OK. The user could have edited the manifest recently.
                return
        }</span>

        <span class="cov8" title="1">if ms.Pod.PodID != action.PodID </span><span class="cov0" title="0">{
                // NOTE(nick): There are two cases where this could happen:
                // 1) Pod 1 died and kubernetes started Pod 2. What should we do with
                //    logs from Pod 1 that are still in the action queue?
                //    This is an open product question. A future HUD may aggregate
                //    logs across pod restarts.
                // 2) Due to race conditions, we got the logs for Pod 1 before
                //    we saw Pod 1 materialize on the Pod API. The best way to fix
                //    this would be to make PodLogManager a subscriber that only
                //    starts listening on logs once the pod has materialized.
                //    We may prioritize this higher or lower based on how often
                //    this happens in practice.
                return
        }</span>

        <span class="cov8" title="1">ms.Pod.Log = append(ms.Pod.Log, action.Log...)</span>
}

func handleServiceEvent(ctx context.Context, state *store.EngineState, service *v1.Service) <span class="cov8" title="1">{
        manifestName := model.ManifestName(service.ObjectMeta.Labels[ManifestNameLabel])
        if manifestName == "" </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">ms, ok := state.ManifestStates[manifestName]
        if !ok </span><span class="cov0" title="0">{
                logger.Get(ctx).Infof("error: got notified of service for unknown manifest '%s'", manifestName)
                return
        }</span>

        <span class="cov8" title="1">url, err := k8s.ServiceURL(service)
        if err != nil </span><span class="cov0" title="0">{
                logger.Get(ctx).Infof("error resolving service %s: %v", manifestName, err)
                return
        }</span>

        <span class="cov8" title="1">ms.LBs[k8s.ServiceName(service.Name)] = url</span>
}

func (u Upper) handleInitAction(ctx context.Context, engineState *store.EngineState, action InitAction) error <span class="cov8" title="1">{
        watchMounts := action.WatchMounts
        manifests := action.Manifests

        for _, m := range manifests </span><span class="cov8" title="1">{
                engineState.ManifestDefinitionOrder = append(engineState.ManifestDefinitionOrder, m.Name)
                engineState.ManifestStates[m.Name] = store.NewManifestState(m)
        }</span>
        <span class="cov8" title="1">engineState.WatchMounts = watchMounts

        var err error
        if watchMounts </span><span class="cov8" title="1">{
                err = u.podWatcherMaker(ctx, u.store)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">err = u.serviceWatcherMaker(ctx, u.store)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                        err := u.reapOldWatchBuilds(ctx, manifests, time.Now())
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Get(ctx).Debugf("Error garbage collecting builds: %v", err)
                        }</span>
                }()
        }

        <span class="cov8" title="1">for _, m := range manifests </span><span class="cov8" title="1">{
                enqueueBuild(engineState, m.Name)
        }</span>
        <span class="cov8" title="1">engineState.InitialBuildCount = len(engineState.ManifestsToBuild)
        return nil</span>
}

// Check if the filesChangedSet only contains spurious changes that
// we don't want to rebuild on, like IDE temp/lock files.
//
// NOTE(nick): This isn't an ideal solution. In an ideal world, the user would
// put everything to ignore in their gitignore/dockerignore files. This is a stop-gap
// so they don't have a terrible experience if those files aren't there or
// aren't in the right places.
func onlySpuriousChanges(filesChanged map[string]bool) (bool, error) <span class="cov8" title="1">{
        // If a lot of files have changed, don't treat this as spurious.
        if len(filesChanged) &gt; 3 </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov8" title="1">for f := range filesChanged </span><span class="cov8" title="1">{
                broken, err := ospath.IsBrokenSymlink(f)
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>

                <span class="cov8" title="1">if !broken </span><span class="cov8" title="1">{
                        return false, nil
                }</span>
        }
        <span class="cov8" title="1">return true, nil</span>
}

func eventContainsConfigFiles(manifest model.Manifest, e manifestFilesChangedAction) bool <span class="cov8" title="1">{
        matcher, err := manifest.ConfigMatcher()
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">for _, f := range e.files </span><span class="cov8" title="1">{
                matches, err := matcher.Matches(f, false)
                if matches &amp;&amp; err == nil </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}

func (u Upper) resolveLB(ctx context.Context, spec k8s.LoadBalancerSpec) *url.URL <span class="cov0" title="0">{
        lb, _ := u.k8s.ResolveLoadBalancer(ctx, spec)
        return lb.URL
}</span>

func (u Upper) reapOldWatchBuilds(ctx context.Context, manifests []model.Manifest, createdBefore time.Time) error <span class="cov8" title="1">{
        refs := make([]reference.Named, len(manifests))
        for i, s := range manifests </span><span class="cov8" title="1">{
                refs[i] = s.DockerRef
        }</span>

        <span class="cov8" title="1">watchFilter := build.FilterByLabelValue(build.BuildMode, build.BuildModeExisting)
        for _, ref := range refs </span><span class="cov8" title="1">{
                nameFilter := build.FilterByRefName(ref)
                err := u.reaper.RemoveTiltImages(ctx, createdBefore, false, watchFilter, nameFilter)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("reapOldWatchBuilds: %v", err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// TODO(nick): This should be in the HUD
func showError(ctx context.Context, state *store.EngineState, resourceNumber int) <span class="cov8" title="1">{
        if resourceNumber &gt; len(state.ManifestDefinitionOrder) </span><span class="cov8" title="1">{
                logger.Get(ctx).Infof("Resource %d does not exist, so no log to print", resourceNumber)
                return
        }</span>

        <span class="cov8" title="1">mn := state.ManifestDefinitionOrder[resourceNumber-1]

        ms := state.ManifestStates[mn]

        if ms.LastBuildFinishTime.Equal(time.Time{}) </span><span class="cov0" title="0">{
                logger.Get(ctx).Infof("Resource %d has no previous build, so no log to print", resourceNumber)
                return
        }</span>

        <span class="cov8" title="1">if ms.LastError != nil </span><span class="cov8" title="1">{
                logger.Get(ctx).Infof("Last %s build log:", mn)
                logger.Get(ctx).Infof("──────────────────────────────────────────────────────────")
                logger.Get(ctx).Infof("%s", ms.LastBuildLog.String())
                logger.Get(ctx).Infof("──────────────────────────────────────────────────────────")
        }</span> else<span class="cov8" title="1"> {
                logger.Get(ctx).Infof("%s pod log:", mn)
                logger.Get(ctx).Infof("──────────────────────────────────────────────────────────")

                // attempting to include at most one crash:
                // if the current pod has crashed, then just print the current pod
                // if the current pod is live, print the current pod plus the last pod
                var s string
                if ms.Pod.ContainerReady </span><span class="cov8" title="1">{
                        s = string(ms.Pod.PreRestartLog) + string(ms.Pod.Log)
                }</span> else<span class="cov8" title="1"> {
                        s = string(ms.Pod.Log)
                }</span>
                <span class="cov8" title="1">logger.Get(ctx).Infof("%s", s)
                logger.Get(ctx).Infof("──────────────────────────────────────────────────────────")</span>
        }
}

type manifestErr struct {
        s string
}

func (e *manifestErr) Error() string <span class="cov8" title="1">{ return e.s }</span>

var _ error = &amp;manifestErr{}

func manifestErrf(format string, a ...interface{}) *manifestErr <span class="cov8" title="1">{
        return &amp;manifestErr{s: fmt.Sprintf(format, a...)}
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package engine

import (
        "context"
        "path/filepath"

        "github.com/windmilleng/tilt/internal/ignore"
        "github.com/windmilleng/tilt/internal/logger"
        "github.com/windmilleng/tilt/internal/model"
        "github.com/windmilleng/tilt/internal/store"
        "github.com/windmilleng/tilt/internal/watch"
)

type manifestFilesChangedAction struct {
        manifestName model.ManifestName
        files        []string
}

func (manifestFilesChangedAction) Action() {<span class="cov0" title="0">}</span>

type manifestNotifyCancel struct {
        manifest model.Manifest
        notify   watch.Notify
        cancel   func()
}

type WatchManager struct {
        watches        map[model.ManifestName]manifestNotifyCancel
        fsWatcherMaker FsWatcherMaker
        timerMaker     timerMaker
}

func NewWatchManager(watcherMaker FsWatcherMaker, timerMaker timerMaker) *WatchManager <span class="cov8" title="1">{
        return &amp;WatchManager{
                watches:        make(map[model.ManifestName]manifestNotifyCancel),
                fsWatcherMaker: watcherMaker,
                timerMaker:     timerMaker,
        }
}</span>

func (w *WatchManager) diff(ctx context.Context, st *store.Store) (setup []model.Manifest, teardown []model.Manifest) <span class="cov8" title="1">{
        state := st.RLockState()
        defer st.RUnlockState()

        setup = []model.Manifest{}
        teardown = []model.Manifest{}
        manifestsToProcess := make(map[model.ManifestName]model.Manifest, len(state.ManifestStates))
        for i, m := range state.ManifestStates </span><span class="cov8" title="1">{
                manifestsToProcess[i] = m.Manifest
        }</span>
        <span class="cov8" title="1">for n, state := range state.ManifestStates </span><span class="cov8" title="1">{
                _, ok := w.watches[n]
                if !ok </span><span class="cov8" title="1">{
                        setup = append(setup, state.Manifest)
                }</span>
                <span class="cov8" title="1">delete(manifestsToProcess, n)</span>
        }

        <span class="cov8" title="1">for _, m := range manifestsToProcess </span><span class="cov0" title="0">{
                teardown = append(teardown, m)
        }</span>

        <span class="cov8" title="1">return setup, teardown</span>
}

func (w *WatchManager) OnChange(ctx context.Context, st *store.Store) <span class="cov8" title="1">{
        setup, teardown := w.diff(ctx, st)

        for _, m := range teardown </span><span class="cov0" title="0">{
                p, ok := w.watches[m.Name]
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">err := p.notify.Close()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Get(ctx).Infof("Error closing watch: %v", err)
                }</span>
                <span class="cov0" title="0">p.cancel()
                delete(w.watches, m.Name)</span>
        }

        <span class="cov8" title="1">for _, manifest := range setup </span><span class="cov8" title="1">{
                watcher, err := w.fsWatcherMaker()
                if err != nil </span><span class="cov0" title="0">{
                        st.Dispatch(NewErrorAction(err))
                        continue</span>
                }

                <span class="cov8" title="1">localPaths := manifest.LocalPaths()

                for _, localPath := range localPaths </span><span class="cov8" title="1">{
                        err = watcher.Add(localPath)
                        if err != nil </span><span class="cov0" title="0">{
                                st.Dispatch(NewErrorAction(err))
                        }</span>
                }

                <span class="cov8" title="1">for _, cf := range manifest.ConfigFiles </span><span class="cov8" title="1">{
                        err = watcher.Add(cf)
                        if err != nil </span><span class="cov0" title="0">{
                                st.Dispatch(NewErrorAction(err))
                        }</span>
                }

                <span class="cov8" title="1">ctx, cancel := context.WithCancel(ctx)

                go w.dispatchFileChangesLoop(ctx, manifest, watcher, st)

                w.watches[manifest.Name] = manifestNotifyCancel{manifest, watcher, cancel}</span>
        }
}

func (w *WatchManager) dispatchFileChangesLoop(ctx context.Context, manifest model.Manifest, watcher watch.Notify, st *store.Store) <span class="cov8" title="1">{
        filter, err := ignore.CreateFileChangeFilter(manifest)
        if err != nil </span><span class="cov0" title="0">{
                st.Dispatch(NewErrorAction(err))
                return
        }</span>

        <span class="cov8" title="1">eventsCh := coalesceEvents(w.timerMaker, watcher.Events())

        for </span><span class="cov8" title="1">{
                select </span>{
                case err, ok := &lt;-watcher.Errors():<span class="cov8" title="1">
                        if !ok </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov8" title="1">st.Dispatch(NewErrorAction(err))</span>
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        return</span>

                case fsEvents, ok := &lt;-eventsCh:<span class="cov8" title="1">
                        if !ok </span><span class="cov0" title="0">{
                                return
                        }</span>

                        <span class="cov8" title="1">watchEvent := manifestFilesChangedAction{manifestName: manifest.Name}

                        for _, e := range fsEvents </span><span class="cov8" title="1">{
                                path, err := filepath.Abs(e.Path)
                                if err != nil </span><span class="cov0" title="0">{
                                        st.Dispatch(NewErrorAction(err))
                                        continue</span>
                                }
                                <span class="cov8" title="1">isIgnored, err := filter.Matches(path, false)
                                if err != nil </span><span class="cov0" title="0">{
                                        st.Dispatch(NewErrorAction(err))
                                        continue</span>
                                }
                                <span class="cov8" title="1">if !isIgnored </span><span class="cov8" title="1">{
                                        watchEvent.files = append(watchEvent.files, path)
                                }</span>
                        }

                        <span class="cov8" title="1">if len(watchEvent.files) &gt; 0 </span><span class="cov8" title="1">{
                                st.Dispatch(watchEvent)
                        }</span>
                }
        }
}

//makes an attempt to read some events from `eventChan` so that multiple file changes that happen at the same time
//from the user's perspective are grouped together.
func coalesceEvents(timerMaker timerMaker, eventChan &lt;-chan watch.FileEvent) &lt;-chan []watch.FileEvent <span class="cov8" title="1">{
        ret := make(chan []watch.FileEvent)
        go func() </span><span class="cov8" title="1">{
                defer close(ret)

                for </span><span class="cov8" title="1">{
                        event, ok := &lt;-eventChan
                        if !ok </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov8" title="1">events := []watch.FileEvent{event}

                        // keep grabbing changes until we've gone `watchBufferMinRestDuration` without seeing a change
                        minRestTimer := timerMaker(watchBufferMinRestDuration)

                        // but if we go too long before seeing a break (e.g., a process is constantly writing logs to that dir)
                        // then just send what we've got
                        timeout := timerMaker(watchBufferMaxDuration)

                        done := false
                        channelClosed := false
                        for !done &amp;&amp; !channelClosed </span><span class="cov8" title="1">{
                                select </span>{
                                case event, ok := &lt;-eventChan:<span class="cov8" title="1">
                                        if !ok </span><span class="cov0" title="0">{
                                                channelClosed = true
                                        }</span> else<span class="cov8" title="1"> {
                                                minRestTimer = timerMaker(watchBufferMinRestDuration)
                                                events = append(events, event)
                                        }</span>
                                case &lt;-minRestTimer:<span class="cov8" title="1">
                                        done = true</span>
                                case &lt;-timeout:<span class="cov8" title="1">
                                        done = true</span>
                                }
                        }
                        <span class="cov8" title="1">if len(events) &gt; 0 </span><span class="cov8" title="1">{
                                ret &lt;- events
                        }</span>

                        <span class="cov8" title="1">if channelClosed </span><span class="cov0" title="0">{
                                return
                        }</span>
                }

        }()
        <span class="cov8" title="1">return ret</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">// Code generated by Wire. DO NOT EDIT.

//go:generate wire
//+build !wireinject

package engine

import (
        context "context"
        wire "github.com/google/go-cloud/wire"
        build "github.com/windmilleng/tilt/internal/build"
        docker "github.com/windmilleng/tilt/internal/docker"
        k8s "github.com/windmilleng/tilt/internal/k8s"
        store "github.com/windmilleng/tilt/internal/store"
        synclet "github.com/windmilleng/tilt/internal/synclet"
        analytics "github.com/windmilleng/wmclient/pkg/analytics"
        dirs "github.com/windmilleng/wmclient/pkg/dirs"
)

// Injectors from wire.go:

func provideBuildAndDeployer(ctx context.Context, docker2 docker.DockerClient, k8s2 k8s.Client, dir *dirs.WindmillDir, env k8s.Env, updateMode UpdateModeFlag, sCli synclet.SyncletClient, shouldFallBackToImgBuild FallbackTester) (BuildAndDeployer, error) <span class="cov8" title="1">{
        store2 := store.NewStore()
        deployDiscovery := NewDeployDiscovery(k8s2, store2)
        syncletManager := NewSyncletManagerForTests(k8s2, sCli)
        syncletBuildAndDeployer := NewSyncletBuildAndDeployer(deployDiscovery, syncletManager)
        containerUpdater := build.NewContainerUpdater(docker2)
        memoryAnalytics := analytics.NewMemoryAnalytics()
        localContainerBuildAndDeployer := NewLocalContainerBuildAndDeployer(containerUpdater, memoryAnalytics, deployDiscovery)
        console := build.DefaultConsole()
        writer := build.DefaultOut()
        labels := _wireLabelsValue
        dockerImageBuilder := build.NewDockerImageBuilder(docker2, console, writer, labels)
        imageBuilder := build.DefaultImageBuilder(dockerImageBuilder)
        updateMode2, err := ProvideUpdateMode(updateMode, env)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">imageBuildAndDeployer := NewImageBuildAndDeployer(imageBuilder, k8s2, env, memoryAnalytics, updateMode2)
        buildOrder := DefaultBuildOrder(syncletBuildAndDeployer, localContainerBuildAndDeployer, imageBuildAndDeployer, env, updateMode2)
        compositeBuildAndDeployer := NewCompositeBuildAndDeployer(buildOrder, shouldFallBackToImgBuild)
        return compositeBuildAndDeployer, nil</span>
}

var (
        _wireLabelsValue = build.Labels{}
)

// wire.go:

var DeployerBaseWireSet = wire.NewSet(build.DefaultConsole, build.DefaultOut, wire.Value(build.Labels{}), build.DefaultImageBuilder, build.NewDockerImageBuilder, NewImageBuildAndDeployer, build.NewContainerUpdater, build.NewContainerResolver, NewSyncletBuildAndDeployer,
        NewLocalContainerBuildAndDeployer,
        DefaultBuildOrder,
        NewDeployDiscovery, wire.Bind(new(BuildAndDeployer), new(CompositeBuildAndDeployer)), NewCompositeBuildAndDeployer,
        ProvideUpdateMode, store.NewStore,
)

var DeployerWireSetTest = wire.NewSet(
        DeployerBaseWireSet,
        NewSyncletManagerForTests,
)

var DeployerWireSet = wire.NewSet(
        DeployerBaseWireSet,
        NewSyncletManager,
)
</pre>
		
		<pre class="file" id="file32" style="display: none">package git

import (
        "context"
        "path/filepath"
        "strings"

        "github.com/monochromegane/go-gitignore"
        "github.com/windmilleng/tilt/internal/ospath"
)

// Known feature differences from git:
// 1. does not use git config core.excludesfile
// 2. only looks for .gitignore in repo root, instead of all directories between dirname(file) and repo root
// 3. does not use .git/info/exclude
// 4. does not take index into account

// ignores files specified in .gitignore
type gitIgnoreTester struct {
        repoRoot      string
        ignoreMatcher gitignore.IgnoreMatcher
}

func (i *gitIgnoreTester) Matches(f string, isDir bool) (bool, error) <span class="cov8" title="1">{
        _, isChild := ospath.Child(i.repoRoot, f)
        if !isChild </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">return i.ignoreMatcher.Match(f, isDir), nil</span>
}

func NewGitIgnoreTesterFromContents(ctx context.Context, repoRoot string, gitignoreContents string) (*gitIgnoreTester, error) <span class="cov8" title="1">{
        absRoot, err := filepath.Abs(repoRoot)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">i := gitignore.NewGitIgnoreFromReader(repoRoot, strings.NewReader(gitignoreContents))

        return &amp;gitIgnoreTester{absRoot, i}, nil</span>
}

// ignores files specified in .gitignore plus any files in $ROOT/.git/
type repoIgnoreTester struct {
        repoRoot        string
        gitIgnoreTester *gitIgnoreTester
}

func (r repoIgnoreTester) Matches(f string, isDir bool) (bool, error) <span class="cov8" title="1">{
        // TODO(matt) what do we want to do with symlinks?
        absPath, err := filepath.Abs(f)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">if strings.HasPrefix(absPath, filepath.Join(r.repoRoot, ".git/")) </span><span class="cov8" title="1">{
                return true, nil
        }</span>

        <span class="cov8" title="1">return r.gitIgnoreTester.Matches(f, isDir)</span>
}

func NewRepoIgnoreTester(ctx context.Context, repoRoot string, gitignoreContents string) (*repoIgnoreTester, error) <span class="cov8" title="1">{
        g, err := NewGitIgnoreTesterFromContents(ctx, repoRoot, gitignoreContents)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;repoIgnoreTester{repoRoot, g}, nil</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package hud

type ShowErrorAction struct {
        // 1-based index of resource whose log should be printed
        ResourceNumber int
}

func (ShowErrorAction) Action() {<span class="cov0" title="0">}</span>

func NewShowErrorAction(resourceNumber int) ShowErrorAction <span class="cov0" title="0">{
        return ShowErrorAction{resourceNumber}
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">package hud

import (
        "context"
        "time"

        "github.com/windmilleng/tilt/internal/logger"
        "github.com/windmilleng/tilt/internal/store"

        "github.com/windmilleng/tilt/internal/hud/view"
)

var _ HeadsUpDisplay = (*FakeHud)(nil)

type FakeHud struct {
        LastView view.View
        Updates  chan view.View
        Canceled bool
        Closed   bool
        closeCh  chan interface{}
}

func NewFakeHud() *FakeHud <span class="cov0" title="0">{
        return &amp;FakeHud{
                Updates: make(chan view.View, 10),
                closeCh: make(chan interface{}),
        }
}</span>

func (h *FakeHud) Run(ctx context.Context, st *store.Store, refreshInterval time.Duration) error <span class="cov0" title="0">{
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0"></span>
        case &lt;-h.closeCh:<span class="cov0" title="0"></span>
        }
        <span class="cov0" title="0">h.Canceled = true
        return ctx.Err()</span>
}

func (h *FakeHud) SetNarrationMessage(ctx context.Context, msg string) {<span class="cov0" title="0">}</span>
func (h *FakeHud) Refresh(ctx context.Context)                         {<span class="cov0" title="0">}</span>

func (h *FakeHud) OnChange(ctx context.Context, st *store.Store) <span class="cov0" title="0">{
        state := st.RLockState()
        view := store.StateToView(state)
        st.RUnlockState()

        err := h.Update(view)
        if err != nil </span><span class="cov0" title="0">{
                logger.Get(ctx).Infof("Error updating HUD: %v", err)
        }</span>
}

func (h *FakeHud) Close() <span class="cov0" title="0">{
        h.Closed = true
        close(h.closeCh)
}</span>

func (h *FakeHud) Update(v view.View) error <span class="cov0" title="0">{
        h.LastView = v
        h.Updates &lt;- v
        return nil
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">package hud

import (
        "context"
        "sync"
        "time"

        "github.com/pkg/browser"
        "github.com/windmilleng/tcell"

        "github.com/pkg/errors"

        "github.com/windmilleng/tilt/internal/hud/view"
        "github.com/windmilleng/tilt/internal/logger"
        "github.com/windmilleng/tilt/internal/store"
)

// The main loop ensures the HUD updates at least this often
const DefaultRefreshInterval = 1 * time.Second

type HeadsUpDisplay interface {
        store.Subscriber

        Run(ctx context.Context, st *store.Store, refreshRate time.Duration) error
        Update(v view.View) error
        Close()
        SetNarrationMessage(ctx context.Context, msg string)
}

type Hud struct {
        a *ServerAdapter
        r *Renderer

        currentView view.View
        viewState   view.ViewState
        mu          sync.RWMutex
}

var _ HeadsUpDisplay = (*Hud)(nil)

func NewDefaultHeadsUpDisplay() (HeadsUpDisplay, error) <span class="cov0" title="0">{
        return &amp;Hud{
                r: NewRenderer(),
        }, nil
}</span>

func (h *Hud) SetNarrationMessage(ctx context.Context, msg string) <span class="cov0" title="0">{
        h.mu.Lock()
        defer h.mu.Unlock()
        viewState := h.viewState
        viewState.ShowNarration = true
        viewState.NarrationMessage = msg
        h.setViewState(ctx, viewState)
}</span>

func (h *Hud) Run(ctx context.Context, st *store.Store, refreshRate time.Duration) error <span class="cov0" title="0">{
        a, err := NewServer(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">h.a = a

        if refreshRate == 0 </span><span class="cov0" title="0">{
                refreshRate = DefaultRefreshInterval
        }</span>
        <span class="cov0" title="0">ticker := time.NewTicker(refreshRate)

        var screenEvents chan tcell.Event
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        h.Close()
                        err := ctx.Err()
                        if err != context.Canceled </span><span class="cov0" title="0">{
                                return err
                        }</span> else<span class="cov0" title="0"> {
                                return nil
                        }</span>
                case ready := &lt;-a.readyCh:<span class="cov0" title="0">
                        screenEvents, err = h.r.SetUp(ready, a.winchCh)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                case &lt;-a.winchCh:<span class="cov0" title="0">
                        h.Refresh(ctx)</span>
                case &lt;-a.streamClosedCh:<span class="cov0" title="0">
                        h.r.Reset()</span>
                case e := &lt;-screenEvents:<span class="cov0" title="0">
                        h.handleScreenEvent(ctx, st, e)</span>
                case &lt;-a.serverClosed:<span class="cov0" title="0">
                        return nil</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        h.Refresh(ctx)</span>
                }
        }
}

func (h *Hud) Close() <span class="cov0" title="0">{
        if h.a != nil </span><span class="cov0" title="0">{
                h.a.Close()
        }</span>
        <span class="cov0" title="0">h.r.Reset()</span>
}

func (h *Hud) handleScreenEvent(ctx context.Context, st *store.Store, ev tcell.Event) <span class="cov0" title="0">{
        h.mu.Lock()
        defer h.mu.Unlock()

        switch ev := ev.(type) </span>{
        case *tcell.EventKey:<span class="cov0" title="0">
                switch ev.Key() </span>{
                case tcell.KeyEscape:<span class="cov0" title="0">
                        h.Close()</span>
                case tcell.KeyRune:<span class="cov0" title="0">
                        switch r := ev.Rune(); </span>{
                        case r &gt;= '1' &amp;&amp; r &lt;= '9':<span class="cov0" title="0">
                                st.Dispatch(NewShowErrorAction(int(r - '0')))</span>
                        case r == 'b':<span class="cov0" title="0"> // "[B]rowser
                                // If we have an endpoint(s), open the first one
                                // TODO(nick): We might need some hints on what load balancer to
                                // open if we have multiple, or what path to default to on the opened manifest.
                                _, selected := h.selectedResource()
                                if len(selected.Endpoints) &gt; 0 </span><span class="cov0" title="0">{
                                        err := browser.OpenURL(selected.Endpoints[0])
                                        if err != nil </span><span class="cov0" title="0">{
                                                logger.Get(ctx).Infof("error opening url '%s' for resource '%s': %v",
                                                        selected.Endpoints[0], selected.Name, err)
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        logger.Get(ctx).Infof("no urls for resource '%s' ¯\\_(ツ)_/¯", selected.Name)
                                }</span>
                        }
                case tcell.KeyUp:<span class="cov0" title="0">
                        h.r.rty.ElementScroller("resources").UpElement()
                        h.refresh(ctx)</span>
                case tcell.KeyDown:<span class="cov0" title="0">
                        h.r.rty.ElementScroller("resources").DownElement()
                        h.refresh(ctx)</span>
                case tcell.KeyEnter:<span class="cov0" title="0">
                        selectedIdx, _ := h.selectedResource()
                        st.Dispatch(NewShowErrorAction(selectedIdx + 1))</span>
                }
        }
}

func (h *Hud) OnChange(ctx context.Context, st *store.Store) <span class="cov0" title="0">{
        state := st.RLockState()
        view := store.StateToView(state)
        st.RUnlockState()

        h.mu.Lock()
        defer h.mu.Unlock()
        h.setView(ctx, view)
}</span>

func (h *Hud) Refresh(ctx context.Context) <span class="cov0" title="0">{
        h.mu.Lock()
        defer h.mu.Unlock()
        h.refresh(ctx)
}</span>

// Must hold the lock
func (h *Hud) setView(ctx context.Context, view view.View) <span class="cov0" title="0">{
        h.currentView = view
        h.refresh(ctx)
}</span>

// Must hold the lock
func (h *Hud) setViewState(ctx context.Context, viewState view.ViewState) <span class="cov0" title="0">{
        h.viewState = viewState
        h.refresh(ctx)
}</span>

// Must hold the lock
func (h *Hud) refresh(ctx context.Context) <span class="cov0" title="0">{
        h.currentView.ViewState = h.viewState

        err := h.Update(h.currentView)
        if err != nil </span><span class="cov0" title="0">{
                logger.Get(ctx).Infof("Error updating HUD: %v", err)
        }</span>
}

func (h *Hud) Update(v view.View) error <span class="cov0" title="0">{
        err := h.r.Render(v)
        return errors.Wrap(err, "error rendering hud")
}</span>

func (h *Hud) selectedResource() (i int, resource view.Resource) <span class="cov0" title="0">{
        i = h.r.rty.ElementScroller("resources").GetSelectedIndex()
        if i &gt;= 0 &amp;&amp; i &lt; len(h.currentView.Resources) </span><span class="cov0" title="0">{
                resource = h.currentView.Resources[i]
        }</span>
        <span class="cov0" title="0">return i, resource</span>
}

var _ store.Subscriber = &amp;Hud{}
</pre>
		
		<pre class="file" id="file36" style="display: none">package hud

import (
        "fmt"
        "os"
        "strings"
        "sync"
        "time"

        "github.com/windmilleng/tcell"
        "github.com/windmilleng/tilt/internal/hud/view"
        "github.com/windmilleng/tilt/internal/rty"
)

type Renderer struct {
        rty    rty.RTY
        screen tcell.Screen
        mu     *sync.Mutex
}

func NewRenderer() *Renderer <span class="cov0" title="0">{
        return &amp;Renderer{
                mu: new(sync.Mutex),
        }
}</span>

func (r *Renderer) Render(v view.View) error <span class="cov8" title="1">{
        r.mu.Lock()
        defer r.mu.Unlock()
        if r.rty != nil </span><span class="cov8" title="1">{
                layout := r.layout(v)
                err := r.rty.Render(layout)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func formatPreciseDuration(d time.Duration) string <span class="cov0" title="0">{
        hours := int(d.Hours())
        if hours &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%dh", hours)
        }</span>

        <span class="cov0" title="0">minutes := int(d.Minutes())
        if minutes &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%dm", minutes)
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("%ds", int(d.Seconds()))</span>
}

func formatDuration(d time.Duration) string <span class="cov0" title="0">{
        hours := int(d.Hours())
        if hours &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%dh", hours)
        }</span>

        <span class="cov0" title="0">minutes := int(d.Minutes())
        if minutes &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%dm", minutes)
        }</span>

        <span class="cov0" title="0">return "&lt;1m"</span>
}

func formatFileList(files []string) string <span class="cov0" title="0">{
        const maxFilesToDisplay = 3

        var ret []string

        for i, f := range files </span><span class="cov0" title="0">{
                if i &gt; maxFilesToDisplay </span><span class="cov0" title="0">{
                        ret = append(ret, fmt.Sprintf("(%d more)", len(files)-maxFilesToDisplay))
                        break</span>
                }
                <span class="cov0" title="0">ret = append(ret, f)</span>
        }

        <span class="cov0" title="0">return strings.Join(ret, ", ")</span>
}

var cLightText = tcell.Color241
var cGood = tcell.ColorGreen
var cBad = tcell.ColorRed
var cPending = tcell.ColorYellow

var podStatusColors = map[string]tcell.Color{
        "Running":           cGood,
        "ContainerCreating": cPending,
        "Pending":           cPending,
        "Error":             cBad,
        "CrashLoopBackOff":  cBad,
}

func (r *Renderer) layout(v view.View) rty.Component <span class="cov8" title="1">{
        l := rty.NewFlexLayout(rty.DirVert)
        if v.ViewState.ShowNarration </span><span class="cov8" title="1">{
                l.Add(renderNarration(v.ViewState.NarrationMessage))
                l.Add(rty.NewLine())
        }</span>

        <span class="cov8" title="1">split := rty.NewFlexLayout(rty.DirHor)

        split.Add(r.renderResources(v.Resources))
        l.Add(split)

        return l</span>
}

func renderNarration(msg string) rty.Component <span class="cov8" title="1">{
        lines := rty.NewLines()
        l := rty.NewLine()
        l.Add(rty.TextString(msg))
        lines.Add(rty.NewLine())
        lines.Add(l)
        lines.Add(rty.NewLine())

        box := rty.Fg(rty.Bg(lines, tcell.ColorLightGrey), tcell.ColorBlack)
        return rty.NewFixedSize(box, rty.GROW, 3)
}</span>

func (r *Renderer) renderResources(rs []view.Resource) rty.Component <span class="cov8" title="1">{
        childNames := make([]string, len(rs))
        for i, r := range rs </span><span class="cov8" title="1">{
                childNames[i] = r.Name
        }</span>

        <span class="cov8" title="1">l, selectedResource := r.rty.RegisterElementScroll("resources", childNames)

        for _, r := range rs </span><span class="cov8" title="1">{
                l.Add(renderResource(r, selectedResource == r.Name))
        }</span>

        <span class="cov8" title="1">return l</span>
}

var spinnerChars = []string{"⠋", "⠙", "⠹", "⠸", "⠼", "⠴", "⠦", "⠧", "⠇", "⠏"}

func spinner() string <span class="cov0" title="0">{
        return spinnerChars[time.Now().Second()%len(spinnerChars)]
}</span>

func renderResource(r view.Resource, selected bool) rty.Component <span class="cov8" title="1">{
        layout := rty.NewConcatLayout(rty.DirVert)

        sb := rty.NewStringBuilder()
        if selected </span><span class="cov0" title="0">{
                sb.Text("▶ ")
        }</span> else<span class="cov8" title="1"> {
                sb.Text("  ")
        }</span>
        <span class="cov8" title="1">sb.Text(r.Name)
        const dashSize = 35
        sb.Fg(cLightText).Textf(" %s ", strings.Repeat("┄", dashSize-len(r.Name))).Fg(tcell.ColorDefault)
        if r.LastDeployTime.Equal(time.Time{}) </span><span class="cov8" title="1">{
                sb.Text("not deployed yet")
        }</span> else<span class="cov0" title="0"> {
                sb.Textf("deployed %s ago", formatDuration(time.Since(r.LastDeployTime)))
        }</span>

        <span class="cov8" title="1">layout.Add(sb.Build())

        if len(r.DirectoriesWatched) &gt; 0 </span><span class="cov8" title="1">{
                var dirs []string
                for _, s := range r.DirectoriesWatched </span><span class="cov8" title="1">{
                        dirs = append(dirs, fmt.Sprintf("%s/", s))
                }</span>
                <span class="cov8" title="1">sb := rty.NewStringBuilder()
                sb.Fg(cLightText).Textf("  (Watching %s)", strings.Join(dirs, " ")).Fg(tcell.ColorDefault)
                layout.Add(sb.Build())</span>
        }

        <span class="cov8" title="1">if !r.LastDeployTime.Equal(time.Time{}) </span><span class="cov0" title="0">{
                if len(r.LastDeployEdits) &gt; 0 </span><span class="cov0" title="0">{
                        sb := rty.NewStringBuilder()
                        sb.Fg(cLightText).Text(" Last Deployed Edits: ").Fg(tcell.ColorDefault)
                        sb.Text(formatFileList(r.LastDeployEdits))
                        layout.Add(sb.Build())
                }</span>
        }

        // Build Info ---------------------------------------
        <span class="cov8" title="1">var buildComponents []rty.Component

        if !r.CurrentBuildStartTime.Equal(time.Time{}) </span><span class="cov0" title="0">{
                sb := rty.NewStringBuilder()
                sb.Fg(cPending).Textf("In Progress %s", spinner()).Fg(tcell.ColorDefault)
                sb.Textf(" - For %s", formatDuration(time.Since(r.CurrentBuildStartTime)))
                if len(r.CurrentBuildEdits) &gt; 0 </span><span class="cov0" title="0">{
                        sb.Textf(" • Edits: %s", formatFileList(r.CurrentBuildEdits))
                }</span>
                <span class="cov0" title="0">buildComponents = append(buildComponents, sb.Build())</span>
        }

        <span class="cov8" title="1">if !r.PendingBuildSince.Equal(time.Time{}) </span><span class="cov0" title="0">{
                sb := rty.NewStringBuilder()
                sb.Fg(cPending).Text("Pending").Fg(tcell.ColorDefault)
                sb.Textf(" - For %s", formatDuration(time.Since(r.PendingBuildSince)))
                if len(r.PendingBuildEdits) &gt; 0 </span><span class="cov0" title="0">{
                        sb.Textf(" • Edits: %s", formatFileList(r.PendingBuildEdits))
                }</span>
                <span class="cov0" title="0">buildComponents = append(buildComponents, sb.Build())</span>
        }

        <span class="cov8" title="1">if !r.LastBuildFinishTime.Equal(time.Time{}) </span><span class="cov0" title="0">{
                sb := rty.NewStringBuilder()

                sb.Textf("Last build (done in %s) ended %s ago — ",
                        formatPreciseDuration(r.LastBuildDuration),
                        formatDuration(time.Since(r.LastBuildFinishTime)))

                if r.LastBuildError != "" </span><span class="cov0" title="0">{
                        sb.Fg(cBad).Text("ERR")
                }</span> else<span class="cov0" title="0"> {
                        sb.Fg(cGood).Text("OK")
                }</span>
                <span class="cov0" title="0">sb.Fg(tcell.ColorDefault)

                buildComponents = append(buildComponents, sb.Build())

                if r.LastBuildError != "" </span><span class="cov0" title="0">{
                        s := fmt.Sprintf("Error: %s", r.LastBuildError)
                        buildComponents = append(buildComponents, rty.TextString(s))
                }</span>
        }

        <span class="cov8" title="1">if len(buildComponents) == 0 </span><span class="cov8" title="1">{
                buildComponents = []rty.Component{rty.TextString("no build yet")}
        }</span>

        <span class="cov8" title="1">l := rty.NewLine()
        l.Add(rty.ColoredString("  BUILD: ", cLightText))
        l.Add(buildComponents[0])
        layout.Add(l)

        for _, c := range buildComponents[1:] </span><span class="cov0" title="0">{
                l := rty.NewLine()
                l.Add(rty.TextString("         "))
                l.Add(c)
                layout.Add(l)
        }</span>

        // Kubernetes Info ---------------------------------------
        <span class="cov8" title="1">if r.PodStatus != "" </span><span class="cov0" title="0">{
                podStatusColor, ok := podStatusColors[r.PodStatus]
                if !ok </span><span class="cov0" title="0">{
                        podStatusColor = tcell.ColorDefault
                }</span>

                <span class="cov0" title="0">sb := rty.NewStringBuilder()
                sb.Fg(cLightText).Text("    K8S: ").Fg(tcell.ColorDefault)
                sb.Textf("Pod [%s] • %s ago — ", r.PodName, formatDuration(time.Since(r.PodCreationTime)))
                sb.Fg(podStatusColor).Text(r.PodStatus).Fg(tcell.ColorDefault)

                // TODO(maia): show # restarts even if == 0 (in gray or green)?
                if r.PodRestarts &gt; 0 </span><span class="cov0" title="0">{
                        sb.Fg(cBad).Textf(" [%d restart(s)]", r.PodRestarts).Fg(tcell.ColorDefault)
                }</span>

                <span class="cov0" title="0">layout.Add(sb.Build())</span>
        }

        <span class="cov8" title="1">if len(r.Endpoints) != 0 </span><span class="cov0" title="0">{
                sb := rty.NewStringBuilder()
                sb.Textf("         %s", strings.Join(r.Endpoints, " "))
                layout.Add(sb.Build())
        }</span>

        <span class="cov8" title="1">layout.Add(rty.NewLine())

        return layout</span>
}

func (r *Renderer) SetUp(event ReadyEvent, sigwinch chan os.Signal) (chan tcell.Event, error) <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()

        // TODO(maia): pass term name along with ttyPath via RPC. Temporary hack:
        // get termName from current terminal, assume it's the same 🙈
        screen, err := tcell.NewScreenFromTty(event.ttyPath, sigwinch, os.Getenv("TERM"))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err = screen.Init(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">screenEvents := make(chan tcell.Event)
        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        screenEvents &lt;- screen.PollEvent()
                }</span>
        }()

        <span class="cov0" title="0">r.rty = rty.NewRTY(screen)

        r.screen = screen

        return screenEvents, nil</span>
}

func (r *Renderer) Reset() <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()

        if r.screen != nil </span><span class="cov0" title="0">{
                r.screen.Fini()
        }</span>

        <span class="cov0" title="0">r.screen = nil</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package hud

import (
        "context"
        "fmt"
        "log"
        "os"
        "syscall"

        "github.com/windmilleng/tilt/internal/hud/proto"
        "github.com/windmilleng/tilt/internal/network"
        "google.golang.org/grpc"
)

var _ proto.HudServer = (*ServerAdapter)(nil)

func NewServer(ctx context.Context) (*ServerAdapter, error) <span class="cov0" title="0">{
        socketPath, err := proto.LocateSocket()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">l, err := network.UnixListen(socketPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">grpcServer := grpc.NewServer()

        a := &amp;ServerAdapter{
                readyCh:        make(chan ReadyEvent),
                winchCh:        make(chan os.Signal),
                streamClosedCh: make(chan error),
                serverClosed:   make(chan interface{}, 1),
                server:         grpcServer,
                ctx:            ctx,
        }

        proto.RegisterHudServer(grpcServer, a)

        // TODO(dbentley): deal with error
        go func() </span><span class="cov0" title="0">{
                err := grpcServer.Serve(l)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("hud server error: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">return a, nil</span>
}

type ServerAdapter struct {
        readyCh        chan ReadyEvent
        winchCh        chan os.Signal
        streamClosedCh chan error
        server         *grpc.Server
        ctx            context.Context
        serverClosed   chan interface{}
}

type ReadyEvent struct {
        ttyPath string
        ctx     context.Context
}

func (a *ServerAdapter) Close() <span class="cov0" title="0">{
        select </span>{
        case &lt;-a.serverClosed:<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0">
                close(a.serverClosed)</span>
        }
        <span class="cov0" title="0">a.server.GracefulStop()</span>
}

func (a *ServerAdapter) ConnectHud(stream proto.Hud_ConnectHudServer) error <span class="cov0" title="0">{
        streamContext := stream.Context()

        msg, err := stream.Recv()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Expect first message to be a connect request
        <span class="cov0" title="0">connectMsg := msg.GetConnect()
        if connectMsg == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("expected a connect msg; got %T %v", msg, msg)
        }</span>

        <span class="cov0" title="0">ready := ReadyEvent{
                ttyPath: connectMsg.TtyPath,
                ctx:     streamContext,
        }
        a.readyCh &lt;- ready

        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        _, err := stream.Recv() // assume it's a window change message
                        if err != nil </span><span class="cov0" title="0">{
                                a.streamClosedCh &lt;- err
                                return
                        }</span>
                        <span class="cov0" title="0">a.winchCh &lt;- syscall.SIGWINCH</span>
                }
        }()

        <span class="cov0" title="0">select </span>{
        case &lt;-streamContext.Done():<span class="cov0" title="0"></span>
        case &lt;-a.ctx.Done():<span class="cov0" title="0"></span>
        case &lt;-a.serverClosed:<span class="cov0" title="0"></span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package k8s

import (
        "bytes"
        "context"
        "fmt"
        "io"
        "net/url"
        "os/exec"
        "strings"
        "time"

        "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/api/validation"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/watch"
        apiv1 "k8s.io/client-go/kubernetes/typed/core/v1"
        "k8s.io/client-go/rest"

        "github.com/docker/distribution/reference"
        "github.com/opentracing/opentracing-go"
        "github.com/pkg/browser"
        "github.com/windmilleng/tilt/internal/logger"
        "k8s.io/client-go/kubernetes"
        "k8s.io/client-go/tools/clientcmd"
)

type Namespace string
type PodID string
type ContainerID string
type ContainerName string
type NodeID string
type ServiceName string

const DefaultNamespace = Namespace("default")

func (pID PodID) Empty() bool    <span class="cov0" title="0">{ return pID.String() == "" }</span>
func (pID PodID) String() string <span class="cov8" title="1">{ return string(pID) }</span>

func (cID ContainerID) Empty() bool    <span class="cov0" title="0">{ return cID.String() == "" }</span>
func (cID ContainerID) String() string <span class="cov8" title="1">{ return string(cID) }</span>
func (cID ContainerID) ShortStr() string <span class="cov0" title="0">{
        if len(string(cID)) &gt; 10 </span><span class="cov0" title="0">{
                return string(cID)[:10]
        }</span>
        <span class="cov0" title="0">return string(cID)</span>
}

func (n ContainerName) String() string <span class="cov0" title="0">{ return string(n) }</span>

func (nID NodeID) String() string <span class="cov8" title="1">{ return string(nID) }</span>

func (n Namespace) String() string <span class="cov8" title="1">{
        if n == "" </span><span class="cov0" title="0">{
                return string(DefaultNamespace)
        }</span>
        <span class="cov8" title="1">return string(n)</span>
}

type Client interface {
        // Updates the entities, creating them if necessary.
        //
        // Tries to update them in-place if possible. But for certain resource types,
        // we might need to fallback to deleting and re-creating them.
        Upsert(ctx context.Context, entities []K8sEntity) error

        // Deletes all given entities
        Delete(ctx context.Context, entities []K8sEntity) error

        // Find all the pods that match the given image, namespace, and labels.
        PodsWithImage(ctx context.Context, image reference.NamedTagged, n Namespace, labels []LabelPair) ([]v1.Pod, error)

        // Find all the pods matching the given parameters, stopping on timeout or
        // when we have at least one pod.
        PollForPodsWithImage(ctx context.Context, image reference.NamedTagged, n Namespace, labels []LabelPair, timeout time.Duration) ([]v1.Pod, error)

        PodByID(ctx context.Context, podID PodID, n Namespace) (*v1.Pod, error)

        // Creates a channel where all changes to the pod are brodcast.
        // Takes a pod as input, to indicate the version of the pod where we start watching.
        WatchPod(ctx context.Context, pod *v1.Pod) (watch.Interface, error)

        // Streams the container logs
        ContainerLogs(ctx context.Context, podID PodID, cName ContainerName, n Namespace) (io.ReadCloser, error)

        // Gets the ID for the Node on which the specified Pod is running
        GetNodeForPod(ctx context.Context, podID PodID) (NodeID, error)

        // Finds the PodID for the instance of appName running on the same node as podID
        FindAppByNode(ctx context.Context, nodeID NodeID, appName string, options FindAppByNodeOptions) (PodID, error)

        // Waits for the LoadBalancerSpec to get a publicly available URL.
        ResolveLoadBalancer(ctx context.Context, lb LoadBalancerSpec) (LoadBalancer, error)

        // Opens a tunnel to the specified pod+port. Returns the tunnel's local port and a function that closes the tunnel
        ForwardPort(ctx context.Context, namespace Namespace, podID PodID, optionalLocalPort, remotePort int) (localPort int, closer func(), err error)

        WatchPods(ctx context.Context, lps []LabelPair) (&lt;-chan *v1.Pod, error)

        WatchServices(ctx context.Context, lps []LabelPair) (&lt;-chan *v1.Service, error)
}

type K8sClient struct {
        env           Env
        kubectlRunner kubectlRunner
        core          apiv1.CoreV1Interface
        restConfig    *rest.Config
        portForwarder PortForwarder
}

var _ Client = K8sClient{}

type PortForwarder func(ctx context.Context, restConfig *rest.Config, core apiv1.CoreV1Interface, namespace string, podID PodID, localPort int, remotePort int) (closer func(), err error)

func NewK8sClient(
        ctx context.Context,
        env Env,
        core apiv1.CoreV1Interface,
        restConfig *rest.Config,
        pf PortForwarder) K8sClient <span class="cov0" title="0">{

        // TODO(nick): I'm not happy about the way that pkg/browser uses global writers.
        writer := logger.Get(ctx).Writer(logger.DebugLvl)
        browser.Stdout = writer
        browser.Stderr = writer

        return K8sClient{
                env:           env,
                kubectlRunner: realKubectlRunner{},
                core:          core,
                restConfig:    restConfig,
                portForwarder: pf,
        }
}</span>

func (k K8sClient) ResolveLoadBalancer(ctx context.Context, lb LoadBalancerSpec) (LoadBalancer, error) <span class="cov0" title="0">{
        if k.env == EnvDockerDesktop &amp;&amp; len(lb.Ports) &gt; 0 </span><span class="cov0" title="0">{
                url, err := url.Parse(fmt.Sprintf("http://localhost:%d/", lb.Ports[0]))
                if err != nil </span><span class="cov0" title="0">{
                        return LoadBalancer{}, fmt.Errorf("hard-coded url failed to parse??? : %v", err)
                }</span>
                <span class="cov0" title="0">return LoadBalancer{
                        URL:  url,
                        Spec: lb,
                }, nil</span>
        }

        <span class="cov0" title="0">if k.env == EnvMinikube </span><span class="cov0" title="0">{
                return k.resolveLoadBalancerFromMinikube(ctx, lb)
        }</span>

        <span class="cov0" title="0">return k.resolveLoadBalancerFromK8sAPI(ctx, lb)</span>
}

func (k K8sClient) resolveLoadBalancerFromMinikube(ctx context.Context, lb LoadBalancerSpec) (LoadBalancer, error) <span class="cov0" title="0">{
        logger.Get(ctx).Infof("Waiting on minikube to resolve service: %s", lb.Name)

        intervalSec := "1" // 1s is the smallest polling interval we can set :raised_eyebrow:
        cmd := exec.CommandContext(ctx, "minikube", "service", lb.Name, "--url", "--interval", intervalSec)

        cmd.Stderr = logger.Get(ctx).Writer(logger.InfoLvl)

        out, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return LoadBalancer{}, fmt.Errorf("ResolveLoadBalancer: %v", err)
        }</span>
        <span class="cov0" title="0">url, err := url.Parse(strings.TrimSpace(string(out)))
        if err != nil </span><span class="cov0" title="0">{
                return LoadBalancer{}, fmt.Errorf("ResolveLoadBalancer: malformed url: %v", err)
        }</span>
        <span class="cov0" title="0">return LoadBalancer{
                URL:  url,
                Spec: lb,
        }, nil</span>
}

func ServiceURL(service *v1.Service) (*url.URL, error) <span class="cov0" title="0">{
        status := service.Status

        lbStatus := status.LoadBalancer

        port := service.Spec.Ports[0].Port

        // Documentation here is helpful:
        // https://godoc.org/k8s.io/api/core/v1#LoadBalancerIngress
        // GKE and OpenStack typically use IP-based load balancers.
        // AWS typically uses DNS-based load balancers.
        for _, ingress := range lbStatus.Ingress </span><span class="cov0" title="0">{
                urlString := ""
                if ingress.IP != "" </span><span class="cov0" title="0">{
                        urlString = fmt.Sprintf("http://%s:%d/", ingress.IP, port)
                }</span>

                <span class="cov0" title="0">if ingress.Hostname != "" </span><span class="cov0" title="0">{
                        urlString = fmt.Sprintf("http://%s:%d/", ingress.Hostname, port)
                }</span>

                <span class="cov0" title="0">if urlString == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">url, err := url.Parse(urlString)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("ResolveLoadBalancer: malformed url: %v", err)
                }</span>
                <span class="cov0" title="0">return url, nil</span>
        }

        <span class="cov0" title="0">return nil, nil</span>
}

func (k K8sClient) resolveLoadBalancerFromK8sAPI(ctx context.Context, lb LoadBalancerSpec) (LoadBalancer, error) <span class="cov0" title="0">{
        if len(lb.Ports) == 0 </span><span class="cov0" title="0">{
                return LoadBalancer{}, nil
        }</span>

        <span class="cov0" title="0">svc, err := k.core.Services(lb.Namespace.String()).Get(lb.Name, metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return LoadBalancer{}, fmt.Errorf("ResolveLoadBalancer#Services: %v", err)
        }</span>

        <span class="cov0" title="0">url, err := ServiceURL(svc)
        if err != nil </span><span class="cov0" title="0">{
                return LoadBalancer{}, err
        }</span>
        <span class="cov0" title="0">return LoadBalancer{
                URL:  url,
                Spec: lb,
        }, nil</span>
}

func (k K8sClient) Upsert(ctx context.Context, entities []K8sEntity) error <span class="cov0" title="0">{
        span, ctx := opentracing.StartSpanFromContext(ctx, "daemon-k8sUpsert")
        defer span.Finish()

        l := logger.Get(ctx)
        prefix := logger.Blue(l).Sprint("  │ ")
        l.Infof("%sApplying via kubectl", prefix)

        immutable := ImmutableEntities(entities)
        if len(immutable) &gt; 0 </span><span class="cov0" title="0">{
                _, stderr, err := k.actOnEntities(ctx, []string{"replace", "--force"}, immutable)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("kubectl replace: %v\nstderr: %s", err, stderr)
                }</span>
        }

        <span class="cov0" title="0">mutable := MutableEntities(entities)
        if len(mutable) &gt; 0 </span><span class="cov0" title="0">{
                _, stderr, err := k.actOnEntities(ctx, []string{"apply"}, mutable)
                if err != nil </span><span class="cov0" title="0">{
                        isImmutableFieldError := strings.Contains(stderr, validation.FieldImmutableErrorMsg)
                        if !isImmutableFieldError </span><span class="cov0" title="0">{
                                return fmt.Errorf("kubectl apply: %v\nstderr: %s", err, stderr)
                        }</span>

                        // If the kubectl apply failed due to an immutable field, fall back to kubectl replace --force.
                        <span class="cov0" title="0">l.Infof("%sFalling back to 'kubectl replace' on immutable field error", prefix)
                        _, stderr, err := k.actOnEntities(ctx, []string{"replace", "--force"}, mutable)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("kubectl replace: %v\nstderr: %s", err, stderr)
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func (k K8sClient) Delete(ctx context.Context, entities []K8sEntity) error <span class="cov0" title="0">{
        _, stderr, err := k.actOnEntities(ctx, []string{"delete"}, entities)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("kubectl delete: %v\nstderr: %s", err, stderr)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (k K8sClient) actOnEntities(ctx context.Context, cmdArgs []string, entities []K8sEntity) (stdout string, stderr string, err error) <span class="cov0" title="0">{
        args := append([]string{}, cmdArgs...)
        args = append(args, "-f", "-")

        rawYAML, err := SerializeYAML(entities)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("serializeYaml for kubectl %s: %v", cmdArgs, err)
        }</span>
        <span class="cov0" title="0">stdin := bytes.NewReader([]byte(rawYAML))

        return k.kubectlRunner.execWithStdin(ctx, args, stdin)</span>
}

func ProvideCoreInterface(cfg *rest.Config) (apiv1.CoreV1Interface, error) <span class="cov0" title="0">{
        clientSet, err := kubernetes.NewForConfig(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return clientSet.CoreV1(), nil</span>
}

func ProvideRESTClient(cfg *rest.Config) (apiv1.CoreV1Interface, error) <span class="cov0" title="0">{
        clientSet, err := kubernetes.NewForConfig(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return clientSet.CoreV1(), nil</span>
}

func ProvideRESTConfig() (*rest.Config, error) <span class="cov0" title="0">{
        rules := clientcmd.NewDefaultClientConfigLoadingRules()
        rules.DefaultClientConfig = &amp;clientcmd.DefaultClientConfig

        overrides := &amp;clientcmd.ConfigOverrides{}

        clientLoader := clientcmd.NewNonInteractiveDeferredLoadingClientConfig(
                rules,
                overrides)
        config, err := clientLoader.ClientConfig()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(
                        "could not get config for context (%q): %s", overrides.Context, err)
        }</span>

        <span class="cov0" title="0">return config, nil</span>
}

func ProvidePortForwarder() PortForwarder <span class="cov0" title="0">{
        return portForwarder
}</span>

func OpenService(ctx context.Context, client Client, lbSpec LoadBalancerSpec) error <span class="cov0" title="0">{
        lb, err := client.ResolveLoadBalancer(ctx, lbSpec)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if lb.URL == nil </span><span class="cov0" title="0">{
                logger.Get(ctx).Infof("Could not determine URL of service: %s", lbSpec.Name)
                return nil
        }</span>

        <span class="cov0" title="0">return browser.OpenURL(lb.URL.String())</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package k8s

import (
        "context"
        "fmt"
        "strings"

        "github.com/docker/distribution/reference"
        "github.com/pkg/errors"
        "github.com/windmilleng/tilt/internal/logger"
        "k8s.io/api/core/v1"
)

const ContainerIDPrefix = "docker://"

func WaitForContainerReady(ctx context.Context, client Client, pod *v1.Pod, ref reference.Named) (v1.ContainerStatus, error) <span class="cov8" title="1">{
        cStatus, err := waitForContainerReadyHelper(pod, ref)
        if err != nil </span><span class="cov0" title="0">{
                return v1.ContainerStatus{}, err
        }</span> else<span class="cov8" title="1"> if cStatus != (v1.ContainerStatus{}) </span><span class="cov8" title="1">{
                return cStatus, nil
        }</span>

        <span class="cov8" title="1">watch, err := client.WatchPod(ctx, pod)
        if err != nil </span><span class="cov0" title="0">{
                return v1.ContainerStatus{}, errors.Wrap(err, "WaitForContainerReady")
        }</span>
        <span class="cov8" title="1">defer watch.Stop()

        for true </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return v1.ContainerStatus{}, errors.Wrap(ctx.Err(), "WaitForContainerReady")</span>
                case event, ok := &lt;-watch.ResultChan():<span class="cov8" title="1">
                        if !ok </span><span class="cov0" title="0">{
                                return v1.ContainerStatus{}, fmt.Errorf("Container watch closed: %s", ref)
                        }</span>

                        <span class="cov8" title="1">obj := event.Object
                        pod, ok := obj.(*v1.Pod)
                        if !ok </span><span class="cov0" title="0">{
                                logger.Get(ctx).Debugf("Unexpected watch notification: %T", obj)
                                continue</span>
                        }

                        <span class="cov8" title="1">cStatus, err := waitForContainerReadyHelper(pod, ref)
                        if err != nil </span><span class="cov8" title="1">{
                                return v1.ContainerStatus{}, err
                        }</span> else<span class="cov8" title="1"> if cStatus != (v1.ContainerStatus{}) </span><span class="cov8" title="1">{
                                return cStatus, nil
                        }</span>
                }
        }
        <span class="cov0" title="0">panic("WaitForContainerReady")</span> // should never reach this state
}

func waitForContainerReadyHelper(pod *v1.Pod, ref reference.Named) (v1.ContainerStatus, error) <span class="cov8" title="1">{
        cStatus, err := ContainerMatching(pod, ref)
        if err != nil </span><span class="cov0" title="0">{
                return v1.ContainerStatus{}, errors.Wrap(err, "WaitForContainerReadyHelper")
        }</span>

        <span class="cov8" title="1">unschedulable, msg := IsUnschedulable(pod.Status)
        if unschedulable </span><span class="cov8" title="1">{
                return v1.ContainerStatus{}, fmt.Errorf("Container will never be ready: %s", msg)
        }</span>

        <span class="cov8" title="1">if IsContainerExited(pod.Status, cStatus) </span><span class="cov8" title="1">{
                return v1.ContainerStatus{}, fmt.Errorf("Container will never be ready: %s", ref)
        }</span>

        <span class="cov8" title="1">if !cStatus.Ready </span><span class="cov8" title="1">{
                return v1.ContainerStatus{}, nil
        }</span>

        <span class="cov8" title="1">return cStatus, nil</span>
}

// If true, this means the container is gone and will never recover.
func IsContainerExited(pod v1.PodStatus, container v1.ContainerStatus) bool <span class="cov8" title="1">{
        if pod.Phase == v1.PodSucceeded || pod.Phase == v1.PodFailed </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov8" title="1">if container.State.Terminated != nil </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">return false</span>
}

// Returns the error message if the pod is unschedulable
func IsUnschedulable(pod v1.PodStatus) (bool, string) <span class="cov8" title="1">{
        for _, cond := range pod.Conditions </span><span class="cov8" title="1">{
                if cond.Reason == v1.PodReasonUnschedulable </span><span class="cov8" title="1">{
                        return true, cond.Message
                }</span>
        }
        <span class="cov8" title="1">return false, ""</span>
}

func ContainerMatching(pod *v1.Pod, ref reference.Named) (v1.ContainerStatus, error) <span class="cov8" title="1">{
        for _, c := range pod.Status.ContainerStatuses </span><span class="cov8" title="1">{
                cRef, err := reference.ParseNormalizedNamed(c.Image)
                if err != nil </span><span class="cov0" title="0">{
                        return v1.ContainerStatus{}, errors.Wrap(err, "ContainerMatching")
                }</span>

                <span class="cov8" title="1">if cRef.Name() == ref.Name() </span><span class="cov8" title="1">{
                        return c, nil
                }</span>
        }
        <span class="cov8" title="1">return v1.ContainerStatus{}, nil</span>
}

func ContainerIDFromContainerStatus(status v1.ContainerStatus) (ContainerID, error) <span class="cov8" title="1">{
        id := status.ContainerID
        if id == "" </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov8" title="1">if !strings.HasPrefix(id, ContainerIDPrefix) </span><span class="cov0" title="0">{
                return "", fmt.Errorf("Malformed container ID: %s", id)
        }</span>
        <span class="cov8" title="1">return ContainerID(id[len(ContainerIDPrefix):]), nil</span>
}

func ContainerNameFromContainerStatus(status v1.ContainerStatus) ContainerName <span class="cov0" title="0">{
        return ContainerName(status.Name)
}</span>

func ContainerSpecOf(pod *v1.Pod, status v1.ContainerStatus) v1.Container <span class="cov0" title="0">{
        for _, spec := range pod.Spec.Containers </span><span class="cov0" title="0">{
                if spec.Name == status.Name </span><span class="cov0" title="0">{
                        return spec
                }</span>
        }
        <span class="cov0" title="0">return v1.Container{}</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package k8s

import (
        "net/url"
        "reflect"

        "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/schema"
)

type K8sEntity struct {
        Obj  runtime.Object
        Kind *schema.GroupVersionKind
}

func (e K8sEntity) Meta() metav1.ObjectMeta <span class="cov8" title="1">{
        objVal := reflect.ValueOf(e.Obj)
        if objVal.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                if objVal.IsNil() </span><span class="cov0" title="0">{
                        return metav1.ObjectMeta{}
                }</span>
                <span class="cov8" title="1">objVal = objVal.Elem()</span>
        }

        <span class="cov8" title="1">if objVal.Kind() != reflect.Struct </span><span class="cov0" title="0">{
                return metav1.ObjectMeta{}
        }</span>

        // Find a field with type ObjectMeta
        <span class="cov8" title="1">omType := reflect.TypeOf(metav1.ObjectMeta{})
        for i := 0; i &lt; objVal.NumField(); i++ </span><span class="cov8" title="1">{
                fieldVal := objVal.Field(i)
                if omType != fieldVal.Type() </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">if !fieldVal.CanInterface() </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">metadata, ok := fieldVal.Interface().(metav1.ObjectMeta)
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">return metadata</span>
        }
        <span class="cov0" title="0">return metav1.ObjectMeta{}</span>
}

func (e K8sEntity) Name() string <span class="cov8" title="1">{
        return e.Meta().Name
}</span>

func (e K8sEntity) Namespace() Namespace <span class="cov8" title="1">{
        n := e.Meta().Namespace
        if n == "" </span><span class="cov0" title="0">{
                return DefaultNamespace
        }</span>
        <span class="cov8" title="1">return Namespace(n)</span>
}

// Most entities can be updated once running, but a few cannot.
func (e K8sEntity) ImmutableOnceCreated() bool <span class="cov8" title="1">{
        if e.Kind != nil </span><span class="cov8" title="1">{
                // TODO(nick): Add more entities.
                return e.Kind.Kind == "Job"
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (e K8sEntity) DeepCopy() K8sEntity <span class="cov8" title="1">{
        // GroupVersionKind is a struct of string values, so dereferencing the pointer
        // is an adequate copy.
        kind := *e.Kind
        return K8sEntity{
                Obj:  e.Obj.DeepCopyObject(),
                Kind: &amp;kind,
        }
}</span>

func ImmutableEntities(entities []K8sEntity) []K8sEntity <span class="cov8" title="1">{
        result := make([]K8sEntity, 0)
        for _, e := range entities </span><span class="cov8" title="1">{
                if e.ImmutableOnceCreated() </span><span class="cov8" title="1">{
                        result = append(result, e)
                }</span>
        }
        <span class="cov8" title="1">return result</span>
}

func MutableEntities(entities []K8sEntity) []K8sEntity <span class="cov8" title="1">{
        result := make([]K8sEntity, 0)
        for _, e := range entities </span><span class="cov8" title="1">{
                if !e.ImmutableOnceCreated() </span><span class="cov8" title="1">{
                        result = append(result, e)
                }</span>
        }
        <span class="cov8" title="1">return result</span>
}

type LoadBalancerSpec struct {
        Name      string
        Namespace Namespace
        Ports     []int32
}

type LoadBalancer struct {
        Spec LoadBalancerSpec
        URL  *url.URL
}

func ToLoadBalancerSpecs(entities []K8sEntity) []LoadBalancerSpec <span class="cov8" title="1">{
        result := make([]LoadBalancerSpec, 0)
        for _, e := range entities </span><span class="cov8" title="1">{
                lb, ok := ToLoadBalancerSpec(e)
                if ok </span><span class="cov8" title="1">{
                        result = append(result, lb)
                }</span>
        }
        <span class="cov8" title="1">return result</span>
}

// Try to convert the current entity to a LoadBalancerSpec service
func ToLoadBalancerSpec(entity K8sEntity) (LoadBalancerSpec, bool) <span class="cov8" title="1">{
        service, ok := entity.Obj.(*v1.Service)
        if !ok </span><span class="cov8" title="1">{
                return LoadBalancerSpec{}, false
        }</span>

        <span class="cov8" title="1">meta := service.ObjectMeta
        name := meta.Name
        spec := service.Spec
        if spec.Type != v1.ServiceTypeLoadBalancer </span><span class="cov0" title="0">{
                return LoadBalancerSpec{}, false
        }</span>

        <span class="cov8" title="1">result := LoadBalancerSpec{
                Name:      name,
                Namespace: Namespace(meta.Namespace),
        }
        for _, portSpec := range spec.Ports </span><span class="cov8" title="1">{
                if portSpec.Port != 0 </span><span class="cov8" title="1">{
                        result.Ports = append(result.Ports, portSpec.Port)
                }</span>
        }

        <span class="cov8" title="1">if len(result.Ports) == 0 </span><span class="cov0" title="0">{
                return LoadBalancerSpec{}, false
        }</span>

        <span class="cov8" title="1">return result, true</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package k8s

import (
        "fmt"
        "os/exec"
        "strings"
)

type Env string

const (
        EnvUnknown       Env = "unknown"
        EnvGKE               = "gke"
        EnvMinikube          = "minikube"
        EnvDockerDesktop     = "docker-for-desktop"
)

func (e Env) IsLocalCluster() bool <span class="cov0" title="0">{
        return e == EnvMinikube || e == EnvDockerDesktop
}</span>

func DetectEnv() (Env, error) <span class="cov0" title="0">{
        cmd := exec.Command("kubectl", "config", "current-context")
        outputBytes, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                exitErr, isExit := err.(*exec.ExitError)
                if isExit </span><span class="cov0" title="0">{
                        return EnvUnknown, fmt.Errorf("DetectEnv failed. Output:\n%s", string(exitErr.Stderr))
                }</span>
                <span class="cov0" title="0">return EnvUnknown, fmt.Errorf("DetectEnv: %v", err)</span>
        }

        <span class="cov0" title="0">output := strings.TrimSpace(string(outputBytes))
        return EnvFromString(output), nil</span>
}

func EnvFromString(s string) Env <span class="cov8" title="1">{
        if s == EnvMinikube </span><span class="cov8" title="1">{
                return EnvMinikube
        }</span> else<span class="cov8" title="1"> if s == EnvDockerDesktop </span><span class="cov8" title="1">{
                return EnvDockerDesktop
        }</span> else<span class="cov8" title="1"> if strings.HasPrefix(s, EnvGKE) </span><span class="cov8" title="1">{
                // GKE context strings look like:
                // gke_blorg-dev_us-central1-b_blorg
                return EnvGKE
        }</span>
        <span class="cov8" title="1">return EnvUnknown</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package k8s

import (
        "fmt"
        "reflect"

        "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

func ExtractPods(obj interface{}) ([]*v1.PodSpec, error) <span class="cov8" title="1">{
        extracted, err := extractPointersOf(obj, reflect.TypeOf(v1.PodSpec{}))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">result := make([]*v1.PodSpec, len(extracted))
        for i, e := range extracted </span><span class="cov8" title="1">{
                c, ok := e.(*v1.PodSpec)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("extractPods: expected Pod, actual %T", e)
                }</span>
                <span class="cov8" title="1">result[i] = c</span>
        }
        <span class="cov8" title="1">return result, nil</span>
}

func extractObjectMetas(obj interface{}) ([]*metav1.ObjectMeta, error) <span class="cov8" title="1">{
        extracted, err := extractPointersOf(obj, reflect.TypeOf(metav1.ObjectMeta{}))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">result := make([]*metav1.ObjectMeta, len(extracted))
        for i, e := range extracted </span><span class="cov8" title="1">{
                c, ok := e.(*metav1.ObjectMeta)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("ExtractObjectMetas: expected ObjectMeta, actual %T", e)
                }</span>
                <span class="cov8" title="1">result[i] = c</span>
        }
        <span class="cov8" title="1">return result, nil</span>
}

func extractContainers(obj interface{}) ([]*v1.Container, error) <span class="cov8" title="1">{
        extracted, err := extractPointersOf(obj, reflect.TypeOf(v1.Container{}))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">result := make([]*v1.Container, len(extracted))
        for i, e := range extracted </span><span class="cov8" title="1">{
                c, ok := e.(*v1.Container)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("extractContainers: expected Container, actual %T", e)
                }</span>
                <span class="cov8" title="1">result[i] = c</span>
        }
        <span class="cov8" title="1">return result, nil</span>
}

// Get pointers to all the container specs in this object.
func extractPointersOf(obj interface{}, pType reflect.Type) ([]interface{}, error) <span class="cov8" title="1">{
        v := reflect.ValueOf(obj)
        result := make([]interface{}, 0)

        // Recursively iterate over the struct fields.
        var extract func(v reflect.Value) error
        extract = func(v reflect.Value) error </span><span class="cov8" title="1">{
                switch v.Kind() </span>{
                case reflect.Ptr, reflect.Interface:<span class="cov8" title="1">
                        if v.IsNil() </span><span class="cov8" title="1">{
                                return nil
                        }</span>
                        <span class="cov8" title="1">return extract(v.Elem())</span>

                case reflect.Struct:<span class="cov8" title="1">
                        if v.Type() == pType </span><span class="cov8" title="1">{
                                if !v.CanAddr() </span><span class="cov0" title="0">{
                                        return fmt.Errorf("Error addressing: %v", v)
                                }</span>
                                <span class="cov8" title="1">result = append(result, v.Addr().Interface())
                                return nil</span>
                        }

                        <span class="cov8" title="1">for i := 0; i &lt; v.NumField(); i++ </span><span class="cov8" title="1">{
                                field := v.Field(i)
                                err := extract(field)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                        <span class="cov8" title="1">return nil</span>

                case reflect.Slice:<span class="cov8" title="1">
                        for i := 0; i &lt; v.Len(); i++ </span><span class="cov8" title="1">{
                                field := v.Index(i)
                                err := extract(field)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                        <span class="cov8" title="1">return nil</span>

                }
                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov8" title="1">err := extract(v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package k8s

import (
        "bytes"
        "context"
        "fmt"
        "io"
        "time"

        "github.com/docker/distribution/reference"
        "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/watch"
)

// A magic constant. If the docker client returns this constant, we always match
// even if the container doesn't have the correct image name.
const MagicTestContainerID = "tilt-testcontainer"

var _ Client = &amp;FakeK8sClient{}

type FakeK8sClient struct {
        Yaml        string
        DeletedYaml string
        Lb          LoadBalancerSpec

        PodsWithImageResp         PodID
        PodsWithImageError        error
        PollForPodsWithImageDelay time.Duration

        LastPodQueryNamespace Namespace
        LastPodQueryImage     reference.NamedTagged

        PodLogs            string
        ContainerLogsError error

        LastForwardPortPodID      PodID
        LastForwardPortRemotePort int
}

func (c *FakeK8sClient) WatchServices(ctx context.Context, lps []LabelPair) (&lt;-chan *v1.Service, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

func (c *FakeK8sClient) WatchPods(ctx context.Context, lps []LabelPair) (&lt;-chan *v1.Pod, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

func NewFakeK8sClient() *FakeK8sClient <span class="cov0" title="0">{
        return &amp;FakeK8sClient{}
}</span>

func (c *FakeK8sClient) ResolveLoadBalancer(ctx context.Context, lb LoadBalancerSpec) (LoadBalancer, error) <span class="cov0" title="0">{
        c.Lb = lb
        return LoadBalancer{}, nil
}</span>

func (c *FakeK8sClient) Upsert(ctx context.Context, entities []K8sEntity) error <span class="cov0" title="0">{
        yaml, err := SerializeYAML(entities)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("kubectl apply: %v", err)
        }</span>
        <span class="cov0" title="0">c.Yaml = yaml
        return nil</span>
}

func (c *FakeK8sClient) Delete(ctx context.Context, entities []K8sEntity) error <span class="cov0" title="0">{
        yaml, err := SerializeYAML(entities)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("kubectl delete: %v", err)
        }</span>
        <span class="cov0" title="0">c.DeletedYaml = yaml
        return nil</span>
}

func (c *FakeK8sClient) SetPodsWithImageResp(pID PodID) <span class="cov0" title="0">{
        c.PodsWithImageResp = pID
}</span>

func (c *FakeK8sClient) WatchPod(ctx context.Context, pod *v1.Pod) (watch.Interface, error) <span class="cov0" title="0">{
        return watch.NewEmptyWatch(), nil
}</span>

func (c *FakeK8sClient) ContainerLogs(ctx context.Context, pID PodID, cName ContainerName, n Namespace) (io.ReadCloser, error) <span class="cov0" title="0">{
        if c.ContainerLogsError != nil </span><span class="cov0" title="0">{
                return nil, c.ContainerLogsError
        }</span>
        <span class="cov0" title="0">return BufferCloser{bytes.NewBufferString(c.PodLogs)}, nil</span>
}

func (c *FakeK8sClient) PodByID(ctx context.Context, pID PodID, n Namespace) (*v1.Pod, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

func FakePodStatus(image reference.NamedTagged, phase string) v1.PodStatus <span class="cov0" title="0">{
        return v1.PodStatus{
                Phase: v1.PodPhase(phase),
                ContainerStatuses: []v1.ContainerStatus{
                        {
                                Name:        "main",
                                ContainerID: "docker://" + MagicTestContainerID,
                                Image:       image.String(),
                                Ready:       true,
                        },
                        {
                                Name:        "tilt-synclet",
                                ContainerID: "docker://tilt-testsynclet",
                                // can't use the constants in synclet because that would create a dep cycle
                                Image: "gcr.io/windmill-public-containers/tilt-synclet:latest",
                                Ready: true,
                        },
                },
        }
}</span>

func FakePodSpec(image reference.NamedTagged) v1.PodSpec <span class="cov0" title="0">{
        return v1.PodSpec{
                Containers: []v1.Container{
                        {
                                Name:  "main",
                                Image: image.String(),
                                Ports: []v1.ContainerPort{
                                        {
                                                ContainerPort: 8080,
                                        },
                                },
                        },
                        {
                                Name:  "tilt-synclet",
                                Image: "gcr.io/windmill-public-containers/tilt-synclet:latest",
                        },
                },
        }
}</span>

func (c *FakeK8sClient) PodsWithImage(ctx context.Context, image reference.NamedTagged, n Namespace, labels []LabelPair) ([]v1.Pod, error) <span class="cov0" title="0">{
        c.LastPodQueryImage = image
        c.LastPodQueryNamespace = n

        if c.PodsWithImageError != nil </span><span class="cov0" title="0">{
                return nil, c.PodsWithImageError
        }</span>

        <span class="cov0" title="0">status := FakePodStatus(image, "Running")
        spec := FakePodSpec(image)

        if !c.PodsWithImageResp.Empty() </span><span class="cov0" title="0">{
                res := c.PodsWithImageResp
                c.PodsWithImageResp = ""
                return []v1.Pod{
                        {
                                ObjectMeta: metav1.ObjectMeta{
                                        Name:   string(res),
                                        Labels: makeLabelSet(labels),
                                },
                                Status: status,
                                Spec:   spec,
                        },
                }, nil
        }</span>
        <span class="cov0" title="0">return []v1.Pod{
                {
                        ObjectMeta: metav1.ObjectMeta{
                                Name:   "pod",
                                Labels: makeLabelSet(labels),
                        },
                        Status: status,
                        Spec:   spec,
                },
        }, nil</span>
}

func (c *FakeK8sClient) SetPollForPodsWithImageDelay(dur time.Duration) <span class="cov0" title="0">{
        c.PollForPodsWithImageDelay = dur
}</span>

func (c *FakeK8sClient) PollForPodsWithImage(ctx context.Context, image reference.NamedTagged, n Namespace, labels []LabelPair, timeout time.Duration) ([]v1.Pod, error) <span class="cov0" title="0">{
        defer c.SetPollForPodsWithImageDelay(0)

        if c.PollForPodsWithImageDelay &gt; timeout </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("timeout polling for pod (delay %s &gt; timeout %s)",
                        c.PollForPodsWithImageDelay.String(), timeout.String())
        }</span>

        <span class="cov0" title="0">time.Sleep(c.PollForPodsWithImageDelay)
        return c.PodsWithImage(ctx, image, n, labels)</span>
}

func (c *FakeK8sClient) applyWasCalled() bool <span class="cov0" title="0">{
        return c.Yaml != ""
}</span>

func (c *FakeK8sClient) FindAppByNode(ctx context.Context, nodeID NodeID, appName string, options FindAppByNodeOptions) (PodID, error) <span class="cov0" title="0">{
        return PodID("pod2"), nil
}</span>

func (c *FakeK8sClient) GetNodeForPod(ctx context.Context, podID PodID) (NodeID, error) <span class="cov0" title="0">{
        return NodeID("node"), nil
}</span>

func (c *FakeK8sClient) ForwardPort(ctx context.Context, namespace Namespace, podID PodID, optionalLocalPort, remotePort int) (int, func(), error) <span class="cov0" title="0">{
        c.LastForwardPortPodID = podID
        c.LastForwardPortRemotePort = remotePort
        return optionalLocalPort, func() </span>{<span class="cov0" title="0">}</span>, nil
}

type BufferCloser struct {
        *bytes.Buffer
}

func (b BufferCloser) Close() error <span class="cov0" title="0">{
        return nil
}</span>

var _ io.ReadCloser = BufferCloser{}
</pre>
		
		<pre class="file" id="file44" style="display: none">package k8s

import (
        "fmt"

        "github.com/docker/distribution/reference"
        "k8s.io/api/core/v1"
)

// Iterate through the fields of a k8s entity and
// replace the image pull policy on all images.
func InjectImagePullPolicy(entity K8sEntity, policy v1.PullPolicy) (K8sEntity, error) <span class="cov8" title="1">{
        entity = entity.DeepCopy()
        containers, err := extractContainers(&amp;entity)
        if err != nil </span><span class="cov0" title="0">{
                return K8sEntity{}, err
        }</span>

        <span class="cov8" title="1">for _, container := range containers </span><span class="cov8" title="1">{
                container.ImagePullPolicy = policy
        }</span>
        <span class="cov8" title="1">return entity, nil</span>
}

// Iterate through the fields of a k8s entity and
// replace a image name with its digest.
//
// policy: The pull policy to set on the replaced image.
//   When working with a local k8s cluster, we want to set this to Never,
//   to ensure that k8s fails hard if the image is missing from docker.
//
// Returns: the new entity, whether the image was replaced, and an error.
func InjectImageDigest(entity K8sEntity, injectRef reference.Named, policy v1.PullPolicy) (K8sEntity, bool, error) <span class="cov8" title="1">{
        entity = entity.DeepCopy()

        // NOTE(nick): For some reason, if you have a reference with a digest,
        // kubernetes will never find it in the local registry and always tries to do a
        // pull. It's not clear to me why it behaves this way.
        //
        // There is not a simple way to resolve this problem at this level of the
        // API. In some cases, the digest won't matter and the name/tag will be
        // enough. In other cases, the digest will be critical if we don't have good
        // synchronization that the name/tag currently matches the digest.
        //
        // For now, we try to detect this case and push the error up to the caller.
        _, hasDigest := injectRef.(reference.Digested)
        if hasDigest &amp;&amp; policy == v1.PullNever </span><span class="cov8" title="1">{
                return K8sEntity{}, false, fmt.Errorf("INTERNAL TILT ERROR: Cannot set PullNever with digest")
        }</span>

        <span class="cov8" title="1">containers, err := extractContainers(&amp;entity)
        if err != nil </span><span class="cov0" title="0">{
                return K8sEntity{}, false, err
        }</span>

        <span class="cov8" title="1">replaced := false
        for _, container := range containers </span><span class="cov8" title="1">{
                existingRef, err := reference.ParseNormalizedNamed(container.Image)
                if err != nil </span><span class="cov0" title="0">{
                        return K8sEntity{}, false, err
                }</span>

                <span class="cov8" title="1">if existingRef.Name() == injectRef.Name() </span><span class="cov8" title="1">{
                        container.Image = injectRef.String()
                        container.ImagePullPolicy = policy
                        replaced = true
                }</span>
        }
        <span class="cov8" title="1">return entity, replaced, nil</span>
}

func PodContainsRef(pod *v1.PodSpec, ref reference.Named) (bool, error) <span class="cov0" title="0">{
        for _, container := range pod.Containers </span><span class="cov0" title="0">{
                existingRef, err := reference.ParseNormalizedNamed(container.Image)
                if err != nil </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("PodContainsRef: %v", err)
                }</span>

                <span class="cov0" title="0">if existingRef.Name() == ref.Name() </span><span class="cov0" title="0">{
                        return true, nil
                }</span>
        }
        <span class="cov0" title="0">return false, nil</span>
}

func ParseNamedTagged(s string) (reference.NamedTagged, error) <span class="cov8" title="1">{
        ref, err := reference.Parse(s)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parsing %s: %v", s, err)
        }</span>

        <span class="cov8" title="1">nt, ok := ref.(reference.NamedTagged)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not parse ref %s as NamedTagged", ref)
        }</span>
        <span class="cov8" title="1">return nt, nil</span>
}

func MustParseNamedTagged(s string) reference.NamedTagged <span class="cov8" title="1">{
        nt, err := ParseNamedTagged(s)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">return nt</span>
}

func MustParseNamed(s string) reference.Named <span class="cov0" title="0">{
        n, err := reference.ParseNamed(s)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return n</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package k8s

import (
        "bytes"
        "context"
        "io"
        "os/exec"
)

type kubectlRunner interface {
        exec(ctx context.Context, argv []string) (stdout string, stderr string, err error)
        execWithStdin(ctx context.Context, argv []string, stdin io.Reader) (stdout string, stderr string, err error)
}

type realKubectlRunner struct{}

var _ kubectlRunner = realKubectlRunner{}

func (k realKubectlRunner) exec(ctx context.Context, args []string) (stdout string, stderr string, err error) <span class="cov0" title="0">{
        c := exec.CommandContext(ctx, "kubectl", args...)

        stdoutBuf := &amp;bytes.Buffer{}
        stderrBuf := &amp;bytes.Buffer{}
        c.Stdout = stdoutBuf
        c.Stderr = stderrBuf

        err = c.Run()
        return stdoutBuf.String(), stderrBuf.String(), err
}</span>

func (k realKubectlRunner) execWithStdin(ctx context.Context, args []string, stdin io.Reader) (stdout string, stderr string, err error) <span class="cov0" title="0">{
        c := exec.CommandContext(ctx, "kubectl", args...)
        c.Stdin = stdin

        stdoutBuf := &amp;bytes.Buffer{}
        stderrBuf := &amp;bytes.Buffer{}
        c.Stdout = stdoutBuf
        c.Stderr = stderrBuf

        err = c.Run()
        return stdoutBuf.String(), stderrBuf.String(), err
}</span>
</pre>
		
		<pre class="file" id="file46" style="display: none">package k8s

import (
        "k8s.io/apimachinery/pkg/labels"
)

type LabelPair struct {
        Key   string
        Value string
}

func makeLabelSet(lps []LabelPair) labels.Set <span class="cov8" title="1">{
        ls := labels.Set{}
        for _, lp := range lps </span><span class="cov8" title="1">{
                ls[lp.Key] = lp.Value
        }</span>
        <span class="cov8" title="1">return ls</span>
}

func makeLabelSelector(lps []LabelPair) string <span class="cov8" title="1">{
        return labels.SelectorFromSet(makeLabelSet(lps)).String()
}</span>

func InjectLabels(entity K8sEntity, labels []LabelPair) (K8sEntity, error) <span class="cov8" title="1">{
        entity = entity.DeepCopy()
        metas, err := extractObjectMetas(&amp;entity)
        if err != nil </span><span class="cov0" title="0">{
                return K8sEntity{}, err
        }</span>

        <span class="cov8" title="1">for _, meta := range metas </span><span class="cov8" title="1">{
                for _, label := range labels </span><span class="cov8" title="1">{
                        if meta.Labels == nil </span><span class="cov8" title="1">{
                                meta.Labels = make(map[string]string, 1)
                        }</span>
                        <span class="cov8" title="1">meta.Labels[label.Key] = label.Value</span>
                }
        }
        <span class="cov8" title="1">return entity, nil</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package k8s

import (
        "bufio"
        "context"
        "fmt"
        "io"
        "strings"
        "time"

        "github.com/docker/distribution/reference"
        "github.com/opentracing/opentracing-go"
        "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/watch"
)

func (k K8sClient) WatchPod(ctx context.Context, pod *v1.Pod) (watch.Interface, error) <span class="cov8" title="1">{
        podAPI := k.core.Pods(NamespaceFromPod(pod).String())
        podID := PodIDFromPod(pod)
        fieldSelector := fmt.Sprintf("metadata.name=%s", podID)
        watchOptions := metav1.ListOptions{
                FieldSelector:   fieldSelector,
                Watch:           true,
                ResourceVersion: pod.ObjectMeta.ResourceVersion,
        }
        return podAPI.Watch(watchOptions)
}</span>

func (k K8sClient) ContainerLogs(ctx context.Context, pID PodID, cName ContainerName, n Namespace) (io.ReadCloser, error) <span class="cov0" title="0">{
        options := &amp;v1.PodLogOptions{
                Container: cName.String(),
                Follow:    true,
        }
        req := k.core.Pods(n.String()).GetLogs(pID.String(), options)
        return req.Stream()
}</span>

func (k K8sClient) PodByID(ctx context.Context, pID PodID, n Namespace) (*v1.Pod, error) <span class="cov0" title="0">{
        return k.core.Pods(n.String()).Get(pID.String(), metav1.GetOptions{})
}</span>

func (k K8sClient) PollForPodsWithImage(ctx context.Context, image reference.NamedTagged, n Namespace, labels []LabelPair, timeout time.Duration) ([]v1.Pod, error) <span class="cov8" title="1">{
        span, ctx := opentracing.StartSpanFromContext(ctx, "k8sClient-PollForPodsWithImage")
        span.SetTag("img", image.String())
        defer span.Finish()

        start := time.Now()
        for time.Since(start) &lt; timeout </span><span class="cov8" title="1">{
                pod, err := k.PodsWithImage(ctx, image, n, labels)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">if pod != nil </span><span class="cov8" title="1">{
                        return pod, nil
                }</span>
        }

        <span class="cov8" title="1">return nil, fmt.Errorf("timed out polling for pod running image %s (after %s)",
                image.String(), timeout)</span>
}

// PodsWithImage returns the ID of the pod running the given image. If too many matches, throw
// an error. If no matches, return nil -- nothing is wrong, we just didn't find a result.
func (k K8sClient) PodsWithImage(ctx context.Context, image reference.NamedTagged, n Namespace, labels []LabelPair) ([]v1.Pod, error) <span class="cov8" title="1">{
        span, ctx := opentracing.StartSpanFromContext(ctx, "k8sClient-PodsWithImage")
        defer span.Finish()

        podList, err := k.core.Pods(n.String()).List(metav1.ListOptions{
                LabelSelector: makeLabelSelector(labels),
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("PodsWithImage: %v", err)
        }</span>

        <span class="cov8" title="1">ip := podMap(podList)
        pods, ok := ip[image.String()]
        if !ok </span><span class="cov8" title="1">{
                // Nothing's wrong, we just didn't find a match.
                return nil, nil
        }</span>
        <span class="cov8" title="1">return pods, nil</span>
}

func podMap(podList *v1.PodList) map[string][]v1.Pod <span class="cov8" title="1">{
        ip := make(map[string][]v1.Pod, 0)
        for _, p := range podList.Items </span><span class="cov8" title="1">{
                for _, c := range p.Spec.Containers </span><span class="cov8" title="1">{
                        ip[c.Image] = append(ip[c.Image], p)
                }</span>
        }
        <span class="cov8" title="1">return ip</span>
}

func PodIDFromPod(pod *v1.Pod) PodID <span class="cov8" title="1">{
        return PodID(pod.ObjectMeta.Name)
}</span>

func NamespaceFromPod(pod *v1.Pod) Namespace <span class="cov8" title="1">{
        return Namespace(pod.ObjectMeta.Namespace)
}</span>

func NodeIDFromPod(pod *v1.Pod) NodeID <span class="cov0" title="0">{
        return NodeID(pod.Spec.NodeName)
}</span>

func (k K8sClient) GetNodeForPod(ctx context.Context, podID PodID) (NodeID, error) <span class="cov8" title="1">{
        jsonPath := "-o=jsonpath={.spec.nodeName}"
        stdout, stderr, err := k.kubectlRunner.exec(ctx, []string{"get", "pods", podID.String(), jsonPath})

        if err != nil </span><span class="cov8" title="1">{
                return NodeID(""), fmt.Errorf("error finding node for pod '%s': %v, stderr: '%s'", podID.String(), err.Error(), stderr)
        }</span>

        <span class="cov8" title="1">lines := nonEmptyLines(stdout)

        if len(lines) == 0 </span><span class="cov8" title="1">{
                return NodeID(""), fmt.Errorf("kubectl output did not contain a node name for pod '%s': '%s'", podID, stdout)
        }</span> else<span class="cov8" title="1"> if len(lines) &gt; 1 </span><span class="cov8" title="1">{
                return NodeID(""), fmt.Errorf("kubectl returned multiple nodes for pod '%s': '%s'", podID, stdout)
        }</span> else<span class="cov8" title="1"> {
                return NodeID(lines[0]), nil
        }</span>
}

type FindAppByNodeOptions struct {
        Namespace string
        Owner     string
}

type MultipleAppsFoundError struct {
        filterDesc string
        pods       []string
}

func (m MultipleAppsFoundError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("found multiple apps matching %s: '%s'", m.filterDesc, m.pods)
}</span>

func (k K8sClient) FindAppByNode(ctx context.Context, nodeID NodeID, appName string, options FindAppByNodeOptions) (PodID, error) <span class="cov8" title="1">{
        jsonPath := fmt.Sprintf(`-o=jsonpath={range .items[?(@.spec.nodeName=="%s")]}{.metadata.name}{"\n"}`, nodeID)

        filterDesc := fmt.Sprintf("name '%s', node '%s'", appName, nodeID.String())

        labelArg := fmt.Sprintf("-lapp=%s", appName)
        if len(options.Owner) &gt; 0 </span><span class="cov8" title="1">{
                labelArg += fmt.Sprintf(",owner=%s", options.Owner)
                filterDesc += fmt.Sprintf(", owner '%s'", options.Owner)
        }</span>

        <span class="cov8" title="1">args := append([]string{"get", "pods", labelArg})

        if len(options.Namespace) &gt; 0 </span><span class="cov8" title="1">{
                args = append(args, fmt.Sprintf("--namespace=%s", options.Namespace))
                filterDesc += fmt.Sprintf(", namespace '%s'", options.Namespace)
        }</span>
        <span class="cov8" title="1">args = append(args, jsonPath)

        stdout, stderr, err := k.kubectlRunner.exec(ctx, args)

        if err != nil </span><span class="cov8" title="1">{
                return PodID(""), fmt.Errorf("error finding app with %s: %v, stderr: '%s'", filterDesc, err.Error(), stderr)
        }</span>

        <span class="cov8" title="1">lines := nonEmptyLines(stdout)

        if len(lines) == 0 </span><span class="cov8" title="1">{
                return PodID(""), fmt.Errorf("unable to find any apps with %s", filterDesc)
        }</span> else<span class="cov8" title="1"> if len(lines) &gt; 1 </span><span class="cov8" title="1">{
                return PodID(""), MultipleAppsFoundError{filterDesc, lines}
        }</span> else<span class="cov8" title="1"> {
                return PodID(lines[0]), nil
        }</span>
}

func nonEmptyLines(s string) []string <span class="cov8" title="1">{
        scanner := bufio.NewScanner(strings.NewReader(s))
        scanner.Split(bufio.ScanWords)

        var ret []string

        for scanner.Scan() </span><span class="cov8" title="1">{
                ret = append(ret, scanner.Text())
        }</span>

        <span class="cov8" title="1">return ret</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package k8s

import (
        "context"
        "fmt"
        "net"
        "net/http"
        "strconv"

        "k8s.io/client-go/kubernetes/typed/core/v1"
        _ "k8s.io/client-go/plugin/pkg/client/auth/gcp" // registers gcp auth provider
        "k8s.io/client-go/rest"
        "k8s.io/client-go/tools/portforward"
        "k8s.io/client-go/transport/spdy"

        "github.com/windmilleng/tilt/internal/logger"

        "github.com/pkg/errors"
)

func (k K8sClient) ForwardPort(ctx context.Context, namespace Namespace, podID PodID, optionalLocalPort, remotePort int) (localPort int, closer func(), err error) <span class="cov0" title="0">{
        localPort = optionalLocalPort
        if localPort == 0 </span><span class="cov0" title="0">{
                // preferably, we'd set the localport to 0, and let the underlying function pick a port for us,
                // to avoid the race condition potential of something else grabbing this port between
                // the call to `getAvailablePort` and whenever `portForwarder` actually binds the port.
                // the k8s client supports a local port of 0, and stores the actual local port assigned in a field,
                // but unfortunately does not export that field, so there is no way for the caller to know which
                // local port to talk to.
                localPort, err = getAvailablePort()
                if err != nil </span><span class="cov0" title="0">{
                        return 0, nil, errors.Wrap(err, "failed to find an available local port")
                }</span>
        }

        <span class="cov0" title="0">closer, err = k.portForwarder(ctx, k.restConfig, k.core, namespace.String(), podID, localPort, remotePort)
        if err != nil </span><span class="cov0" title="0">{
                return 0, nil, err
        }</span>

        <span class="cov0" title="0">return localPort, closer, nil</span>
}

func portForwarder(ctx context.Context, restConfig *rest.Config, core v1.CoreV1Interface, namespace string, podID PodID, localPort int, remotePort int) (closer func(), err error) <span class="cov0" title="0">{
        transport, upgrader, err := spdy.RoundTripperFor(restConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "error getting roundtripper")
        }</span>

        <span class="cov0" title="0">req := core.RESTClient().Post().
                Resource("pods").
                Namespace(namespace).
                Name(podID.String()).
                SubResource("portforward")

        dialer := spdy.NewDialer(upgrader, &amp;http.Client{Transport: transport}, "POST", req.URL())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "error creating dialer")
        }</span>

        <span class="cov0" title="0">stopChan := make(chan struct{}, 1)
        readyChan := make(chan struct{}, 1)

        ports := []string{fmt.Sprintf("%d:%d", localPort, remotePort)}
        pf, err := portforward.New(
                dialer,
                ports,
                stopChan,
                readyChan,
                logger.Get(ctx).Writer(logger.DebugLvl),
                logger.Get(ctx).Writer(logger.DebugLvl))

        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "error forwarding port")
        }</span>

        <span class="cov0" title="0">errChan := make(chan error)
        go func() </span><span class="cov0" title="0">{
                errChan &lt;- pf.ForwardPorts()
                err := &lt;-errChan
                pf.Close()
                // logging isn't really sufficient, since we're in a goroutine and who knows where the caller
                // has moved on to by this point, but other options are much more expensive (e.g., monitoring the state
                // of the port forward from the caller and/or automatically reconnecting port forwards)
                logger.Get(ctx).Infof("error from port forward: %v", err)
        }</span>()

        <span class="cov0" title="0">select </span>{
        case err = &lt;-errChan:<span class="cov0" title="0">
                pf.Close()
                return nil, errors.Wrap(err, "error forwarding port")</span>
        case &lt;-pf.Ready:<span class="cov0" title="0">
                closer = func() </span><span class="cov0" title="0">{
                        close(stopChan)
                }</span>
                <span class="cov0" title="0">return closer, nil</span>
        }
}

func getAvailablePort() (int, error) <span class="cov0" title="0">{
        l, err := net.Listen("tcp", ":0")
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                e := l.Close()
                if err == nil </span><span class="cov0" title="0">{
                        err = e
                }</span>
        }()

        <span class="cov0" title="0">_, p, err := net.SplitHostPort(l.Addr().String())
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">port, err := strconv.Atoi(p)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return port, err</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package k8s

import (
        "bufio"
        "bytes"
        "io"

        "k8s.io/apimachinery/pkg/runtime/serializer/json"
        "k8s.io/apimachinery/pkg/util/yaml"
        "k8s.io/client-go/kubernetes/scheme"
)

func ParseYAMLFromString(yaml string) ([]K8sEntity, error) <span class="cov8" title="1">{
        buf := bytes.NewBuffer([]byte(yaml))
        return ParseYAML(buf)
}</span>

func ParseYAML(k8sYaml io.Reader) ([]K8sEntity, error) <span class="cov8" title="1">{
        reader := bufio.NewReader(k8sYaml)
        yamlReader := yaml.NewYAMLReader(reader)

        result := make([]K8sEntity, 0)
        for true </span><span class="cov8" title="1">{
                yamlPart, err := yamlReader.Read()
                if err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">if err == io.EOF </span><span class="cov8" title="1">{
                        return result, nil
                }</span>

                <span class="cov8" title="1">deserializer := scheme.Codecs.UniversalDeserializer()
                obj, groupVersionKind, err := deserializer.Decode(yamlPart, nil, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">result = append(result, K8sEntity{
                        Obj:  obj,
                        Kind: groupVersionKind,
                })</span>
        }

        <span class="cov0" title="0">return nil, nil</span>
}

func SerializeYAML(decoded []K8sEntity) (string, error) <span class="cov8" title="1">{
        yamlSerializer := json.NewYAMLSerializer(json.DefaultMetaFactory, scheme.Scheme, scheme.Scheme)
        buf := bytes.NewBuffer(nil)
        for i, obj := range decoded </span><span class="cov8" title="1">{
                if i != 0 </span><span class="cov8" title="1">{
                        buf.Write([]byte("\n---\n"))
                }</span>
                <span class="cov8" title="1">err := yamlSerializer.Encode(obj.Obj, buf)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
        }
        <span class="cov8" title="1">return buf.String(), nil</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package k8s

import (
        "context"

        "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/labels"
)

func (kCli K8sClient) WatchPods(ctx context.Context, lps []LabelPair) (&lt;-chan *v1.Pod, error) <span class="cov8" title="1">{
        ch := make(chan *v1.Pod)

        ls := labels.Set{}
        for _, lp := range lps </span><span class="cov8" title="1">{
                ls[lp.Key] = lp.Value
        }</span>

        // passing "" gets us all namespaces
        <span class="cov8" title="1">watcher, err := kCli.core.Pods("").Watch(metav1.ListOptions{LabelSelector: ls.String()})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                for </span><span class="cov8" title="1">{
                        select </span>{
                        case event, ok := &lt;-watcher.ResultChan():<span class="cov8" title="1">
                                if !ok </span><span class="cov8" title="1">{
                                        close(ch)
                                        return
                                }</span>

                                <span class="cov8" title="1">if event.Object == nil </span><span class="cov0" title="0">{
                                        continue</span>
                                }

                                <span class="cov8" title="1">pod, ok := event.Object.(*v1.Pod)
                                if !ok </span><span class="cov8" title="1">{
                                        continue</span>
                                }

                                <span class="cov8" title="1">ch &lt;- pod</span>
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                watcher.Stop()
                                close(ch)
                                return</span>
                        }
                }
        }()

        <span class="cov8" title="1">return ch, nil</span>
}

func (kCli K8sClient) WatchServices(ctx context.Context, lps []LabelPair) (&lt;-chan *v1.Service, error) <span class="cov8" title="1">{
        ch := make(chan *v1.Service)

        ls := labels.Set{}
        for _, lp := range lps </span><span class="cov8" title="1">{
                ls[lp.Key] = lp.Value
        }</span>

        // passing "" gets us all namespaces
        <span class="cov8" title="1">watcher, err := kCli.core.Services("").Watch(metav1.ListOptions{LabelSelector: ls.String()})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                for </span><span class="cov8" title="1">{
                        select </span>{
                        case event, ok := &lt;-watcher.ResultChan():<span class="cov0" title="0">
                                if !ok </span><span class="cov0" title="0">{
                                        close(ch)
                                        return
                                }</span>

                                <span class="cov0" title="0">if event.Object == nil </span><span class="cov0" title="0">{
                                        continue</span>
                                }

                                <span class="cov0" title="0">service, ok := event.Object.(*v1.Service)
                                if !ok </span><span class="cov0" title="0">{
                                        continue</span>
                                }

                                <span class="cov0" title="0">ch &lt;- service</span>
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                watcher.Stop()
                                close(ch)
                                return</span>
                        }
                }
        }()

        <span class="cov8" title="1">return ch, nil</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package kustomize

import (
        "io/ioutil"
        "path/filepath"

        yaml "gopkg.in/yaml.v2"
)

// kustomization is the content of a kustomization.yaml file.
type kustomization struct {
        Bases              []string             `yaml:"bases"`
        Resources          []string             `yaml:"resources"`
        Patches            []string             `yaml:"patches"`
        CRDs               []string             `yaml:"crds"`
        PatchesJSON6902    []patchJSON6902      `yaml:"patchesJson6902"`
        ConfigMapGenerator []configMapGenerator `yaml:"configMapGenerator"`
}

type patchJSON6902 struct {
        Path string `yaml:"path"`
}

type configMapGenerator struct {
        Files []string `yaml:"files"`
}

func dependenciesForKustomization(dir string) ([]string, error) <span class="cov8" title="1">{
        var deps []string

        path := filepath.Join(dir, "kustomization.yaml")
        buf, err := ioutil.ReadFile(path)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">content := kustomization{}
        if err := yaml.Unmarshal(buf, &amp;content); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">for _, base := range content.Bases </span><span class="cov8" title="1">{
                baseDeps, err := dependenciesForKustomization(filepath.Join(dir, base))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">deps = append(deps, baseDeps...)</span>
        }

        <span class="cov8" title="1">deps = append(deps, path)
        deps = append(deps, joinPaths(dir, content.Resources)...)
        deps = append(deps, joinPaths(dir, content.Patches)...)
        deps = append(deps, joinPaths(dir, content.CRDs)...)
        for _, patch := range content.PatchesJSON6902 </span><span class="cov8" title="1">{
                deps = append(deps, filepath.Join(dir, patch.Path))
        }</span>
        <span class="cov8" title="1">for _, generator := range content.ConfigMapGenerator </span><span class="cov8" title="1">{
                deps = append(deps, joinPaths(dir, generator.Files)...)
        }</span>

        <span class="cov8" title="1">return deps, nil</span>
}

func Deps(baseDir string) ([]string, error) <span class="cov8" title="1">{
        deps, err := dependenciesForKustomization(baseDir)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return uniqDependencies(deps), nil</span>
}

func joinPaths(root string, paths []string) []string <span class="cov8" title="1">{
        var list []string

        for _, path := range paths </span><span class="cov8" title="1">{
                list = append(list, filepath.Join(root, path))
        }</span>

        <span class="cov8" title="1">return list</span>
}

func uniqDependencies(deps []string) []string <span class="cov8" title="1">{
        seen := make(map[string]struct{}, len(deps))
        j := 0
        for _, v := range deps </span><span class="cov8" title="1">{
                if _, ok := seen[v]; ok </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">seen[v] = struct{}{}
                deps[j] = v
                j++</span>
        }

        <span class="cov8" title="1">return deps[:j]</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package logger

import (
        "fmt"
        "io"
)

// A logger that writes all of its messages to `write`
type funcLogger struct {
        supportsColor bool
        level         Level
        write         func(level Level, b []byte) error
}

var _ Logger = funcLogger{}

func NewFuncLogger(supportsColor bool, level Level, write func(level Level, b []byte) error) Logger <span class="cov0" title="0">{
        return funcLogger{supportsColor, level, write}
}</span>

func (l funcLogger) Level() Level <span class="cov0" title="0">{
        return l.level
}</span>

func (l funcLogger) Infof(format string, a ...interface{}) <span class="cov8" title="1">{
        l.Write(InfoLvl, fmt.Sprintf(format, a...))
}</span>

func (l funcLogger) Verbosef(format string, a ...interface{}) <span class="cov0" title="0">{
        l.Write(VerboseLvl, fmt.Sprintf(format, a...))
}</span>

func (l funcLogger) Debugf(format string, a ...interface{}) <span class="cov8" title="1">{
        l.Write(DebugLvl, fmt.Sprintf(format, a...))
}</span>

func (l funcLogger) Write(level Level, s string) <span class="cov8" title="1">{
        _ = l.write(level, []byte(s))
}</span>

type FuncLoggerWriter struct {
        l     funcLogger
        level Level
}

var _ io.Writer = FuncLoggerWriter{}

func (fw FuncLoggerWriter) Write(b []byte) (int, error) <span class="cov0" title="0">{
        return len(b), fw.l.write(fw.level, b)
}</span>

func (l funcLogger) Writer(level Level) io.Writer <span class="cov0" title="0">{
        return FuncLoggerWriter{l, level}
}</span>

func (l funcLogger) SupportsColor() bool <span class="cov0" title="0">{
        return l.supportsColor
}</span>

var _ Logger = funcLogger{}
</pre>
		
		<pre class="file" id="file53" style="display: none">package logger

import (
        "context"
        "fmt"
        "io"
        "os"

        "github.com/fatih/color"

        "github.com/mattn/go-isatty"
)

type Logger interface {
        // log information that we always want to show
        Infof(format string, a ...interface{})
        // log information that a tilt user might not want to see on every run, but that they might find
        // useful when debugging their Tiltfile/docker/k8s configs
        Verbosef(format string, a ...interface{})
        // log information that is likely to only be of interest to tilt developers
        Debugf(format string, a ...interface{})

        Write(level Level, s string)

        // gets an io.Writer that filters to the specified level for, e.g., passing to a subprocess
        Writer(level Level) io.Writer

        Level() Level

        SupportsColor() bool
}

var _ Logger = logger{}

type Level int

const (
        NoneLvl = iota
        InfoLvl
        VerboseLvl
        DebugLvl
)

const loggerContextKey = "Logger"

func Get(ctx context.Context) Logger <span class="cov8" title="1">{
        val := ctx.Value(loggerContextKey)

        if val != nil </span><span class="cov8" title="1">{
                return val.(Logger)
        }</span>

        // No logger found in context, something is wrong.
        <span class="cov0" title="0">panic("Called logger.Get(ctx) on a context with no logger attached!")</span>
}

func NewLogger(level Level, writer io.Writer) Logger <span class="cov8" title="1">{
        // adapted from fatih/color
        supportsColor := true
        if os.Getenv("TERM") == "dumb" </span><span class="cov0" title="0">{
                supportsColor = false
        }</span> else<span class="cov8" title="1"> {
                file, isFile := writer.(*os.File)
                if isFile </span><span class="cov0" title="0">{
                        fd := file.Fd()
                        supportsColor = isatty.IsTerminal(fd) || isatty.IsCygwinTerminal(fd)
                }</span>
        }
        <span class="cov8" title="1">return logger{level, writer, supportsColor}</span>
}

func WithLogger(ctx context.Context, logger Logger) context.Context <span class="cov8" title="1">{
        return context.WithValue(ctx, loggerContextKey, logger)
}</span>

type logger struct {
        level         Level
        writer        io.Writer
        supportsColor bool
}

func (l logger) Level() Level <span class="cov8" title="1">{
        return l.level
}</span>

func (l logger) Infof(format string, a ...interface{}) <span class="cov0" title="0">{
        l.writef(InfoLvl, format, a...)
}</span>

func (l logger) Verbosef(format string, a ...interface{}) <span class="cov0" title="0">{
        l.writef(VerboseLvl, format, a...)
}</span>

func (l logger) Debugf(format string, a ...interface{}) <span class="cov0" title="0">{
        l.writef(DebugLvl, format, a...)
}</span>

func (l logger) writef(level Level, format string, a ...interface{}) <span class="cov0" title="0">{
        if l.level &gt;= level </span><span class="cov0" title="0">{
                // swallowing errors because:
                // 1) if we can't write to the log, what else are we going to do?
                // 2) a logger interface that returns error becomes really distracting at call sites,
                //    increasing friction and reducing logging
                _, _ = fmt.Fprintf(l.writer, format, a...)
                _, _ = fmt.Fprintln(l.writer, "")
        }</span>
}

func (l logger) Write(level Level, s string) <span class="cov8" title="1">{
        if l.level &gt;= level </span><span class="cov8" title="1">{
                // swallowing errors because:
                // 1) if we can't write to the log, what else are we going to do?
                // 2) a logger interface that returns error becomes really distracting at call sites,
                //    increasing friction and reducing logging
                _, _ = fmt.Fprintf(l.writer, s)
                _, _ = fmt.Fprintln(l.writer, "")
        }</span>
}

type levelWriter struct {
        logger logger
        level  Level
}

var _ io.Writer = levelWriter{}

func (lw levelWriter) Write(p []byte) (n int, err error) <span class="cov0" title="0">{
        if lw.logger.level &gt;= lw.level </span><span class="cov0" title="0">{
                return lw.logger.writer.Write(p)
        }</span> else<span class="cov0" title="0"> {
                return len(p), nil
        }</span>
}

func (l logger) Writer(level Level) io.Writer <span class="cov0" title="0">{
        return levelWriter{l, level}
}</span>

func (l logger) SupportsColor() bool <span class="cov8" title="1">{
        return l.supportsColor
}</span>

func getColor(l Logger, c color.Attribute) *color.Color <span class="cov0" title="0">{
        color := color.New(c)
        if !l.SupportsColor() </span><span class="cov0" title="0">{
                color.DisableColor()
        }</span>
        <span class="cov0" title="0">return color</span>
}

func Blue(l Logger) *color.Color   <span class="cov0" title="0">{ return getColor(l, color.FgBlue) }</span>
func Yellow(l Logger) *color.Color <span class="cov0" title="0">{ return getColor(l, color.FgYellow) }</span>
func Green(l Logger) *color.Color  <span class="cov0" title="0">{ return getColor(l, color.FgGreen) }</span>
func Red(l Logger) *color.Color    <span class="cov0" title="0">{ return getColor(l, color.FgRed) }</span>

// Returns a context containing a logger that forks all of its output
// to both the parent context's logger and to the given `io.Writer`
func CtxWithForkedOutput(ctx context.Context, writer io.Writer) context.Context <span class="cov8" title="1">{
        l := Get(ctx)

        write := func(level Level, b []byte) error </span><span class="cov8" title="1">{
                l.Write(level, string(b))
                if l.Level() &gt;= level </span><span class="cov8" title="1">{
                        b = append([]byte{}, b...)
                        b = append(b, '\n')
                        _, err := writer.Write(b)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov8" title="1">forkedLogger := funcLogger{
                supportsColor: l.SupportsColor(),
                level:         l.Level(),
                write:         write,
        }

        return WithLogger(ctx, forkedLogger)</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package logger

import (
        "io"
        "strings"
)

// sticks "prefix" at the start of every new line
type prefixedWriter struct {
        prefix                string
        underlying            io.Writer
        indentBeforeNextWrite bool
}

var _ io.Writer = &amp;prefixedWriter{}

func NewPrefixedWriter(prefix string, underlying io.Writer) *prefixedWriter <span class="cov8" title="1">{
        return &amp;prefixedWriter{prefix, underlying, true}
}</span>

func (i *prefixedWriter) Write(buf []byte) (n int, err error) <span class="cov8" title="1">{
        output := ""

        if i.indentBeforeNextWrite </span><span class="cov8" title="1">{
                output += i.prefix
        }</span>

        <span class="cov8" title="1">output += string(buf)

        // temporarily take off a trailing newline so that Replace doesn't add a prefix at the end
        endsInNewline := false
        if len(output) &gt; 0 </span><span class="cov8" title="1">{
                endsInNewline = output[len(output)-1] == '\n'
        }</span>

        <span class="cov8" title="1">if endsInNewline </span><span class="cov8" title="1">{
                output = output[:len(output)-1]
        }</span>

        <span class="cov8" title="1">output = strings.Replace(output, "\n", "\n"+i.prefix, -1)

        if endsInNewline </span><span class="cov8" title="1">{
                output = output + "\n"
                i.indentBeforeNextWrite = true
        }</span> else<span class="cov8" title="1"> {
                i.indentBeforeNextWrite = false
        }</span>

        <span class="cov8" title="1">_, err = i.underlying.Write([]byte(output))
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">return len(buf), nil</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package minikube

import (
        "bufio"
        "bytes"
        "context"
        "fmt"
        "os/exec"
        "regexp"
)

// This isn't perfect (because it won't unquote the value right) but
// it's good enough for 99% of cases.
var envMatcher = regexp.MustCompile(`export (\w+)="([^"]+)"`)

func DockerEnv(ctx context.Context) (map[string]string, error) <span class="cov0" title="0">{
        cmd := exec.CommandContext(ctx, "minikube", "docker-env", "--shell", "sh")
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                exitErr, isExitErr := err.(*exec.ExitError)
                if isExitErr </span><span class="cov0" title="0">{
                        // TODO(nick): Maybe we should automatically run minikube start?
                        return nil, fmt.Errorf("Could not read docker env from minikube.\n"+
                                "Did you forget to run `minikube start`?\n%s", string(exitErr.Stderr))
                }</span>

                <span class="cov0" title="0">return nil, fmt.Errorf("Could not read docker env from minikube: %v", err)</span>
        }
        <span class="cov0" title="0">return dockerEnvFromOutput(output)</span>
}

func dockerEnvFromOutput(output []byte) (map[string]string, error) <span class="cov8" title="1">{
        result := make(map[string]string, 0)
        scanner := bufio.NewScanner(bytes.NewBuffer(output))
        for scanner.Scan() </span><span class="cov8" title="1">{
                line := scanner.Text()

                match := envMatcher.FindStringSubmatch(line)
                if len(match) &gt; 0 </span><span class="cov8" title="1">{
                        result[match[1]] = match[2]
                }</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package model

import (
        "fmt"
        "path/filepath"
        "strings"

        "github.com/docker/distribution/reference"
)

type ManifestName string

func (m ManifestName) String() string <span class="cov0" title="0">{ return string(m) }</span>

// NOTE: If you modify Manifest, make sure to modify `Manifest.Equal` appropriately
type Manifest struct {
        // Properties for all builds.
        Name         ManifestName
        K8sYaml      string
        TiltFilename string
        DockerRef    reference.Named
        PortForwards []PortForward

        // Local files read while reading the Tilt configuration.
        // If these files are changed, we should reload the manifest.
        ConfigFiles []string

        // Properties for fast_build (builds that support
        // iteration based on past artifacts)
        BaseDockerfile string
        Mounts         []Mount
        Steps          []Step
        Entrypoint     Cmd

        // From static_build. If StaticDockerfile is populated,
        // we do not expect the iterative build fields to be populated.
        StaticDockerfile string
        StaticBuildPath  string // the absolute path to the files

        Repos []LocalGithubRepo
}

func (m Manifest) ConfigMatcher() (PathMatcher, error) <span class="cov0" title="0">{
        configMatcher, err := NewSimpleFileMatcher(m.ConfigFiles...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return configMatcher, nil</span>
}

func (m Manifest) IsStaticBuild() bool <span class="cov8" title="1">{
        return m.StaticDockerfile != ""
}</span>

func (m Manifest) LocalPaths() []string <span class="cov0" title="0">{
        if m.IsStaticBuild() </span><span class="cov0" title="0">{
                return []string{m.StaticBuildPath}
        }</span>

        <span class="cov0" title="0">result := make([]string, len(m.Mounts))
        for i, mount := range m.Mounts </span><span class="cov0" title="0">{
                result[i] = mount.LocalPath
        }</span>
        <span class="cov0" title="0">return result</span>
}

func (m Manifest) Validate() error <span class="cov8" title="1">{
        err := m.validate()
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (m Manifest) validate() *ValidateErr <span class="cov8" title="1">{
        if m.Name == "" </span><span class="cov0" title="0">{
                return validateErrf("[validate] manifest missing name: %+v", m)
        }</span>

        <span class="cov8" title="1">if m.DockerRef == nil </span><span class="cov0" title="0">{
                return validateErrf("[validate] manifest %q missing image ref", m.Name)
        }</span>

        <span class="cov8" title="1">if m.K8sYaml == "" </span><span class="cov0" title="0">{
                return validateErrf("[validate] manifest %q missing YAML file", m.Name)
        }</span>

        <span class="cov8" title="1">for _, m := range m.Mounts </span><span class="cov8" title="1">{
                if !filepath.IsAbs(m.LocalPath) </span><span class="cov8" title="1">{
                        return validateErrf(
                                "[validate] mount.LocalPath must be an absolute path (got: %s)", m.LocalPath)
                }</span>
        }

        <span class="cov8" title="1">if m.IsStaticBuild() </span><span class="cov0" title="0">{
                if m.StaticBuildPath == "" </span><span class="cov0" title="0">{
                        return validateErrf("[validate] manifest %q missing build path", m.Name)
                }</span>
        } else<span class="cov8" title="1"> {
                if m.BaseDockerfile == "" </span><span class="cov0" title="0">{
                        return validateErrf("[validate] manifest %q missing base dockerfile", m.Name)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (m1 Manifest) Equal(m2 Manifest) bool <span class="cov8" title="1">{
        primitivesMatch := m1.Name == m2.Name &amp;&amp; m1.K8sYaml == m2.K8sYaml &amp;&amp; m1.DockerRef == m2.DockerRef &amp;&amp; m1.BaseDockerfile == m2.BaseDockerfile &amp;&amp; m1.StaticDockerfile == m2.StaticDockerfile &amp;&amp; m1.StaticBuildPath == m2.StaticBuildPath &amp;&amp; m1.TiltFilename == m2.TiltFilename
        entrypointMatch := m1.Entrypoint.Equal(m2.Entrypoint)
        configFilesMatch := m1.configFilesEqual(m2.ConfigFiles)
        mountsMatch := m1.mountsEqual(m2.Mounts)
        reposMatch := m1.reposEqual(m2.Repos)
        stepsMatch := m1.stepsEqual(m2.Steps)
        portForwardsMatch := m1.portForwardsEqual(m2)

        return primitivesMatch &amp;&amp; entrypointMatch &amp;&amp; configFilesMatch &amp;&amp; mountsMatch &amp;&amp; reposMatch &amp;&amp; portForwardsMatch &amp;&amp; stepsMatch
}</span>

func (m1 Manifest) configFilesEqual(c2 []string) bool <span class="cov8" title="1">{
        if (m1.ConfigFiles == nil) != (c2 == nil) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">if len(m1.ConfigFiles) != len(c2) </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">for i := range c2 </span><span class="cov8" title="1">{
                if m1.ConfigFiles[i] != c2[i] </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}

func (m1 Manifest) mountsEqual(m2 []Mount) bool <span class="cov8" title="1">{
        if (m1.Mounts == nil) != (m2 == nil) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">if len(m1.Mounts) != len(m2) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">for i := range m2 </span><span class="cov0" title="0">{
                if m1.Mounts[i] != m2[i] </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}

func (m1 Manifest) reposEqual(m2 []LocalGithubRepo) bool <span class="cov8" title="1">{
        if (m1.Repos == nil) != (m2 == nil) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">if len(m1.Repos) != len(m2) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">for i := range m2 </span><span class="cov8" title="1">{
                if m1.Repos[i] != m2[i] </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}

func (m1 Manifest) portForwardsEqual(m2 Manifest) bool <span class="cov8" title="1">{
        if len(m1.PortForwards) != len(m2.PortForwards) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">for i := range m2.PortForwards </span><span class="cov8" title="1">{
                if m1.PortForwards[i] != m2.PortForwards[i] </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}

func (m1 Manifest) stepsEqual(s2 []Step) bool <span class="cov8" title="1">{
        if len(m1.Steps) != len(s2) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">for i := range s2 </span><span class="cov8" title="1">{
                if !m1.Steps[i].Equal(s2[i]) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}

type Mount struct {
        LocalPath     string
        ContainerPath string
}

type LocalGithubRepo struct {
        LocalPath            string
        DockerignoreContents string
        GitignoreContents    string
}

func (LocalGithubRepo) IsRepo() {<span class="cov0" title="0">}</span>

func (r1 LocalGithubRepo) Equal(r2 LocalGithubRepo) bool <span class="cov0" title="0">{
        return r1.DockerignoreContents == r2.DockerignoreContents &amp;&amp; r1.GitignoreContents == r2.GitignoreContents &amp;&amp; r1.LocalPath == r2.LocalPath
}</span>

type Step struct {
        // Required. The command to run in this step.
        Cmd Cmd
        // Optional. If not specified, this step runs on every change.
        // If specified, we only run the Cmd if the trigger matches the changed file.
        Triggers []string
        // Directory the Triggers are relative to
        BaseDirectory string
}

func (s1 Step) Equal(s2 Step) bool <span class="cov8" title="1">{
        if s1.BaseDirectory != s2.BaseDirectory </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">if !s1.Cmd.Equal(s2.Cmd) </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">if len(s1.Triggers) != len(s2.Triggers) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">for i := range s2.Triggers </span><span class="cov8" title="1">{
                if s1.Triggers[i] != s2.Triggers[i] </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}

type Cmd struct {
        Argv []string
}

func (c Cmd) IsShellStandardForm() bool <span class="cov8" title="1">{
        return len(c.Argv) == 3 &amp;&amp; c.Argv[0] == "sh" &amp;&amp; c.Argv[1] == "-c" &amp;&amp; !strings.Contains(c.Argv[2], "\n")
}</span>

// Get the script when the shell is in standard form.
// Panics if the command is not in shell standard form.
func (c Cmd) ShellStandardScript() string <span class="cov8" title="1">{
        if !c.IsShellStandardForm() </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("Not in shell standard form: %+v", c))</span>
        }
        <span class="cov8" title="1">return c.Argv[2]</span>
}

func (c Cmd) EntrypointStr() string <span class="cov8" title="1">{
        if c.IsShellStandardForm() </span><span class="cov0" title="0">{
                return fmt.Sprintf("ENTRYPOINT %s", c.Argv[2])
        }</span>

        <span class="cov8" title="1">quoted := make([]string, len(c.Argv))
        for i, arg := range c.Argv </span><span class="cov8" title="1">{
                quoted[i] = fmt.Sprintf("%q", arg)
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("ENTRYPOINT [%s]", strings.Join(quoted, ", "))</span>
}

func (c Cmd) RunStr() string <span class="cov8" title="1">{
        if c.IsShellStandardForm() </span><span class="cov8" title="1">{
                return fmt.Sprintf("RUN %s", c.Argv[2])
        }</span>

        <span class="cov8" title="1">quoted := make([]string, len(c.Argv))
        for i, arg := range c.Argv </span><span class="cov8" title="1">{
                quoted[i] = fmt.Sprintf("%q", arg)
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("RUN [%s]", strings.Join(quoted, ", "))</span>
}
func (c Cmd) String() string <span class="cov0" title="0">{
        if c.IsShellStandardForm() </span><span class="cov0" title="0">{
                return c.Argv[2]
        }</span>

        <span class="cov0" title="0">quoted := make([]string, len(c.Argv))
        for i, arg := range c.Argv </span><span class="cov0" title="0">{
                if strings.Contains(arg, " ") </span><span class="cov0" title="0">{
                        quoted[i] = fmt.Sprintf("%q", arg)
                }</span> else<span class="cov0" title="0"> {
                        quoted[i] = arg
                }</span>
        }
        <span class="cov0" title="0">return fmt.Sprintf("%s", strings.Join(quoted, " "))</span>
}

func (c1 Cmd) Equal(c2 Cmd) bool <span class="cov8" title="1">{
        if (c1.Argv == nil) != (c2.Argv == nil) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">if len(c1.Argv) != len(c2.Argv) </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">for i := range c1.Argv </span><span class="cov8" title="1">{
                if c1.Argv[i] != c2.Argv[i] </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}

func (c Cmd) Empty() bool <span class="cov0" title="0">{
        return len(c.Argv) == 0
}</span>

func ToShellCmd(cmd string) Cmd <span class="cov8" title="1">{
        if cmd == "" </span><span class="cov0" title="0">{
                return Cmd{}
        }</span>
        <span class="cov8" title="1">return Cmd{Argv: []string{"sh", "-c", cmd}}</span>
}

func ToShellCmds(cmds []string) []Cmd <span class="cov8" title="1">{
        res := make([]Cmd, len(cmds))
        for i, cmd := range cmds </span><span class="cov8" title="1">{
                res[i] = ToShellCmd(cmd)
        }</span>
        <span class="cov8" title="1">return res</span>
}

func ToStep(cwd string, cmd Cmd) Step <span class="cov0" title="0">{
        return Step{BaseDirectory: cwd, Cmd: cmd}
}</span>

func ToSteps(cwd string, cmds []Cmd) []Step <span class="cov0" title="0">{
        res := make([]Step, len(cmds))
        for i, cmd := range cmds </span><span class="cov0" title="0">{
                res[i] = ToStep(cwd, cmd)
        }</span>
        <span class="cov0" title="0">return res</span>
}

func ToShellSteps(cwd string, cmds []string) []Step <span class="cov0" title="0">{
        return ToSteps(cwd, ToShellCmds(cmds))
}</span>

type ValidateErr struct {
        s string
}

func (e *ValidateErr) Error() string <span class="cov8" title="1">{ return e.s }</span>

var _ error = &amp;ValidateErr{}

func validateErrf(format string, a ...interface{}) *ValidateErr <span class="cov8" title="1">{
        return &amp;ValidateErr{s: fmt.Sprintf(format, a...)}
}</span>

type PortForward struct {
        // The port to expose on localhost of the current machine.
        LocalPort int

        // The port to connect to inside the deployed container.
        // If 0, we will connect to the first containerPort.
        ContainerPort int
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package model

import (
        "fmt"
        "path/filepath"
)

type PathMatcher interface {
        Matches(f string, isDir bool) (bool, error)
}

// A Matcher that matches nothing.
type emptyMatcher struct{}

func (m emptyMatcher) Matches(f string, isDir bool) (bool, error) <span class="cov0" title="0">{
        return false, nil
}</span>

var EmptyMatcher PathMatcher = emptyMatcher{}

// A matcher that matches against a set of files.
type fileMatcher struct {
        paths map[string]bool
}

func (m fileMatcher) Matches(f string, isDir bool) (bool, error) <span class="cov0" title="0">{
        return m.paths[f], nil
}</span>

func NewSimpleFileMatcher(paths ...string) (fileMatcher, error) <span class="cov0" title="0">{
        pathMap := make(map[string]bool, len(paths))
        for _, path := range paths </span><span class="cov0" title="0">{
                // Get the absolute path of the path, because PathMatchers expect to always
                // work with absolute paths.
                path, err := filepath.Abs(path)
                if err != nil </span><span class="cov0" title="0">{
                        return fileMatcher{}, fmt.Errorf("NewSimplePathMatcher: %v", err)
                }</span>
                <span class="cov0" title="0">pathMap[path] = true</span>
        }
        <span class="cov0" title="0">return fileMatcher{paths: pathMap}, nil</span>
}

type PatternMatcher interface {
        PathMatcher

        // Express this PathMatcher as a sequence of filepath.Match
        // patterns. These patterns are widely useful in Docker-land because
        // they're suitable in .dockerignore or Dockerfile ADD statements
        // https://docs.docker.com/engine/reference/builder/#add
        AsMatchPatterns() []string
}

type CompositePathMatcher struct {
        Matchers []PathMatcher
}

func NewCompositeMatcher(matchers []PathMatcher) PathMatcher <span class="cov0" title="0">{
        if len(matchers) == 0 </span><span class="cov0" title="0">{
                return EmptyMatcher
        }</span>
        <span class="cov0" title="0">cMatcher := CompositePathMatcher{Matchers: matchers}
        pMatchers := make([]PatternMatcher, len(matchers))
        for i, m := range matchers </span><span class="cov0" title="0">{
                pm, ok := m.(CompositePatternMatcher)
                if !ok </span><span class="cov0" title="0">{
                        return cMatcher
                }</span>
                <span class="cov0" title="0">pMatchers[i] = pm</span>
        }
        <span class="cov0" title="0">return CompositePatternMatcher{
                CompositePathMatcher: cMatcher,
                Matchers:             pMatchers,
        }</span>
}

func (c CompositePathMatcher) Matches(f string, isDir bool) (bool, error) <span class="cov0" title="0">{
        for _, t := range c.Matchers </span><span class="cov0" title="0">{
                ret, err := t.Matches(f, isDir)
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
                <span class="cov0" title="0">if ret </span><span class="cov0" title="0">{
                        return true, nil
                }</span>
        }
        <span class="cov0" title="0">return false, nil</span>
}

type CompositePatternMatcher struct {
        CompositePathMatcher
        Matchers []PatternMatcher
}

func (c CompositePatternMatcher) AsMatchPatterns() []string <span class="cov0" title="0">{
        result := []string{}
        for _, m := range c.Matchers </span><span class="cov0" title="0">{
                result = append(result, m.AsMatchPatterns()...)
        }</span>
        <span class="cov0" title="0">return result</span>
}

var _ PathMatcher = CompositePathMatcher{}
var _ PatternMatcher = CompositePatternMatcher{}
</pre>
		
		<pre class="file" id="file58" style="display: none">package model

import (
        "strings"
)

func TrySquash(steps []Cmd) []Cmd <span class="cov8" title="1">{
        newSteps := make([]Cmd, 0)
        for i := 0; i &lt; len(steps); i++ </span><span class="cov8" title="1">{
                toSquash := []Cmd{}
                for j := i; j &lt; len(steps); j++ </span><span class="cov8" title="1">{
                        stepJ := steps[j]
                        if !stepJ.IsShellStandardForm() </span><span class="cov8" title="1">{
                                break</span>
                        }

                        <span class="cov8" title="1">toSquash = append(toSquash, stepJ)</span>
                }

                <span class="cov8" title="1">if len(toSquash) &lt; 2 </span><span class="cov8" title="1">{
                        newSteps = append(newSteps, steps[i])
                        continue</span>
                }

                <span class="cov8" title="1">newSteps = append(newSteps, squashHelper(toSquash))
                i += len(toSquash) - 1</span>
        }
        <span class="cov8" title="1">return newSteps</span>
}

// Create a new shell script that combines the individual steps.
// We know all the scripts are in shell standard form.
func squashHelper(steps []Cmd) Cmd <span class="cov8" title="1">{
        scripts := make([]string, len(steps))
        for i, c := range steps </span><span class="cov8" title="1">{
                scripts[i] = c.ShellStandardScript()
        }</span>

        <span class="cov8" title="1">return Cmd{
                // This could potentially break things (because it converts normal shell
                // scripts to scripts run with -ex). We're not too worried about it right
                // now.  In the future, we might need to do manual exit code checks for
                // correctness.
                Argv: []string{
                        "sh",
                        "-exc",
                        strings.Join(scripts, ";\n"),
                },
        }</span>
}
</pre>
		
		<pre class="file" id="file59" style="display: none">package ospath

import (
        "os"
        "path/filepath"
)

// Given absolute paths `dir` and `file`, returns
// the relative path of `file` relative to `dir`.
//
// Returns true if successful. If `file` is not under `dir`, returns false.
func Child(dir string, file string) (string, bool) <span class="cov8" title="1">{
        current := file
        child := ""
        for true </span><span class="cov8" title="1">{
                if dir == current </span><span class="cov8" title="1">{
                        return child, true
                }</span>

                <span class="cov8" title="1">if len(current) &lt;= len(dir) || current == "." </span><span class="cov8" title="1">{
                        return "", false
                }</span>

                <span class="cov8" title="1">cDir := filepath.Dir(current)
                cBase := filepath.Base(current)
                child = filepath.Join(cBase, child)
                current = cDir</span>
        }

        <span class="cov0" title="0">return "", false</span>
}

func RealChild(dir string, file string) (string, bool, error) <span class="cov0" title="0">{
        realDir, err := RealAbs(dir)
        if err != nil </span><span class="cov0" title="0">{
                return "", false, err
        }</span>
        <span class="cov0" title="0">realFile, err := RealAbs(file)
        if err != nil </span><span class="cov0" title="0">{
                return "", false, err
        }</span>

        <span class="cov0" title="0">rel, isChild := Child(realDir, realFile)
        return rel, isChild, nil</span>
}

// Returns the absolute version of this path, resolving all symlinks.
func RealAbs(path string) (string, error) <span class="cov0" title="0">{
        // Make the path absolute first, so that we find any symlink parents.
        absPath, err := filepath.Abs(path)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Resolve the symlinks.
        <span class="cov0" title="0">realPath, err := filepath.EvalSymlinks(absPath)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Double-check we're still absolute.
        <span class="cov0" title="0">return filepath.Abs(realPath)</span>
}

// Like os.Getwd, but with all symlinks resolved.
func Realwd() (string, error) <span class="cov0" title="0">{
        path, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return RealAbs(path)</span>
}

func IsDir(path string) bool <span class="cov0" title="0">{
        f, err := os.Stat(path)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return f.Mode().IsDir()</span>
}

func IsBrokenSymlink(path string) (bool, error) <span class="cov8" title="1">{
        // Stat resolves symlinks, lstat does not.
        // So if Stat reports IsNotExist, but Lstat does not,
        // then we have a broken symlink.
        _, err := os.Stat(path)
        if err == nil </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">if !os.IsNotExist(err) </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">_, err = os.Lstat(path)
        if err != nil </span><span class="cov8" title="1">{
                if os.IsNotExist(err) </span><span class="cov8" title="1">{
                        return false, nil
                }</span>
                <span class="cov0" title="0">return false, err</span>
        }
        <span class="cov8" title="1">return true, nil</span>
}

// TryAsCwdChildren converts the given absolute paths to children of the CWD,
// if possible (otherwise, leaves them as absolute paths).
func TryAsCwdChildren(absPaths []string) []string <span class="cov0" title="0">{
        wd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                // This is just a util for printing right now, so don't actually throw an
                // error, just return back all the absolute paths
                return absPaths[:]
        }</span>

        <span class="cov0" title="0">res := make([]string, len(absPaths))
        for i, abs := range absPaths </span><span class="cov0" title="0">{
                rel, isChild := Child(wd, abs)
                if isChild </span><span class="cov0" title="0">{
                        res[i] = rel
                }</span> else<span class="cov0" title="0"> {
                        res[i] = abs
                }</span>
        }
        <span class="cov0" title="0">return res</span>
}
</pre>
		
		<pre class="file" id="file60" style="display: none">package rty

import (
        "bytes"
        "fmt"
        "io"
        "regexp"
        "strconv"
        "strings"

        "github.com/mattn/go-runewidth"
)

// this is all copied from tview.

var (
        colorPattern  = regexp.MustCompile(`\[([a-zA-Z]+|#[0-9a-zA-Z]{6}|\-)?(:([a-zA-Z]+|#[0-9a-zA-Z]{6}|\-)?(:([lbdru]+|\-)?)?)?\]`)
        escapePattern = regexp.MustCompile(`\[([a-zA-Z0-9_,;: \-\."#]+)\[(\[*)\]`)
)

// decomposeString returns information about a string which may contain color
// tags. It returns the indices of the color tags (as returned by
// re.FindAllStringIndex()), the color tags themselves (as returned by
// re.FindAllStringSubmatch()), the indices of an escaped tags, the string
// stripped by any color tags and escaped, and the screen width of the stripped
// string.
func decomposeString(text string) (colorIndices [][]int, colors [][]string, escapeIndices [][]int, stripped string, width int) <span class="cov8" title="1">{
        // Get positions of color and escape tags.
        colorIndices = colorPattern.FindAllStringIndex(text, -1)
        colors = colorPattern.FindAllStringSubmatch(text, -1)
        escapeIndices = escapePattern.FindAllStringIndex(text, -1)

        // Because the color pattern detects empty tags, we need to filter them out.
        for i := len(colorIndices) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                if colorIndices[i][1]-colorIndices[i][0] == 2 </span><span class="cov0" title="0">{
                        colorIndices = append(colorIndices[:i], colorIndices[i+1:]...)
                        colors = append(colors[:i], colors[i+1:]...)
                }</span>
        }

        // Remove the color tags from the original string.
        <span class="cov8" title="1">var from int
        buf := make([]byte, 0, len(text))
        for _, indices := range colorIndices </span><span class="cov8" title="1">{
                buf = append(buf, []byte(text[from:indices[0]])...)
                from = indices[1]
        }</span>
        <span class="cov8" title="1">buf = append(buf, text[from:]...)

        // Escape string.
        stripped = string(escapePattern.ReplaceAll(buf, []byte("[$1$2]")))

        // Get the width of the stripped string.
        width = runewidth.StringWidth(stripped)

        return</span>
}

// Positions of substrings in regular expressions.
const (
        colorForegroundPos = 1
        colorBackgroundPos = 3
        colorFlagPos       = 5
)

// styleFromTag takes the given style, defined by a foreground color (fgColor),
// a background color (bgColor), and style attributes, and modifies it based on
// the substrings (tagSubstrings) extracted by the regular expression for color
// tags. The new colors and attributes are returned where empty strings mean
// "don't modify" and a dash ("-") means "reset to default".
func styleFromTag(fgColor, bgColor, attributes string, tagSubstrings []string) (newFgColor, newBgColor, newAttributes string) <span class="cov8" title="1">{
        if tagSubstrings[colorForegroundPos] != "" </span><span class="cov8" title="1">{
                color := tagSubstrings[colorForegroundPos]
                if color == "-" </span><span class="cov8" title="1">{
                        fgColor = "-"
                }</span> else<span class="cov8" title="1"> if color != "" </span><span class="cov8" title="1">{
                        fgColor = color
                }</span>
        }

        <span class="cov8" title="1">if tagSubstrings[colorBackgroundPos-1] != "" </span><span class="cov8" title="1">{
                color := tagSubstrings[colorBackgroundPos]
                if color == "-" </span><span class="cov8" title="1">{
                        bgColor = "-"
                }</span> else<span class="cov8" title="1"> if color != "" </span><span class="cov8" title="1">{
                        bgColor = color
                }</span>
        }

        <span class="cov8" title="1">if tagSubstrings[colorFlagPos-1] != "" </span><span class="cov8" title="1">{
                flags := tagSubstrings[colorFlagPos]
                if flags == "-" </span><span class="cov8" title="1">{
                        attributes = "-"
                }</span> else<span class="cov0" title="0"> if flags != "" </span><span class="cov0" title="0">{
                        attributes = flags
                }</span>
        }

        <span class="cov8" title="1">return fgColor, bgColor, attributes</span>
}

// The states of the ANSI escape code parser.
const (
        ansiText = iota
        ansiEscape
        ansiSubstring
        ansiControlSequence
)

// ansi is a io.Writer which translates ANSI escape codes into tview color
// tags.
type ansi struct {
        io.Writer

        // Reusable buffers.
        buffer                        *bytes.Buffer // The entire output text of one Write().
        csiParameter, csiIntermediate *bytes.Buffer // Partial CSI strings.

        // The current state of the parser. One of the ansi constants.
        state int
}

// ANSIWriter returns an io.Writer which translates any ANSI escape codes
// written to it into tview color tags. Other escape codes don't have an effect
// and are simply removed. The translated text is written to the provided
// writer.
func ANSIWriter(writer io.Writer) io.Writer <span class="cov8" title="1">{
        return &amp;ansi{
                Writer:          writer,
                buffer:          new(bytes.Buffer),
                csiParameter:    new(bytes.Buffer),
                csiIntermediate: new(bytes.Buffer),
                state:           ansiText,
        }
}</span>

// Write parses the given text as a string of runes, translates ANSI escape
// codes to color tags and writes them to the output writer.
func (a *ansi) Write(text []byte) (int, error) <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{
                a.buffer.Reset()
        }</span>()

        <span class="cov8" title="1">for _, r := range string(text) </span><span class="cov8" title="1">{
                switch a.state </span>{

                // We just entered an escape sequence.
                case ansiEscape:<span class="cov8" title="1">
                        switch r </span>{
                        case '[':<span class="cov8" title="1"> // Control Sequence Introducer.
                                a.csiParameter.Reset()
                                a.csiIntermediate.Reset()
                                a.state = ansiControlSequence</span>
                        case 'c':<span class="cov8" title="1"> // Reset.
                                _, err := fmt.Fprint(a.buffer, "[-:-:-]")
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov8" title="1">a.state = ansiText</span>
                        case 'P', ']', 'X', '^', '_':<span class="cov0" title="0"> // Substrings and commands.
                                a.state = ansiSubstring</span>
                        default:<span class="cov0" title="0"> // Ignore.
                                a.state = ansiText</span>
                        }

                        // CSI Sequences.
                case ansiControlSequence:<span class="cov8" title="1">
                        switch </span>{
                        case r &gt;= 0x30 &amp;&amp; r &lt;= 0x3f:<span class="cov8" title="1"> // Parameter bytes.
                                if _, err := a.csiParameter.WriteRune(r); err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                        case r &gt;= 0x20 &amp;&amp; r &lt;= 0x2f:<span class="cov0" title="0"> // Intermediate bytes.
                                if _, err := a.csiIntermediate.WriteRune(r); err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                        case r &gt;= 0x40 &amp;&amp; r &lt;= 0x7e:<span class="cov8" title="1"> // Final byte.
                                switch r </span>{
                                case 'E':<span class="cov0" title="0"> // Next line.
                                        count, _ := strconv.Atoi(a.csiParameter.String())
                                        if count == 0 </span><span class="cov0" title="0">{
                                                count = 1
                                        }</span>
                                        <span class="cov0" title="0">_, err := fmt.Fprint(a.buffer, strings.Repeat("\n", count))
                                        if err != nil </span><span class="cov0" title="0">{
                                                return 0, err
                                        }</span>
                                case 'm':<span class="cov8" title="1"> // Select Graphic Rendition.
                                        var (
                                                background, foreground, attributes string
                                                clearAttributes                    bool
                                        )
                                        fields := strings.Split(a.csiParameter.String(), ";")
                                        if len(fields) == 0 || len(fields) == 1 &amp;&amp; fields[0] == "0" </span><span class="cov0" title="0">{
                                                // Reset.
                                                if _, err := a.buffer.WriteString("[-:-:-]"); err != nil </span><span class="cov0" title="0">{
                                                        return 0, err
                                                }</span>
                                                <span class="cov0" title="0">break</span>
                                        }
                                        <span class="cov8" title="1">lookupColor := func(colorNumber int, bright bool) string </span><span class="cov8" title="1">{
                                                if colorNumber &lt; 0 || colorNumber &gt; 7 </span><span class="cov0" title="0">{
                                                        return "black"
                                                }</span>
                                                <span class="cov8" title="1">if bright </span><span class="cov0" title="0">{
                                                        colorNumber += 8
                                                }</span>
                                                <span class="cov8" title="1">return [...]string{
                                                        "black",
                                                        "red",
                                                        "green",
                                                        "yellow",
                                                        "blue",
                                                        "darkmagenta",
                                                        "darkcyan",
                                                        "white",
                                                        "#7f7f7f",
                                                        "#ff0000",
                                                        "#00ff00",
                                                        "#ffff00",
                                                        "#5c5cff",
                                                        "#ff00ff",
                                                        "#00ffff",
                                                        "#ffffff",
                                                }[colorNumber]</span>
                                        }
                                        <span class="cov8" title="1">for index, field := range fields </span><span class="cov8" title="1">{
                                                switch field </span>{
                                                case "1", "01":<span class="cov0" title="0">
                                                        attributes += "b"</span>
                                                case "2", "02":<span class="cov0" title="0">
                                                        attributes += "d"</span>
                                                case "4", "04":<span class="cov0" title="0">
                                                        attributes += "u"</span>
                                                case "5", "05":<span class="cov0" title="0">
                                                        attributes += "l"</span>
                                                case "7", "07":<span class="cov0" title="0">
                                                        attributes += "7"</span>
                                                case "22", "24", "25", "27":<span class="cov0" title="0">
                                                        clearAttributes = true</span>
                                                case "30", "31", "32", "33", "34", "35", "36", "37":<span class="cov8" title="1">
                                                        colorNumber, _ := strconv.Atoi(field)
                                                        foreground = lookupColor(colorNumber-30, false)</span>
                                                case "40", "41", "42", "43", "44", "45", "46", "47":<span class="cov8" title="1">
                                                        colorNumber, _ := strconv.Atoi(field)
                                                        background = lookupColor(colorNumber-40, false)</span>
                                                case "90", "91", "92", "93", "94", "95", "96", "97":<span class="cov0" title="0">
                                                        colorNumber, _ := strconv.Atoi(field)
                                                        foreground = lookupColor(colorNumber-90, true)</span>
                                                case "100", "101", "102", "103", "104", "105", "106", "107":<span class="cov0" title="0">
                                                        colorNumber, _ := strconv.Atoi(field)
                                                        background = lookupColor(colorNumber-100, true)</span>
                                                case "38", "48":<span class="cov0" title="0">
                                                        var color string
                                                        if len(fields) &gt; index+1 </span><span class="cov0" title="0">{
                                                                if fields[index+1] == "5" &amp;&amp; len(fields) &gt; index+2 </span><span class="cov0" title="0">{ // 8-bit colors.
                                                                        colorNumber, _ := strconv.Atoi(fields[index+2])
                                                                        if colorNumber &lt;= 7 </span><span class="cov0" title="0">{
                                                                                color = lookupColor(colorNumber, false)
                                                                        }</span> else<span class="cov0" title="0"> if colorNumber &lt;= 15 </span><span class="cov0" title="0">{
                                                                                color = lookupColor(colorNumber, true)
                                                                        }</span> else<span class="cov0" title="0"> if colorNumber &lt;= 231 </span><span class="cov0" title="0">{
                                                                                red := (colorNumber - 16) / 36
                                                                                green := ((colorNumber - 16) / 6) % 6
                                                                                blue := (colorNumber - 16) % 6
                                                                                color = fmt.Sprintf("#%02x%02x%02x", 255*red/5, 255*green/5, 255*blue/5)
                                                                        }</span> else<span class="cov0" title="0"> if colorNumber &lt;= 255 </span><span class="cov0" title="0">{
                                                                                grey := 255 * (colorNumber - 232) / 23
                                                                                color = fmt.Sprintf("#%02x%02x%02x", grey, grey, grey)
                                                                        }</span>
                                                                } else<span class="cov0" title="0"> if fields[index+1] == "2" &amp;&amp; len(fields) &gt; index+4 </span><span class="cov0" title="0">{ // 24-bit colors.
                                                                        red, _ := strconv.Atoi(fields[index+2])
                                                                        green, _ := strconv.Atoi(fields[index+3])
                                                                        blue, _ := strconv.Atoi(fields[index+4])
                                                                        color = fmt.Sprintf("#%02x%02x%02x", red, green, blue)
                                                                }</span>
                                                        }
                                                        <span class="cov0" title="0">if len(color) &gt; 0 </span><span class="cov0" title="0">{
                                                                if field == "38" </span><span class="cov0" title="0">{
                                                                        foreground = color
                                                                }</span> else<span class="cov0" title="0"> {
                                                                        background = color
                                                                }</span>
                                                        }
                                                }
                                        }
                                        <span class="cov8" title="1">if len(attributes) &gt; 0 || clearAttributes </span><span class="cov0" title="0">{
                                                attributes = ":" + attributes
                                        }</span>
                                        <span class="cov8" title="1">if len(foreground) &gt; 0 || len(background) &gt; 0 || len(attributes) &gt; 0 </span><span class="cov8" title="1">{
                                                _, err := fmt.Fprintf(a.buffer, "[%s:%s%s]", foreground, background, attributes)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        return 0, err
                                                }</span>
                                        }
                                }
                                <span class="cov8" title="1">a.state = ansiText</span>
                        default:<span class="cov0" title="0"> // Undefined byte.
                                a.state = ansiText</span> // Abort CSI.
                        }

                        // We just entered a substring/command sequence.
                case ansiSubstring:<span class="cov0" title="0">
                        if r == 27 </span><span class="cov0" title="0">{ // Most likely the end of the substring.
                                a.state = ansiEscape
                        }</span> // Ignore all other characters.

                        // "ansiText" and all others.
                default:<span class="cov8" title="1">
                        if r == 27 </span><span class="cov8" title="1">{
                                // This is the start of an escape sequence.
                                a.state = ansiEscape
                        }</span> else<span class="cov8" title="1"> {
                                // Just a regular rune. Send to buffer.
                                if _, err := a.buffer.WriteRune(r); err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                        }
                }
        }

        // Write buffer to target writer.
        <span class="cov8" title="1">n, err := a.buffer.WriteTo(a.Writer)
        if err != nil </span><span class="cov0" title="0">{
                return int(n), err
        }</span>
        <span class="cov8" title="1">return len(text), nil</span>
}

// TranslateANSI replaces ANSI escape sequences found in the provided string
// with tview's color tags and returns the resulting string.
func TranslateANSI(text string) string <span class="cov8" title="1">{
        var buffer bytes.Buffer
        writer := ANSIWriter(&amp;buffer)
        _, _ = writer.Write([]byte(text))
        return buffer.String()
}</span>
</pre>
		
		<pre class="file" id="file61" style="display: none">package rty

import (
        "fmt"

        "github.com/windmilleng/tcell"
)

// Canvases hold content.

type Canvas interface {
        Size() (int, int)
        SetContent(x int, y int, mainc rune, combc []rune, style tcell.Style) error
        Close() (int, int)
        GetContent(x, y int) (mainc rune, combc []rune, style tcell.Style, width int)
}

func totalHeight(canvases []Canvas) int <span class="cov0" title="0">{
        total := 0
        for _, c := range canvases </span><span class="cov0" title="0">{
                _, h := c.Size()
                total += h
        }</span>
        <span class="cov0" title="0">return total</span>
}

// Implementations below
type cell struct {
        ch    rune
        style tcell.Style
}

type TempCanvas struct {
        width  int
        height int
        cells  [][]cell
        style  tcell.Style
}

type lineRange struct {
        start int
        end   int
}

func newTempCanvas(width, height int, style tcell.Style) *TempCanvas <span class="cov8" title="1">{
        c := &amp;TempCanvas{width: width, height: height}
        if height != GROW </span><span class="cov8" title="1">{
                c.cells = make([][]cell, height)
                for i := 0; i &lt; height; i++ </span><span class="cov8" title="1">{
                        c.cells[i] = c.makeRow()
                }</span>
        }
        <span class="cov8" title="1">return c</span>
}

func (c *TempCanvas) Size() (int, int) <span class="cov8" title="1">{
        return c.width, c.height
}</span>

func (c *TempCanvas) Close() (int, int) <span class="cov8" title="1">{
        if c.height == GROW </span><span class="cov0" title="0">{
                c.height = len(c.cells)
        }</span>
        <span class="cov8" title="1">return c.width, c.height</span>
}

func (c *TempCanvas) makeRow() []cell <span class="cov8" title="1">{
        row := make([]cell, c.width)
        for i := 0; i &lt; c.width; i++ </span><span class="cov8" title="1">{
                row[i].style = c.style
        }</span>
        <span class="cov8" title="1">return row</span>
}

func (c *TempCanvas) SetContent(x int, y int, mainc rune, combc []rune, style tcell.Style) error <span class="cov8" title="1">{
        if x &lt; 0 || x &gt;= c.width || y &lt; 0 || y &gt;= c.height </span><span class="cov0" title="0">{
                panic(fmt.Errorf("cell %v,%v outside canvas %v,%v", x, y, c.width, c.height))</span>
        }

        <span class="cov8" title="1">for y &gt;= len(c.cells) </span><span class="cov0" title="0">{
                c.cells = append(c.cells, c.makeRow())
        }</span>

        <span class="cov8" title="1">c.cells[y][x] = cell{ch: mainc, style: style}
        return nil</span>
}

func (c *TempCanvas) GetContent(x, y int) (mainc rune, combc []rune, style tcell.Style, width int) <span class="cov8" title="1">{
        if x &lt; 0 || x &gt;= c.width || y &lt; 0 || y &gt;= c.height </span><span class="cov0" title="0">{
                panic(fmt.Errorf("cell %d, %d outside bounds %d, %d", x, y, c.width, c.height))</span>
        }

        <span class="cov8" title="1">if y &gt;= len(c.cells) </span><span class="cov0" title="0">{
                return 0, nil, tcell.StyleDefault, 1
        }</span>

        <span class="cov8" title="1">cell := c.cells[y][x]
        return cell.ch, nil, cell.style, 1</span>
}

type SubCanvas struct {
        del       Canvas
        startX    int
        startY    int
        width     int
        height    int
        highWater int
        style     tcell.Style
}

func newSubCanvas(del Canvas, startX int, startY int, width int, height int, style tcell.Style) *SubCanvas <span class="cov8" title="1">{
        _, delHeight := del.Size()
        if height == GROW &amp;&amp; delHeight != GROW </span><span class="cov0" title="0">{
                panic(fmt.Errorf("can't create a growing subcanvas from a non-growing subcanvas"))</span>
        }
        <span class="cov8" title="1">r := &amp;SubCanvas{
                del:       del,
                startX:    startX,
                startY:    startY,
                width:     width,
                height:    height,
                highWater: -1,
                style:     style,
        }
        r.fill(-1)
        return r</span>
}

func (c *SubCanvas) Size() (int, int) <span class="cov8" title="1">{
        return c.width, c.height
}</span>

func (c *SubCanvas) Close() (int, int) <span class="cov8" title="1">{
        if c.height == GROW </span><span class="cov0" title="0">{
                c.height = c.highWater + 1
        }</span>
        <span class="cov8" title="1">return c.width, c.height</span>
}

func (c *SubCanvas) SetContent(x int, y int, mainc rune, combc []rune, style tcell.Style) error <span class="cov8" title="1">{
        if x &lt; 0 || x &gt;= c.width || y &lt; 0 || y &gt;= c.height </span><span class="cov0" title="0">{
                return fmt.Errorf("coord %d,%d is outside bounds %d,%d", x, y, c.width, c.height)
        }</span>

        <span class="cov8" title="1">if c.height == GROW &amp;&amp; y &gt; c.highWater </span><span class="cov0" title="0">{
                oldHighWater := c.highWater
                c.highWater = y
                c.fill(oldHighWater)
        }</span>
        <span class="cov8" title="1">return c.del.SetContent(c.startX+x, c.startY+y, mainc, combc, style)</span>
}

func (c *SubCanvas) fill(lastFilled int) <span class="cov8" title="1">{
        startY := lastFilled + 1
        maxY := c.height
        if maxY == GROW </span><span class="cov0" title="0">{
                maxY = c.highWater + 1
        }</span>
        <span class="cov8" title="1">for y := startY; y &lt; maxY; y++ </span><span class="cov8" title="1">{
                for x := 0; x &lt; c.width; x++ </span><span class="cov8" title="1">{
                        if err := c.del.SetContent(c.startX+x, c.startY+y, 0, nil, c.style); err != nil </span><span class="cov0" title="0">{
                                panic(err)</span>
                        }
                }
        }
}

func (c *SubCanvas) GetContent(x int, y int) (rune, []rune, tcell.Style, int) <span class="cov0" title="0">{
        return c.del.GetContent(x, y)
}</span>

type ScreenCanvas struct {
        del tcell.Screen
}

func newScreenCanvas(del tcell.Screen) *ScreenCanvas <span class="cov0" title="0">{
        return &amp;ScreenCanvas{del: del}
}</span>

func (c *ScreenCanvas) Size() (int, int) <span class="cov0" title="0">{
        return c.del.Size()
}</span>

func (c *ScreenCanvas) SetContent(x int, y int, mainc rune, combc []rune, style tcell.Style) error <span class="cov0" title="0">{
        c.del.SetContent(x, y, mainc, combc, style)
        return nil
}</span>

func (c *ScreenCanvas) Close() (int, int) <span class="cov0" title="0">{
        return c.del.Size()
}</span>

func (c *ScreenCanvas) GetContent(x, y int) (mainc rune, combc []rune, style tcell.Style, width int) <span class="cov0" title="0">{
        return c.del.GetContent(x, y)
}</span>
</pre>
		
		<pre class="file" id="file62" style="display: none">package rty

import (
        "fmt"

        "github.com/rivo/tview"

        "github.com/windmilleng/tcell"
)

// Layouts implement Component

type Dir int

const (
        DirHor Dir = iota
        DirVert
)

// FlexLayout lays out its sub-components.
type FlexLayout struct {
        dir Dir
        cs  []Component
}

func NewFlexLayout(dir Dir) *FlexLayout <span class="cov8" title="1">{
        return &amp;FlexLayout{
                dir: dir,
        }
}</span>

func (l *FlexLayout) Add(c Component) <span class="cov8" title="1">{
        l.cs = append(l.cs, c)
}</span>

func whToLd(width int, height int, dir Dir) (length int, depth int) <span class="cov8" title="1">{
        if dir == DirVert </span><span class="cov8" title="1">{
                return height, width
        }</span>
        <span class="cov8" title="1">return width, height</span>
}

func ldToWh(length int, depth int, dir Dir) (width int, height int) <span class="cov0" title="0">{
        if dir == DirVert </span><span class="cov0" title="0">{
                return depth, length
        }</span>
        <span class="cov0" title="0">return length, depth</span>
}

func (l *FlexLayout) Size(width int, height int) (int, int) <span class="cov0" title="0">{
        return width, height
}</span>

func (l *FlexLayout) Render(w Writer, width, height int) error <span class="cov8" title="1">{
        length, _ := whToLd(width, height, l.dir)

        allocations := make([]int, len(l.cs))
        allocated := 0
        var flexIdxs []int

        for i, c := range l.cs </span><span class="cov8" title="1">{
                reqWidth, reqHeight := c.Size(width, height)
                reqLen, _ := whToLd(reqWidth, reqHeight, l.dir)
                if reqLen &gt;= length </span><span class="cov8" title="1">{
                        flexIdxs = append(flexIdxs, i)
                }</span> else<span class="cov8" title="1"> {
                        allocations[i] = reqLen
                        allocated += reqLen
                }</span>
        }

        <span class="cov8" title="1">flexTotal := length - allocated
        if flexTotal &lt; 0 </span><span class="cov8" title="1">{
                noun := "lines"
                if l.dir == DirHor </span><span class="cov8" title="1">{
                        noun = "columns"
                }</span>
                <span class="cov8" title="1">return fmt.Errorf("FlexLayout can't render in %v %s; need at least %v", length, noun, allocated)</span>
        }
        <span class="cov8" title="1">numFlex := len(flexIdxs)
        for _, i := range flexIdxs </span><span class="cov8" title="1">{
                elemLength := flexTotal / numFlex
                allocations[i] = elemLength
                numFlex--
                flexTotal -= elemLength
        }</span>

        <span class="cov8" title="1">offset := 0
        for i, c := range l.cs </span><span class="cov8" title="1">{
                elemLength := allocations[i]

                var subW Writer

                if l.dir == DirHor </span><span class="cov8" title="1">{
                        subW = w.Divide(offset, 0, allocations[i], height)
                }</span> else<span class="cov8" title="1"> {
                        subW = w.Divide(0, offset, width, allocations[i])
                }</span>

                <span class="cov8" title="1">offset += elemLength

                subW.RenderChild(c)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

type ConcatLayout struct {
        dir Dir
        cs  []Component
}

func NewConcatLayout(dir Dir) *ConcatLayout <span class="cov8" title="1">{
        return &amp;ConcatLayout{dir: dir}
}</span>

func (l *ConcatLayout) Add(c Component) <span class="cov8" title="1">{
        l.cs = append(l.cs, c)
}</span>

func (l *ConcatLayout) Size(width, height int) (int, int) <span class="cov0" title="0">{
        totalLen := 0
        maxDepth := 0
        for _, c := range l.cs </span><span class="cov0" title="0">{
                reqWidth, reqHeight := c.Size(width, height)
                reqLen, reqDepth := whToLd(reqWidth, reqHeight, l.dir)
                if reqLen == GROW </span><span class="cov0" title="0">{
                        totalLen = GROW
                }</span>
                <span class="cov0" title="0">if totalLen != GROW </span><span class="cov0" title="0">{
                        totalLen += reqLen
                }</span>
                <span class="cov0" title="0">if reqDepth &gt; maxDepth </span><span class="cov0" title="0">{
                        maxDepth = reqDepth
                }</span>
        }
        <span class="cov0" title="0">return ldToWh(totalLen, maxDepth, l.dir)</span>
}

func (l *ConcatLayout) Render(w Writer, width int, height int) error <span class="cov8" title="1">{
        offset := 0
        for _, c := range l.cs </span><span class="cov8" title="1">{
                reqWidth, reqHeight := c.Size(width, height)

                var subW Writer
                if l.dir == DirHor </span><span class="cov0" title="0">{
                        subW = w.Divide(offset, 0, reqWidth, reqHeight)
                        offset += reqWidth
                }</span> else<span class="cov8" title="1"> {
                        subW = w.Divide(0, offset, reqWidth, reqHeight)
                        offset += reqHeight
                }</span>

                <span class="cov8" title="1">subW.RenderChild(c)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func NewLines() *ConcatLayout <span class="cov8" title="1">{
        return NewConcatLayout(DirVert)
}</span>

type Line struct {
        del *FlexLayout
}

func NewLine() *Line <span class="cov8" title="1">{
        return &amp;Line{del: NewFlexLayout(DirHor)}
}</span>

func (l *Line) Add(c Component) <span class="cov8" title="1">{
        l.del.Add(c)
}</span>

func (l *Line) Size(width int, height int) (int, int) <span class="cov8" title="1">{
        return width, 1
}</span>

func (l *Line) Render(w Writer, width int, height int) error <span class="cov8" title="1">{
        w.SetContent(0, 0, 0, nil) // set at least one to take up our line
        w.Divide(0, 0, width, height).RenderChild(l.del)
        return nil
}</span>

type ColorLayout struct {
        del        Component
        color      tcell.Color
        foreground bool
}

func Fg(del Component, color tcell.Color) Component <span class="cov8" title="1">{
        return &amp;ColorLayout{
                del:        del,
                color:      color,
                foreground: true,
        }
}</span>

func Bg(del Component, color tcell.Color) Component <span class="cov8" title="1">{
        return &amp;ColorLayout{
                del:        del,
                color:      color,
                foreground: false,
        }
}</span>

func (l *ColorLayout) Size(width int, height int) (int, int) <span class="cov8" title="1">{
        return l.del.Size(width, height)
}</span>

func (l *ColorLayout) Render(w Writer, width int, height int) error <span class="cov8" title="1">{
        if l.foreground </span><span class="cov8" title="1">{
                w = w.Foreground(l.color)
        }</span> else<span class="cov8" title="1"> {
                w = w.Background(l.color)
        }</span>
        <span class="cov8" title="1">w = w.Fill()
        w.RenderChild(l.del)
        return nil</span>
}

type Box struct {
        focused bool
        inner   Component
}

func NewBox() *Box <span class="cov8" title="1">{
        return &amp;Box{}
}</span>

func (b *Box) SetInner(c Component) <span class="cov8" title="1">{
        b.inner = c
}</span>

func (b *Box) SetFocused(focused bool) <span class="cov8" title="1">{
        b.focused = focused
}</span>

func (b *Box) Size(width int, height int) (int, int) <span class="cov8" title="1">{
        return width, height
}</span>

func (b *Box) Render(w Writer, width int, height int) error <span class="cov8" title="1">{
        if height == GROW &amp;&amp; b.inner == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("box must have either fixed height or a child")
        }</span>

        <span class="cov8" title="1">if b.inner != nil </span><span class="cov8" title="1">{
                innerHeight := height - 2
                if height == GROW </span><span class="cov0" title="0">{
                        innerHeight = GROW
                }</span>

                <span class="cov8" title="1">childHeight := w.Divide(1, 1, width-2, innerHeight).RenderChild(b.inner)
                height = childHeight + 2</span>
        }

        <span class="cov8" title="1">hor := tview.BoxDrawingsLightHorizontal
        vert := tview.BoxDrawingsLightVertical
        tl := tview.BoxDrawingsLightDownAndRight
        tr := tview.BoxDrawingsLightDownAndLeft
        bl := tview.BoxDrawingsLightUpAndRight
        br := tview.BoxDrawingsLightUpAndLeft
        if b.focused </span><span class="cov8" title="1">{
                hor = tview.BoxDrawingsDoubleHorizontal
                vert = tview.BoxDrawingsDoubleVertical
                tl = tview.BoxDrawingsDoubleDownAndRight
                tr = tview.BoxDrawingsDoubleDownAndLeft
                bl = tview.BoxDrawingsDoubleUpAndRight
                br = tview.BoxDrawingsDoubleUpAndLeft
        }</span>

        <span class="cov8" title="1">for i := 1; i &lt; width-1; i++ </span><span class="cov8" title="1">{
                w.SetContent(i, 0, hor, nil)
                w.SetContent(i, height-1, hor, nil)
        }</span>

        <span class="cov8" title="1">for i := 1; i &lt; height-1; i++ </span><span class="cov8" title="1">{
                w.SetContent(0, i, vert, nil)
                w.SetContent(width-1, i, vert, nil)
        }</span>

        <span class="cov8" title="1">w.SetContent(0, 0, tl, nil)
        w.SetContent(width-1, 0, tr, nil)
        w.SetContent(0, height-1, bl, nil)
        w.SetContent(width-1, height-1, br, nil)

        return nil</span>
}

// FixedSizeLayout fixes a component to a size
type FixedSizeLayout struct {
        del    Component
        width  int
        height int
}

func NewFixedSize(del Component, width int, height int) *FixedSizeLayout <span class="cov0" title="0">{
        return &amp;FixedSizeLayout{del: del, width: width, height: height}
}</span>

func (l *FixedSizeLayout) Size(width int, height int) (int, int) <span class="cov0" title="0">{
        if l.width != GROW &amp;&amp; l.height != GROW </span><span class="cov0" title="0">{
                return l.width, l.height
        }</span>
        <span class="cov0" title="0">rWidth, rHeight := l.width, l.height
        delWidth, delHeight := l.del.Size(width, height)
        if rWidth == GROW </span><span class="cov0" title="0">{
                rWidth = delWidth
        }</span>
        <span class="cov0" title="0">if rHeight == GROW </span><span class="cov0" title="0">{
                rHeight = delHeight
        }</span>

        <span class="cov0" title="0">return rWidth, rHeight</span>
}

func (l *FixedSizeLayout) Render(w Writer, width int, height int) error <span class="cov0" title="0">{
        w.RenderChild(l.del)
        return nil
}</span>
</pre>
		
		<pre class="file" id="file63" style="display: none">package rty

import (
        "fmt"

        "github.com/windmilleng/tcell"
)

func NewRTY(screen tcell.Screen) RTY <span class="cov0" title="0">{
        return &amp;rty{
                screen: screen,
                state:  make(renderState),
        }
}</span>

type rty struct {
        screen tcell.Screen
        state  renderState
}

type renderState map[string]interface{}

func (r *rty) Render(c Component) error <span class="cov0" title="0">{
        r.screen.Clear()
        g := &amp;renderGlobals{
                prev: r.state,
                next: make(renderState),
        }
        f := renderFrame{
                canvas:  newScreenCanvas(r.screen),
                globals: g,
        }

        f.RenderChild(c)
        r.screen.Show()
        r.state = g.next
        return g.err
}</span>

func (r *rty) RegisterElementScroll(name string, children []string) (l *ElementScrollLayout, selectedChild string) <span class="cov0" title="0">{
        r.state[name], selectedChild = adjustElementScroll(r.state[name], children)
        return &amp;ElementScrollLayout{
                name: name,
        }, selectedChild
}</span>

func (r *rty) ElementScroller(name string) ElementScroller <span class="cov0" title="0">{
        st, ok := r.state[name]
        if !ok </span><span class="cov0" title="0">{
                st = &amp;ElementScrollState{}
                r.state[name] = st
        }</span>

        <span class="cov0" title="0">return &amp;ElementScrollController{state: st.(*ElementScrollState)}</span>
}

func (r *rty) TextScroller(name string) TextScroller <span class="cov0" title="0">{
        st, ok := r.state[name]
        if !ok </span><span class="cov0" title="0">{
                st = &amp;TextScrollState{}
                r.state[name] = st
        }</span>

        <span class="cov0" title="0">return &amp;TextScrollController{state: st.(*TextScrollState)}</span>
}

type renderGlobals struct {
        err  error
        prev renderState
        next renderState
}

func (g *renderGlobals) Get(key string) interface{} <span class="cov0" title="0">{
        return g.prev[key]
}</span>

func (g *renderGlobals) Set(key string, d interface{}) <span class="cov0" title="0">{
        g.next[key] = d
}</span>

func (g *renderGlobals) errorf(format string, a ...interface{}) <span class="cov8" title="1">{
        if g.err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">g.err = fmt.Errorf(format, a...)</span>
}

type renderFrame struct {
        canvas Canvas

        style tcell.Style

        globals *renderGlobals
}

func (f renderFrame) SetContent(x int, y int, mainc rune, combc []rune) <span class="cov8" title="1">{
        if err := f.canvas.SetContent(x, y, mainc, combc, f.style); err != nil </span><span class="cov0" title="0">{
                f.error(err)
        }</span>
}

func (f renderFrame) Fill() Writer <span class="cov8" title="1">{
        width, height := f.canvas.Size()
        f.canvas = newSubCanvas(f.canvas, 0, 0, width, height, f.style)
        return f
}</span>

func (f renderFrame) Divide(x, y, width, height int) Writer <span class="cov8" title="1">{
        f.canvas = newSubCanvas(f.canvas, x, y, width, height, f.style)
        return f
}</span>

func (f renderFrame) Foreground(c tcell.Color) Writer <span class="cov8" title="1">{
        f.style = f.style.Foreground(c)
        return f
}</span>

func (f renderFrame) Background(c tcell.Color) Writer <span class="cov8" title="1">{
        f.style = f.style.Background(c)
        return f
}</span>

func (f renderFrame) RenderChild(c Component) int <span class="cov8" title="1">{
        width, height := f.canvas.Size()
        if err := c.Render(f, width, height); err != nil </span><span class="cov8" title="1">{
                f.error(err)
        }</span>

        <span class="cov8" title="1">_, height = f.canvas.Close()
        return height</span>
}

func (f renderFrame) Style(style tcell.Style) Writer <span class="cov0" title="0">{
        width, height := f.canvas.Size()
        f.canvas = newSubCanvas(f.canvas, 0, 0, width, height, style)
        return f
}</span>

func (f renderFrame) RenderChildInTemp(c Component) Canvas <span class="cov0" title="0">{
        width, _ := f.canvas.Size()
        tmp := newTempCanvas(width, GROW, f.style)
        f.canvas = tmp

        if err := c.Render(f, width, GROW); err != nil </span><span class="cov0" title="0">{
                f.error(err)
        }</span>
        <span class="cov0" title="0">tmp.Close()
        return tmp</span>
}

func (f renderFrame) Embed(src Canvas, srcY int, srcHeight int) <span class="cov0" title="0">{
        width, destLines := f.canvas.Size()

        numLines := destLines
        if srcHeight &lt; destLines </span><span class="cov0" title="0">{
                numLines = srcHeight
        }</span>

        <span class="cov0" title="0">for i := 0; i &lt; numLines; i++ </span><span class="cov0" title="0">{
                for j := 0; j &lt; width; j++ </span><span class="cov0" title="0">{
                        mainc, combc, style, _ := src.GetContent(j, srcY+i)
                        if err := f.canvas.SetContent(j, i, mainc, combc, style); err != nil </span><span class="cov0" title="0">{
                                f.error(err)
                        }</span>
                }
        }
}

func (f renderFrame) RenderStateful(c StatefulComponent, name string) <span class="cov0" title="0">{
        prev := f.globals.Get(name)

        width, height := f.canvas.Size()
        next, err := c.RenderStateful(f, prev, width, height)
        if err != nil </span><span class="cov0" title="0">{
                f.error(err)
        }</span>

        <span class="cov0" title="0">f.globals.Set(name, next)</span>
}

func (f renderFrame) errorf(fmt string, a ...interface{}) <span class="cov0" title="0">{
        f.globals.errorf(fmt, a...)
}</span>

func (f renderFrame) error(err error) <span class="cov8" title="1">{
        f.globals.errorf("%s", err.Error())
}</span>
</pre>
		
		<pre class="file" id="file64" style="display: none">package rty

import (
        "strings"
)

type StatefulComponent interface {
        RenderStateful(w Writer, prevState interface{}, width, height int) (state interface{}, err error)
}

type TextScrollLayout struct {
        name string
        cs   []Component
}

func NewTextScrollLayout(name string) *TextScrollLayout <span class="cov0" title="0">{
        return &amp;TextScrollLayout{name: name}
}</span>

func (l *TextScrollLayout) Add(c Component) <span class="cov0" title="0">{
        l.cs = append(l.cs, c)
}</span>

func (l *TextScrollLayout) Size(width int, height int) (int, int) <span class="cov0" title="0">{
        return width, height
}</span>

type TextScrollState struct {
        width  int
        height int

        canvasIdx     int
        lineIdx       int // line within canvas
        canvasLengths []int

        following bool
}

func defaultTextScrollState() *TextScrollState <span class="cov0" title="0">{
        return &amp;TextScrollState{following: true}
}</span>
func (l *TextScrollLayout) Render(w Writer, width, height int) error <span class="cov0" title="0">{
        w.RenderStateful(l, l.name)
        return nil
}</span>

func (l *TextScrollLayout) RenderStateful(w Writer, prevState interface{}, width, height int) (state interface{}, err error) <span class="cov0" title="0">{
        prev, ok := prevState.(*TextScrollState)
        if !ok </span><span class="cov0" title="0">{
                prev = defaultTextScrollState()
        }</span>
        <span class="cov0" title="0">next := &amp;TextScrollState{
                width:     width,
                height:    height,
                following: prev.following,
        }

        if len(l.cs) == 0 </span><span class="cov0" title="0">{
                return next, nil
        }</span>

        <span class="cov0" title="0">next.canvasLengths = make([]int, len(l.cs))
        canvases := make([]Canvas, len(l.cs))

        for i, c := range l.cs </span><span class="cov0" title="0">{
                childCanvas := w.RenderChildInTemp(c)
                canvases[i] = childCanvas
                _, childHeight := childCanvas.Size()
                next.canvasLengths[i] = childHeight
        }</span>

        <span class="cov0" title="0">l.adjustCursor(prev, next, canvases)

        y := 0
        canvases = canvases[next.canvasIdx:]

        if next.lineIdx != 0 </span><span class="cov0" title="0">{
                firstCanvas := canvases[0]
                canvases = canvases[1:]
                _, firstHeight := firstCanvas.Size()
                numLines := firstHeight - prev.lineIdx
                if numLines &gt; height </span><span class="cov0" title="0">{
                        numLines = height
                }</span>

                <span class="cov0" title="0">w.Divide(0, 0, width, numLines).Embed(firstCanvas, next.lineIdx, numLines)
                y += numLines</span>
        }

        <span class="cov0" title="0">for _, canvas := range canvases </span><span class="cov0" title="0">{
                _, canvasHeight := canvas.Size()
                numLines := canvasHeight
                if numLines &gt; height-y </span><span class="cov0" title="0">{
                        numLines = height - y
                }</span>
                <span class="cov0" title="0">w.Divide(0, y, width, numLines).Embed(canvas, 0, numLines)
                y += numLines</span>
        }

        <span class="cov0" title="0">return next, nil</span>
}

func (l *TextScrollLayout) adjustCursor(prev *TextScrollState, next *TextScrollState, canvases []Canvas) <span class="cov0" title="0">{
        if next.following </span><span class="cov0" title="0">{
                next.jumpToBottom(canvases)
                return
        }</span>

        <span class="cov0" title="0">if prev.canvasIdx &gt;= len(canvases) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">next.canvasIdx = prev.canvasIdx
        _, canvasHeight := canvases[next.canvasIdx].Size()
        if prev.lineIdx &gt;= canvasHeight </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">next.lineIdx = prev.lineIdx</span>
}

func (s *TextScrollState) jumpToBottom(canvases []Canvas) <span class="cov0" title="0">{
        totalHeight := totalHeight(canvases)
        if totalHeight &lt;= s.height </span><span class="cov0" title="0">{
                // all content fits on the screen
                s.canvasIdx = 0
                s.lineIdx = 0
                return
        }</span>

        <span class="cov0" title="0">heightLeft := s.height
        for i := range canvases </span><span class="cov0" title="0">{
                // we actually want to iterate from the end
                iEnd := len(canvases) - i - 1
                c := canvases[iEnd]

                _, cHeight := c.Size()
                if cHeight &lt; heightLeft </span><span class="cov0" title="0">{
                        heightLeft -= cHeight
                }</span> else<span class="cov0" title="0"> if cHeight == heightLeft </span><span class="cov0" title="0">{
                        // start at the beginning of this canvas
                        s.canvasIdx = iEnd
                        s.lineIdx = 0
                        return
                }</span> else<span class="cov0" title="0"> {
                        // start some number of lines into this canvas.
                        s.canvasIdx = iEnd
                        s.lineIdx = cHeight - heightLeft
                        return
                }</span>
        }
}

type TextScrollController struct {
        state *TextScrollState
}

func (s *TextScrollController) Up() <span class="cov0" title="0">{
        st := s.state
        if st.lineIdx != 0 </span><span class="cov0" title="0">{
                st.lineIdx--
                return
        }</span>

        <span class="cov0" title="0">if st.canvasIdx == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">st.canvasIdx--
        st.lineIdx = st.canvasLengths[st.canvasIdx] - 1</span>
}

func (s *TextScrollController) Down() <span class="cov0" title="0">{
        st := s.state
        canvasLength := st.canvasLengths[st.canvasIdx]
        if st.lineIdx &lt; canvasLength-1 </span><span class="cov0" title="0">{
                // we can just go down in this canvas
                st.lineIdx++
                return
        }</span>
        <span class="cov0" title="0">if st.canvasIdx == len(st.canvasLengths)-1 </span><span class="cov0" title="0">{
                // we're at the end of the last canvas
                return
        }</span>
        <span class="cov0" title="0">st.canvasIdx++
        st.lineIdx = 0</span>
}

func (s *TextScrollController) ToggleFollow() <span class="cov0" title="0">{
        s.state.following = !s.state.following
}</span>

func NewScrollingWrappingTextArea(name string, text string) Component <span class="cov0" title="0">{
        l := NewTextScrollLayout(name)
        lines := strings.Split(text, "\n")
        for _, line := range lines </span><span class="cov0" title="0">{
                l.Add(TextString(line + "\n"))
        }</span>
        <span class="cov0" title="0">return l</span>
}

type ElementScrollLayout struct {
        name     string
        children []Component
}

func NewElementScrollLayout(name string) *ElementScrollLayout <span class="cov0" title="0">{
        return &amp;ElementScrollLayout{name: name}
}</span>

func (l *ElementScrollLayout) Add(c Component) <span class="cov0" title="0">{
        l.children = append(l.children, c)
}</span>

func (l *ElementScrollLayout) Size(width int, height int) (int, int) <span class="cov0" title="0">{
        return width, height
}</span>

type ElementScrollState struct {
        width  int
        height int

        children []string

        elementIdx int
}

func (l *ElementScrollLayout) Render(w Writer, width, height int) error <span class="cov0" title="0">{
        w.RenderStateful(l, l.name)
        return nil
}</span>

func (l *ElementScrollLayout) RenderStateful(w Writer, prevState interface{}, width, height int) (state interface{}, err error) <span class="cov0" title="0">{
        prev, ok := prevState.(*ElementScrollState)
        if !ok </span><span class="cov0" title="0">{
                prev = &amp;ElementScrollState{}
        }</span>
        <span class="cov0" title="0">next := &amp;ElementScrollState{
                width:      width,
                height:     height,
                children:   prev.children,
                elementIdx: prev.elementIdx,
        }

        if len(l.children) == 0 </span><span class="cov0" title="0">{
                return next, nil
        }</span>

        <span class="cov0" title="0">y := 0
        for _, c := range l.children </span><span class="cov0" title="0">{
                canvas := w.RenderChildInTemp(c)
                _, childHeight := canvas.Size()
                numLines := childHeight
                if numLines &gt; height-y </span><span class="cov0" title="0">{
                        numLines = height - y
                }</span>
                <span class="cov0" title="0">w.Divide(0, y, width, numLines).Embed(canvas, 0, numLines)
                y += numLines</span>
        }

        <span class="cov0" title="0">return next, nil</span>
}

type ElementScrollController struct {
        state *ElementScrollState
}

func adjustElementScroll(prevInt interface{}, newChildren []string) (*ElementScrollState, string) <span class="cov0" title="0">{
        prev, ok := prevInt.(*ElementScrollState)
        if !ok </span><span class="cov0" title="0">{
                prev = &amp;ElementScrollState{}
        }</span>

        <span class="cov0" title="0">next := &amp;ElementScrollState{
                width:    prev.width,
                height:   prev.height,
                children: newChildren,
        }
        if len(prev.children) == 0 </span><span class="cov0" title="0">{
                return next, ""
        }</span>
        <span class="cov0" title="0">prevChild := prev.children[prev.elementIdx]
        for i, child := range newChildren </span><span class="cov0" title="0">{
                if child == prevChild </span><span class="cov0" title="0">{
                        next.elementIdx = i
                        return next, child
                }</span>
        }
        <span class="cov0" title="0">return next, ""</span>
}

func (s *ElementScrollController) GetSelectedIndex() int <span class="cov0" title="0">{
        return s.state.elementIdx
}</span>

func (s *ElementScrollController) GetSelectedChild() string <span class="cov0" title="0">{
        if len(s.state.children) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return s.state.children[s.state.elementIdx]</span>
}

func (s *ElementScrollController) UpElement() <span class="cov0" title="0">{
        if s.state.elementIdx == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">s.state.elementIdx--</span>
}

func (s *ElementScrollController) DownElement() <span class="cov0" title="0">{
        if s.state.elementIdx == len(s.state.children)-1 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">s.state.elementIdx++</span>
}
</pre>
		
		<pre class="file" id="file65" style="display: none">package rty

import (
        "fmt"

        "github.com/windmilleng/tcell"
)

type StringBuilder interface {
        Text(string) StringBuilder
        Textf(string, ...interface{}) StringBuilder
        Fg(tcell.Color) StringBuilder
        Bg(tcell.Color) StringBuilder
        Build() Component
}

func NewStringBuilder() StringBuilder <span class="cov8" title="1">{
        return &amp;stringBuilder{}
}</span>

type directive interface {
        directive()
}

type textDirective string
type fgDirective tcell.Color
type bgDirective tcell.Color

func (textDirective) directive() {<span class="cov0" title="0">}</span>
func (fgDirective) directive()   {<span class="cov0" title="0">}</span>
func (bgDirective) directive()   {<span class="cov0" title="0">}</span>

type stringBuilder struct {
        directives []directive
}

func (b *stringBuilder) Text(t string) StringBuilder <span class="cov8" title="1">{
        t = TranslateANSI(t)
        colorIndices, colors, _, _, _ := decomposeString(t)
        var colorPos int
        var foregroundColor, backgroundColor, attributes string

        var chs []rune

        flush := func() </span><span class="cov8" title="1">{
                if len(chs) == 0 </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">b.directives = append(b.directives, textDirective(string(chs)))
                chs = nil</span>
        }

        <span class="cov8" title="1">for pos, ch := range t </span><span class="cov8" title="1">{
                // Handle color tags.
                if colorPos &lt; len(colorIndices) &amp;&amp; pos &gt;= colorIndices[colorPos][0] &amp;&amp; pos &lt; colorIndices[colorPos][1] </span><span class="cov8" title="1">{
                        if pos == colorIndices[colorPos][1]-1 </span><span class="cov8" title="1">{
                                flush()
                                foregroundColor, backgroundColor, attributes = styleFromTag(foregroundColor, backgroundColor, attributes, colors[colorPos])
                                colorPos++
                                b.directives = append(b.directives, fgDirective(tcell.GetColor(foregroundColor)))
                                b.directives = append(b.directives, bgDirective(tcell.GetColor(backgroundColor)))
                        }</span>
                        <span class="cov8" title="1">continue</span>
                }

                <span class="cov8" title="1">chs = append(chs, ch)</span>
        }

        <span class="cov8" title="1">flush()

        return b</span>
}

func (b *stringBuilder) Textf(format string, a ...interface{}) StringBuilder <span class="cov0" title="0">{
        b.Text(fmt.Sprintf(format, a...))
        return b
}</span>

func (b *stringBuilder) Fg(c tcell.Color) StringBuilder <span class="cov8" title="1">{
        b.directives = append(b.directives, fgDirective(c))
        return b
}</span>

func (b *stringBuilder) Bg(c tcell.Color) StringBuilder <span class="cov8" title="1">{
        b.directives = append(b.directives, bgDirective(c))
        return b
}</span>

func (b *stringBuilder) Build() Component <span class="cov8" title="1">{
        return &amp;StringLayout{directives: b.directives}
}</span>

type StringLayout struct {
        directives []directive
}

func TextString(s string) Component <span class="cov8" title="1">{
        return NewStringBuilder().Text(s).Build()
}</span>

func ColoredString(s string, fg tcell.Color) Component <span class="cov8" title="1">{
        return NewStringBuilder().Fg(fg).Text(s).Build()
}</span>

func BgColoredString(s string, fg tcell.Color, bg tcell.Color) Component <span class="cov8" title="1">{
        return NewStringBuilder().Fg(fg).Bg(bg).Text(s).Build()
}</span>

func (l *StringLayout) Size(availWidth int, availHeight int) (int, int) <span class="cov8" title="1">{
        return l.render(nil, availWidth, availHeight)
}</span>

func (l *StringLayout) Render(w Writer, width int, height int) error <span class="cov8" title="1">{
        l.render(w, width, height)
        return nil
}</span>

// returns width, height for laying out full string
func (l *StringLayout) render(w Writer, width int, height int) (int, int) <span class="cov8" title="1">{
        nextX, nextY := 0, 0
        maxWidth := 0
        for _, d := range l.directives </span><span class="cov8" title="1">{
                var s string
                switch d := d.(type) </span>{
                case textDirective:<span class="cov8" title="1">
                        s = string(d)</span>
                case fgDirective:<span class="cov8" title="1">
                        if w != nil </span><span class="cov8" title="1">{
                                w = w.Foreground(tcell.Color(d))
                        }</span>
                        <span class="cov8" title="1">continue</span>
                case bgDirective:<span class="cov8" title="1">
                        if w != nil </span><span class="cov8" title="1">{
                                w = w.Background(tcell.Color(d))
                        }</span>
                        <span class="cov8" title="1">continue</span>
                default:<span class="cov0" title="0">
                        panic(fmt.Errorf("StringLayout.Render: unexpected directive %T %+v", d, d))</span>
                }

                // now we know it's a text directive
                <span class="cov8" title="1">for _, ch := range s </span><span class="cov8" title="1">{
                        // TODO(dbentley): combining characters
                        // TODO(dbentley): tab, etc.
                        // TODO(dbentley): runewidth
                        if nextX &gt;= width </span><span class="cov8" title="1">{
                                nextX, nextY = 0, nextY+1
                        }</span>
                        <span class="cov8" title="1">if nextX+1 &gt; maxWidth </span><span class="cov8" title="1">{
                                maxWidth = nextX + 1
                        }</span>
                        <span class="cov8" title="1">if nextY &gt;= height </span><span class="cov8" title="1">{
                                return maxWidth, height
                        }</span>
                        <span class="cov8" title="1">if ch == '\n' </span><span class="cov8" title="1">{
                                if nextX == 0 &amp;&amp; w != nil </span><span class="cov0" title="0">{
                                        // make sure we take up our space
                                        w.SetContent(nextY, nextY, ch, nil)
                                }</span>
                                <span class="cov8" title="1">nextX, nextY = 0, nextY+1
                                continue</span>
                        }

                        <span class="cov8" title="1">if w != nil </span><span class="cov8" title="1">{
                                w.SetContent(nextX, nextY, ch, nil)
                        }</span>
                        <span class="cov8" title="1">nextX = nextX + 1</span>
                }
        }
        <span class="cov8" title="1">if nextY == 0 </span><span class="cov8" title="1">{
                nextY = 1
        }</span>
        <span class="cov8" title="1">return maxWidth, nextY</span>
}
</pre>
		
		<pre class="file" id="file66" style="display: none">package store

import (
        "fmt"
        "sort"

        "github.com/docker/distribution/reference"
        "github.com/windmilleng/tilt/internal/k8s"
)

// The results of a successful build.
type BuildResult struct {
        // The name+tag of the image that the pod is running.
        //
        // The tag is derived from a content-addressable digest.
        Image reference.NamedTagged

        // If this build was a container build, containerID we built on top of
        ContainerID k8s.ContainerID

        // The namespace where the pod was deployed.
        Namespace k8s.Namespace

        // The k8s entities deployed alongside the image.
        Entities []k8s.K8sEntity

        // Some of our build engines replace the files in-place, rather
        // than building a new image. This captures how much the code
        // running on-pod has diverged from the original image.
        FilesReplacedSet map[string]bool
}

func (b BuildResult) IsEmpty() bool <span class="cov0" title="0">{
        return b.Image == nil
}</span>

func (b BuildResult) HasImage() bool <span class="cov0" title="0">{
        return b.Image != nil
}</span>

// Clone the build result and add new replaced files.
// Does not do a deep clone of the underlying entities.
func (b BuildResult) ShallowCloneForContainerUpdate(filesReplacedSet map[string]bool) BuildResult <span class="cov0" title="0">{
        result := BuildResult{}
        result.Image = b.Image
        result.Namespace = b.Namespace
        result.Entities = append([]k8s.K8sEntity{}, b.Entities...)

        newSet := make(map[string]bool, len(b.FilesReplacedSet)+len(filesReplacedSet))
        for k, v := range b.FilesReplacedSet </span><span class="cov0" title="0">{
                newSet[k] = v
        }</span>
        <span class="cov0" title="0">for k, v := range filesReplacedSet </span><span class="cov0" title="0">{
                newSet[k] = v
        }</span>
        <span class="cov0" title="0">result.FilesReplacedSet = newSet
        return result</span>
}

// The state of the system since the last successful build.
// This data structure should be considered immutable.
// All methods that return a new BuildState should first clone the existing build state.
type BuildState struct {
        // The last successful build.
        LastResult BuildResult

        // Files changed since the last result was build.
        // This must be liberal: it's ok if this has too many files, but not ok if it has too few.
        FilesChangedSet map[string]bool
}

func NewBuildState(result BuildResult, files []string) BuildState <span class="cov0" title="0">{
        set := make(map[string]bool, len(files))
        for _, f := range files </span><span class="cov0" title="0">{
                set[f] = true
        }</span>
        <span class="cov0" title="0">return BuildState{
                LastResult:      result,
                FilesChangedSet: set,
        }</span>
}

func (b BuildState) LastImage() reference.NamedTagged <span class="cov0" title="0">{
        return b.LastResult.Image
}</span>

// Return the files changed since the last result in sorted order.
// The sorting helps ensure that this is deterministic, both for testing
// and for deterministic builds.
func (b BuildState) FilesChanged() []string <span class="cov0" title="0">{
        result := make([]string, 0, len(b.FilesChangedSet))
        for file, _ := range b.FilesChangedSet </span><span class="cov0" title="0">{
                result = append(result, file)
        }</span>
        <span class="cov0" title="0">sort.Strings(result)
        return result</span>
}

// Return the files changed since the last result's image in sorted order.
// The sorting helps ensure that this is deterministic, both for testing
// and for deterministic builds.
// Errors if there was no last result image.
func (b BuildState) FilesChangedSinceLastResultImage() ([]string, error) <span class="cov0" title="0">{
        if !b.LastResult.HasImage() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("No image in last result")
        }</span>

        <span class="cov0" title="0">cSet := b.FilesChangedSet
        rSet := b.LastResult.FilesReplacedSet
        sum := make(map[string]bool, len(cSet)+len(rSet))
        for k, v := range cSet </span><span class="cov0" title="0">{
                sum[k] = v
        }</span>
        <span class="cov0" title="0">for k, v := range rSet </span><span class="cov0" title="0">{
                sum[k] = v
        }</span>

        <span class="cov0" title="0">result := make([]string, 0, len(sum))
        for file, _ := range sum </span><span class="cov0" title="0">{
                result = append(result, file)
        }</span>
        <span class="cov0" title="0">sort.Strings(result)
        return result, nil</span>
}

// A build state is empty if there are no previous results.
func (b BuildState) IsEmpty() bool <span class="cov0" title="0">{
        return b.LastResult.IsEmpty()
}</span>

func (b BuildState) HasImage() bool <span class="cov0" title="0">{
        return b.LastResult.HasImage()
}</span>

var BuildStateClean = BuildState{}
</pre>
		
		<pre class="file" id="file67" style="display: none">package store

import (
        "bytes"
        "context"
        "net/url"
        "sort"
        "time"

        "github.com/pkg/errors"
        "github.com/windmilleng/tilt/internal/build"
        "github.com/windmilleng/tilt/internal/hud/view"
        "github.com/windmilleng/tilt/internal/k8s"
        "github.com/windmilleng/tilt/internal/logger"
        "github.com/windmilleng/tilt/internal/model"
        "github.com/windmilleng/tilt/internal/ospath"
        "k8s.io/api/core/v1"
)

type EngineState struct {
        // saved so that we can render in order
        ManifestDefinitionOrder []model.ManifestName

        ManifestStates    map[model.ManifestName]*ManifestState
        ManifestsToBuild  []model.ManifestName
        CurrentlyBuilding model.ManifestName
        WatchMounts       bool

        // How many builds were queued on startup (i.e., how many manifests there were)
        InitialBuildCount int

        // How many builds have been completed (pass or fail) since starting tilt
        CompletedBuildCount int

        // For synchronizing BuildController so that it's only
        // doing one action at a time. In the future, we might
        // want to allow it to parallelize builds better, but that
        // would require better tools for triaging output to different streams.
        BuildControllerActionCount int

        PermanentError error
}

type ManifestState struct {
        LastBuild    BuildResult
        Manifest     model.Manifest
        Pod          Pod
        LBs          map[k8s.ServiceName]*url.URL
        HasBeenBuilt bool

        // TODO(nick): Maybe we should keep timestamps for the most
        // recent change to each file?
        PendingFileChanges map[string]bool

        CurrentlyBuildingFileChanges []string

        CurrentBuildStartTime     time.Time
        CurrentBuildLog           *bytes.Buffer
        LastSuccessfulDeployEdits []string
        LastError                 error
        LastBuildFinishTime       time.Time
        LastSuccessfulDeployTime  time.Time
        LastBuildDuration         time.Duration
        LastBuildLog              *bytes.Buffer
        QueueEntryTime            time.Time

        // If the pod isn't running this container then it's possible we're running stale code
        ExpectedContainerID k8s.ContainerID
        // We detected stale code and are currently doing an image build
        CrashRebuildInProg bool
        // we've observed changes to config file(s) and need to reload the manifest next time we start a build
        ConfigIsDirty bool
}

func NewState() *EngineState <span class="cov8" title="1">{
        ret := &amp;EngineState{}
        ret.ManifestStates = make(map[model.ManifestName]*ManifestState)
        return ret
}</span>

func NewManifestState(manifest model.Manifest) *ManifestState <span class="cov8" title="1">{
        return &amp;ManifestState{
                LastBuild:          BuildResult{},
                Manifest:           manifest,
                PendingFileChanges: make(map[string]bool),
                LBs:                make(map[k8s.ServiceName]*url.URL),
                CurrentBuildLog:    &amp;bytes.Buffer{},
        }
}</span>

type Pod struct {
        PodID     k8s.PodID
        Namespace k8s.Namespace
        StartedAt time.Time
        Status    string
        Phase     v1.PodPhase

        // The log for the previously active pod, if any
        PreRestartLog []byte
        // The log for the currently active pod, if any
        Log []byte

        // Corresponds to the deployed container.
        ContainerName  k8s.ContainerName
        ContainerID    k8s.ContainerID
        ContainerPorts []int32
        ContainerReady bool

        // We want to show the user # of restarts since pod has been running current code,
        // i.e. OldRestarts - Total Restarts
        ContainerRestarts int
        OldRestarts       int // # times the pod restarted when it was running old code
}

func shortenFile(baseDirs []string, f string) string <span class="cov8" title="1">{
        ret := f
        for _, baseDir := range baseDirs </span><span class="cov8" title="1">{
                short, isChild := ospath.Child(baseDir, f)
                if isChild &amp;&amp; len(short) &lt; len(ret) </span><span class="cov8" title="1">{
                        ret = short
                }</span>
        }
        <span class="cov8" title="1">return ret</span>
}

// for each filename in `files`, trims the longest appropriate basedir prefix off the front
func shortenFileList(baseDirs []string, files []string) []string <span class="cov8" title="1">{
        baseDirs = append([]string{}, baseDirs...)

        var ret []string
        for _, f := range files </span><span class="cov8" title="1">{
                ret = append(ret, shortenFile(baseDirs, f))
        }</span>
        <span class="cov8" title="1">return ret</span>
}

// Returns the manifests in order.
func (s EngineState) Manifests() []model.Manifest <span class="cov0" title="0">{
        result := make([]model.Manifest, 0)
        for _, name := range s.ManifestDefinitionOrder </span><span class="cov0" title="0">{
                ms := s.ManifestStates[name]
                result = append(result, ms.Manifest)
        }</span>
        <span class="cov0" title="0">return result</span>
}

// Returns a set of pending file changes, without config files that don't belong
// to mounts. (Changed config files show up in ms.PendingFileChanges and don't
// necessarily belong to any mounts/watched directories -- we don't want to run
// these files through a build b/c we'll pitch an error if we find un-mounted
// files at that point.)
func (ms *ManifestState) PendingFileChangesWithoutUnmountedConfigFiles(ctx context.Context) (map[string]bool, error) <span class="cov0" title="0">{
        matcher, err := ms.Manifest.ConfigMatcher()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "[PendingFileChangesWithoutUnmountedConfigFiles] getting config matcher")
        }</span>

        <span class="cov0" title="0">files := make(map[string]bool)
        for f := range ms.PendingFileChanges </span><span class="cov0" title="0">{
                matches, err := matcher.Matches(f, false)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Get(ctx).Infof("Error matching %s: %v", f, err)
                }</span>
                <span class="cov0" title="0">if matches &amp;&amp; !build.FileBelongsToMount(f, ms.Manifest.Mounts) </span><span class="cov0" title="0">{
                        // Filter out config files that don't belong to a mount
                        continue</span>
                }
                <span class="cov0" title="0">files[f] = true</span>
        }
        <span class="cov0" title="0">return files, nil</span>
}

func StateToView(s EngineState) view.View <span class="cov8" title="1">{
        ret := view.View{}

        for _, name := range s.ManifestDefinitionOrder </span><span class="cov8" title="1">{
                ms := s.ManifestStates[name]

                var absWatchDirs []string
                for _, p := range ms.Manifest.LocalPaths() </span><span class="cov8" title="1">{
                        absWatchDirs = append(absWatchDirs, p)
                }</span>
                <span class="cov8" title="1">relWatchDirs := ospath.TryAsCwdChildren(absWatchDirs)

                var pendingBuildEdits []string
                for f := range ms.PendingFileChanges </span><span class="cov8" title="1">{
                        pendingBuildEdits = append(pendingBuildEdits, f)
                }</span>

                <span class="cov8" title="1">pendingBuildEdits = shortenFileList(absWatchDirs, pendingBuildEdits)
                lastDeployEdits := shortenFileList(absWatchDirs, ms.LastSuccessfulDeployEdits)
                currentBuildEdits := shortenFileList(absWatchDirs, ms.CurrentlyBuildingFileChanges)

                // Sort the strings to make the outputs deterministic.
                sort.Strings(pendingBuildEdits)

                lastBuildError := ""
                if ms.LastError != nil </span><span class="cov0" title="0">{
                        lastBuildError = ms.LastError.Error()
                }</span>

                <span class="cov8" title="1">var endpoints []string
                for _, u := range ms.LBs </span><span class="cov0" title="0">{
                        if u != nil </span><span class="cov0" title="0">{
                                endpoints = append(endpoints, u.String())
                        }</span>
                }

                <span class="cov8" title="1">r := view.Resource{
                        Name:                  name.String(),
                        DirectoriesWatched:    relWatchDirs,
                        LastDeployTime:        ms.LastSuccessfulDeployTime,
                        LastDeployEdits:       lastDeployEdits,
                        LastBuildError:        lastBuildError,
                        LastBuildFinishTime:   ms.LastBuildFinishTime,
                        LastBuildDuration:     ms.LastBuildDuration,
                        PendingBuildEdits:     pendingBuildEdits,
                        PendingBuildSince:     ms.QueueEntryTime,
                        CurrentBuildEdits:     currentBuildEdits,
                        CurrentBuildStartTime: ms.CurrentBuildStartTime,
                        PodName:               ms.Pod.PodID.String(),
                        PodCreationTime:       ms.Pod.StartedAt,
                        PodStatus:             ms.Pod.Status,
                        PodRestarts:           ms.Pod.ContainerRestarts - ms.Pod.OldRestarts,
                        Endpoints:             endpoints,
                }

                ret.Resources = append(ret.Resources, r)</span>
        }

        <span class="cov8" title="1">return ret</span>
}
</pre>
		
		<pre class="file" id="file68" style="display: none">package store

import (
        "context"
        "sync"
)

// A central state store, modeled after the Reactive programming UX pattern.
// Terminology is borrowed liberally from Redux. These docs in particular are helpful:
// https://redux.js.org/introduction/threeprinciples
// https://redux.js.org/basics
type Store struct {
        state       *EngineState
        subscribers *subscriberList
        actionQueue *actionQueue
        actionCh    chan Action
        mu          sync.Mutex
        stateMu     sync.RWMutex

        // TODO(nick): Define Subscribers and Reducers.
        // The actionChan is an intermediate representation to make the transition easiser.
}

func NewStore() *Store <span class="cov8" title="1">{
        return &amp;Store{
                state:       NewState(),
                actionQueue: &amp;actionQueue{},
                actionCh:    make(chan Action),
                subscribers: &amp;subscriberList{},
        }
}</span>

func (s *Store) AddSubscriber(sub Subscriber) <span class="cov8" title="1">{
        s.subscribers.Add(sub)
}</span>

// Sends messages to all the subscribers asynchronously.
func (s *Store) NotifySubscribers(ctx context.Context) <span class="cov8" title="1">{
        s.subscribers.NotifyAll(ctx, s)
}</span>

// TODO(nick): Clone the state to ensure it's not mutated.
// For now, we use RW locks to simulate the same behavior, but the
// onus is on the caller to RUnlockState.
func (s *Store) RLockState() EngineState <span class="cov0" title="0">{
        s.stateMu.RLock()
        return *(s.state)
}</span>

func (s *Store) RUnlockState() <span class="cov0" title="0">{
        s.stateMu.RUnlock()
}</span>

// TODO(nick): Phase this out. Anyone that uses this should be implemented as a reducer.
func (s *Store) LockMutableState() *EngineState <span class="cov0" title="0">{
        s.stateMu.Lock()
        return s.state
}</span>

func (s *Store) UnlockMutableState() <span class="cov0" title="0">{
        s.stateMu.Unlock()
}</span>

func (s *Store) Actions() &lt;-chan Action <span class="cov0" title="0">{
        return s.actionCh
}</span>

func (s *Store) Dispatch(action Action) <span class="cov0" title="0">{
        s.actionQueue.add(action)
        go s.drainActions()
}</span>

func (s *Store) Close() <span class="cov0" title="0">{
        close(s.actionCh)
}</span>

func (s *Store) drainActions() <span class="cov0" title="0">{
        // The mutex here ensures that the actions appear on the channel in-order.
        // It will also be necessary once we have reducers.
        s.mu.Lock()
        defer s.mu.Unlock()

        actions := s.actionQueue.drain()
        for _, action := range actions </span><span class="cov0" title="0">{
                s.actionCh &lt;- action
        }</span>
}

type Action interface {
        Action()
}

type actionQueue struct {
        actions []Action
        mu      sync.Mutex
}

func (q *actionQueue) add(action Action) <span class="cov0" title="0">{
        q.mu.Lock()
        defer q.mu.Unlock()
        q.actions = append(q.actions, action)
}</span>

func (q *actionQueue) drain() []Action <span class="cov0" title="0">{
        q.mu.Lock()
        defer q.mu.Unlock()
        result := append([]Action{}, q.actions...)
        q.actions = nil
        return result
}</span>
</pre>
		
		<pre class="file" id="file69" style="display: none">package store

import (
        "context"
        "sync"
)

// A subscriber is notified whenever the state changes.
//
// Subscribers do not need to be thread-safe. The Store will only
// call OnChange for a given subscriber when the last call completes.
//
// Subscribers are only allowed to read state. If they want to
// modify state, they should call store.Dispatch()
type Subscriber interface {
        OnChange(ctx context.Context, store *Store)
}

type subscriberEntry struct {
        subscriber Subscriber
        mu         sync.Mutex
}

func (l *subscriberList) Add(s Subscriber) <span class="cov8" title="1">{
        l.mu.Lock()
        defer l.mu.Unlock()
        l.subscribers = append(l.subscribers, &amp;subscriberEntry{
                subscriber: s,
        })
}</span>

func (l *subscriberList) NotifyAll(ctx context.Context, store *Store) <span class="cov8" title="1">{
        l.mu.Lock()
        subscribers := append([]*subscriberEntry{}, l.subscribers...)
        l.mu.Unlock()

        for _, s := range subscribers </span><span class="cov8" title="1">{
                go s.notify(ctx, store)
        }</span>
}

type subscriberList struct {
        subscribers []*subscriberEntry
        mu          sync.Mutex
}

func (e *subscriberEntry) notify(ctx context.Context, store *Store) <span class="cov8" title="1">{
        e.mu.Lock()
        defer e.mu.Unlock()
        e.subscriber.OnChange(ctx, store)
}</span>
</pre>
		
		<pre class="file" id="file70" style="display: none">package sidecar

import (
        "github.com/docker/distribution/reference"
        "github.com/windmilleng/tilt/internal/k8s"
)

func InjectSyncletSidecar(entity k8s.K8sEntity, matchRef reference.Named) (k8s.K8sEntity, bool, error) <span class="cov8" title="1">{
        entity = entity.DeepCopy()

        pods, err := k8s.ExtractPods(&amp;entity)
        if err != nil </span><span class="cov0" title="0">{
                return k8s.K8sEntity{}, false, err
        }</span>

        <span class="cov8" title="1">replaced := false
        for _, pod := range pods </span><span class="cov8" title="1">{
                ok, err := k8s.PodContainsRef(pod, matchRef)
                if err != nil </span><span class="cov0" title="0">{
                        return k8s.K8sEntity{}, false, err
                }</span>

                <span class="cov8" title="1">if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">replaced = true
                vol := SyncletVolume.DeepCopy()
                pod.Volumes = append(pod.Volumes, *vol)

                container := SyncletContainer.DeepCopy()
                pod.Containers = append(pod.Containers, *container)</span>
        }
        <span class="cov8" title="1">return entity, replaced, nil</span>
}
</pre>
		
		<pre class="file" id="file71" style="display: none">package sidecar

import (
        "fmt"

        "github.com/windmilleng/tilt/internal/k8s"
        "k8s.io/apimachinery/pkg/api/resource"

        "k8s.io/api/core/v1"
)

func syncletPrivileged() *bool <span class="cov8" title="1">{
        val := true
        return &amp;val
}</span>

// When we deploy Tilt for development, we override this with LDFLAGS
var SyncletTag = "v20180928"

const SyncletImageName = "gcr.io/windmill-public-containers/tilt-synclet"
const SyncletContainerName = "tilt-synclet"

var SyncletImageRef = k8s.MustParseNamed(SyncletImageName)

var SyncletContainer = v1.Container{
        Name:            SyncletContainerName,
        Image:           fmt.Sprintf("%s:%s", SyncletImageName, SyncletTag),
        ImagePullPolicy: v1.PullIfNotPresent,
        Resources:       v1.ResourceRequirements{Requests: v1.ResourceList{v1.ResourceCPU: resource.MustParse("0Mi")}},
        VolumeMounts: []v1.VolumeMount{
                v1.VolumeMount{
                        Name:      "tilt-dockersock",
                        MountPath: "/var/run/docker.sock",
                },
        },
        SecurityContext: &amp;v1.SecurityContext{
                Privileged: syncletPrivileged(),
        },
}

var SyncletVolume = v1.Volume{
        Name: "tilt-dockersock",
        VolumeSource: v1.VolumeSource{
                HostPath: &amp;v1.HostPathVolumeSource{
                        Path: "/var/run/docker.sock",
                },
        },
}
</pre>
		
		<pre class="file" id="file72" style="display: none">package tiltfile

import (
        "errors"
        "fmt"
        "io/ioutil"
        "os"
        "path/filepath"
        "strings"

        "github.com/docker/distribution/reference"
        "github.com/google/skylark"
        "github.com/windmilleng/tilt/internal/model"
)

const oldMountSyntaxError = "The syntax for `add` has changed. Before it was `add(dest: string, src: string)`. Now it is `add(src: localPath, dest: string)`."
const noActiveBuildError = "No active build"

type compManifest struct {
        cManifest []*k8sManifest
}

var _ skylark.Value = compManifest{}

func (s compManifest) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("composite manifest: %+v", s.cManifest)
}</span>
func (s compManifest) Type() string <span class="cov0" title="0">{
        return "compManifest"
}</span>
func (s compManifest) Freeze() {<span class="cov0" title="0">
}</span>
func (compManifest) Truth() skylark.Bool <span class="cov0" title="0">{
        return true
}</span>
func (compManifest) Hash() (uint32, error) <span class="cov0" title="0">{
        return 0, errors.New("unhashable type: composite manifest")
}</span>

type k8sManifest struct {
        k8sYaml      skylark.String
        dockerImage  dockerImage
        name         string
        configFiles  []string
        portForwards []model.PortForward
}

var _ skylark.Value = &amp;k8sManifest{}
var _ skylark.HasAttrs = &amp;k8sManifest{}

func (k *k8sManifest) String() string <span class="cov0" title="0">{
        shortYaml := k.k8sYaml.String()
        const maxYamlCharsToInclude = 40
        if len(shortYaml) &gt; maxYamlCharsToInclude </span><span class="cov0" title="0">{
                shortYaml = shortYaml[:maxYamlCharsToInclude]
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("[k8sManifest] yaml: '%v' dockerImage: '%v'", shortYaml, k.dockerImage)</span>
}

func (k *k8sManifest) Type() string <span class="cov0" title="0">{
        return "k8sManifest"
}</span>

func (k *k8sManifest) Freeze() <span class="cov0" title="0">{
        k.k8sYaml.Freeze()
        k.dockerImage.Freeze()
}</span>

func (k *k8sManifest) Truth() skylark.Bool <span class="cov0" title="0">{
        return true
}</span>

func (k *k8sManifest) Hash() (uint32, error) <span class="cov0" title="0">{
        return 0, errors.New("unhashable type: k8sManifest")
}</span>

func (k *k8sManifest) Attr(name string) (skylark.Value, error) <span class="cov8" title="1">{
        switch name </span>{
        case "port_forward":<span class="cov8" title="1">
                return skylark.NewBuiltin(name, k.createPortForward), nil</span>
        default:<span class="cov0" title="0">
                return nil, nil</span>
        }
}

func (k *k8sManifest) AttrNames() []string <span class="cov0" title="0">{
        return []string{"port_forward"}
}</span>

func (k *k8sManifest) createPortForward(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) <span class="cov8" title="1">{
        var localPort int
        var containerPort int
        err := skylark.UnpackArgs(fn.Name(), args, kwargs, "local", &amp;localPort, "remote?", &amp;containerPort)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">k.portForwards = append(k.portForwards, model.PortForward{
                LocalPort:     localPort,
                ContainerPort: containerPort,
        })
        return skylark.None, nil</span>
}

type mount struct {
        src        localPath
        mountPoint string
        repo       gitRepo
}

// See model.Manifest for more information on what all these fields mean.
type dockerImage struct {
        baseDockerfilePath localPath
        ref                reference.Named
        mounts             []mount
        steps              []model.Step
        entrypoint         string
        tiltFilename       string

        staticDockerfilePath localPath
        staticBuildPath      localPath
}

var _ skylark.Value = &amp;dockerImage{}
var _ skylark.HasAttrs = &amp;dockerImage{}

func (t *Tiltfile) runDockerImageCmd(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) <span class="cov8" title="1">{
        var skylarkCmd skylark.String
        var trigger skylark.Value
        err := skylark.UnpackArgs(fn.Name(), args, kwargs, "cmd", &amp;skylarkCmd, "trigger?", &amp;trigger)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">buildContext, ok := thread.Local("buildContext").(*dockerImage)
        if buildContext == nil </span><span class="cov8" title="1">{
                return nil, errors.New("run called without a build context")
        }</span>
        <span class="cov8" title="1">if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("internal error: buildContext thread local was not of type *dockerImage")
        }</span>

        <span class="cov8" title="1">cmd, ok := skylark.AsString(skylarkCmd)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("internal error: skylarkCmd was not a string")
        }</span>

        <span class="cov8" title="1">var triggers []string
        switch trigger := trigger.(type) </span>{
        case *skylark.List:<span class="cov8" title="1">
                l := trigger.Len()
                triggers = make([]string, l)
                for i := 0; i &lt; l; i++ </span><span class="cov8" title="1">{
                        t := trigger.Index(i)
                        tStr, isStr := t.(skylark.String)
                        if !isStr </span><span class="cov0" title="0">{
                                return nil, badTypeErr(fn, skylark.String(""), t)
                        }</span>
                        <span class="cov8" title="1">triggers[i] = string(tStr)</span>
                }
        case skylark.String:<span class="cov8" title="1">
                triggers = []string{string(trigger)}</span>
        }

        <span class="cov8" title="1">step := model.ToStep(t.absWorkingDir(), model.ToShellCmd(cmd))

        step.Triggers = triggers

        buildContext.steps = append(buildContext.steps, step)
        return skylark.None, nil</span>
}

func addMount(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) <span class="cov8" title="1">{
        var src skylark.Value
        var mountPoint string

        buildContext, ok := thread.Local("buildContext").(*dockerImage)
        if buildContext == nil </span><span class="cov8" title="1">{
                return nil, errors.New("add called without a build context")
        }</span>
        <span class="cov8" title="1">if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("internal error: buildContext thread local was not of type *dockerImage")
        }</span>

        <span class="cov8" title="1">if len(buildContext.steps) &gt; 0 </span><span class="cov0" title="0">{
                return nil, errors.New("add mount before run command")
        }</span>
        <span class="cov8" title="1">err := skylark.UnpackArgs(fn.Name(), args, kwargs, "src", &amp;src, "dest", &amp;mountPoint)
        if err != nil </span><span class="cov8" title="1">{
                if strings.Contains(err.Error(), "got gitRepo, want string") </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf(oldMountSyntaxError)
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov8" title="1">m := mount{}
        switch p := src.(type) </span>{
        case localPath:<span class="cov8" title="1">
                m.src = p
                m.repo = p.repo</span>
        case gitRepo:<span class="cov8" title="1">
                m.src = localPath{p.basePath, p}
                m.repo = p</span>
        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("invalid type for src. Got %s want gitRepo OR localPath", src.Type())</span>
        }
        <span class="cov8" title="1">m.mountPoint = mountPoint
        buildContext.mounts = append(buildContext.mounts, m)

        return skylark.None, nil</span>
}

func (d *dockerImage) String() string <span class="cov0" title="0">{
        if d.baseDockerfilePath.Truth() </span><span class="cov0" title="0">{
                return fmt.Sprintf("fileName: %v, ref: %s, cmds: %v", d.baseDockerfilePath.path, d.ref, d.steps)
        }</span> else<span class="cov0" title="0"> {
                return fmt.Sprintf("fileName: %s, path: %s", d.staticDockerfilePath.path, d.staticBuildPath.path)
        }</span>
}

func (d *dockerImage) Type() string <span class="cov0" title="0">{
        return "dockerImage"
}</span>

func (d *dockerImage) Freeze() {<span class="cov0" title="0">
}</span>

func (*dockerImage) Truth() skylark.Bool <span class="cov0" title="0">{
        return true
}</span>

func (*dockerImage) Hash() (uint32, error) <span class="cov0" title="0">{
        return 0, errors.New("unhashable type: dockerImage")
}</span>

func (d *dockerImage) Attr(name string) (skylark.Value, error) <span class="cov0" title="0">{
        switch name </span>{
        case "file_name":<span class="cov0" title="0">
                if d.staticDockerfilePath.Truth() </span><span class="cov0" title="0">{
                        return d.staticDockerfilePath, nil
                }</span> else<span class="cov0" title="0"> {
                        return d.baseDockerfilePath, nil
                }</span>
        case "file_tag":<span class="cov0" title="0">
                return skylark.String(d.ref.String()), nil</span>
        default:<span class="cov0" title="0">
                return nil, nil</span>
        }
}

func (*dockerImage) AttrNames() []string <span class="cov0" title="0">{
        return []string{"file_name", "file_tag"}
}</span>

type gitRepo struct {
        basePath             string
        gitignoreContents    string
        dockerignoreContents string
}

func (t *Tiltfile) newGitRepo(path string) (gitRepo, error) <span class="cov8" title="1">{
        absPath := t.absPath(path)
        _, err := os.Stat(absPath)
        if err != nil </span><span class="cov8" title="1">{
                return gitRepo{}, fmt.Errorf("Reading path %s: %v", path, err)
        }</span>

        <span class="cov8" title="1">if _, err := os.Stat(filepath.Join(absPath, ".git")); os.IsNotExist(err) </span><span class="cov8" title="1">{
                return gitRepo{}, fmt.Errorf("%s isn't a valid git repo: it doesn't have a .git/ directory", absPath)
        }</span>

        <span class="cov8" title="1">gitignoreContents, err := ioutil.ReadFile(filepath.Join(absPath, ".gitignore"))
        if err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                return gitRepo{}, err
        }</span>

        <span class="cov8" title="1">dockerignoreContents, err := ioutil.ReadFile(filepath.Join(absPath, ".dockerignore"))
        if err != nil </span><span class="cov8" title="1">{
                if !os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return gitRepo{}, err
                }</span>
        }

        <span class="cov8" title="1">return gitRepo{absPath, string(gitignoreContents), string(dockerignoreContents)}, nil</span>
}

var _ skylark.Value = gitRepo{}

func (gr gitRepo) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("[gitRepo] '%v'", gr.basePath)
}</span>

func (gr gitRepo) Type() string <span class="cov8" title="1">{
        return "gitRepo"
}</span>

func (gr gitRepo) Freeze() {<span class="cov0" title="0">}</span>

func (gr gitRepo) Truth() skylark.Bool <span class="cov8" title="1">{
        return gr.basePath != "" || gr.gitignoreContents != "" || gr.dockerignoreContents != ""
}</span>

func (gitRepo) Hash() (uint32, error) <span class="cov0" title="0">{
        return 0, errors.New("unhashable type: gitRepo")
}</span>

func (gr gitRepo) Attr(name string) (skylark.Value, error) <span class="cov8" title="1">{
        switch name </span>{
        case "path":<span class="cov8" title="1">
                return skylark.NewBuiltin(name, gr.path), nil</span>
        default:<span class="cov0" title="0">
                return nil, nil</span>
        }

}

func (gr gitRepo) AttrNames() []string <span class="cov0" title="0">{
        return []string{"path"}
}</span>

func (gr gitRepo) path(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) <span class="cov8" title="1">{
        var path string
        err := skylark.UnpackArgs(fn.Name(), args, kwargs, "path", &amp;path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return gr.makeLocalPath(path), nil</span>
}

func (gr gitRepo) makeLocalPath(path string) localPath <span class="cov8" title="1">{
        return localPath{filepath.Join(gr.basePath, path), gr}
}</span>

type localPath struct {
        path string
        repo gitRepo
}

func (tf *Tiltfile) localPathFromSkylarkValue(v skylark.Value) (localPath, error) <span class="cov8" title="1">{
        switch v := v.(type) </span>{
        case localPath:<span class="cov8" title="1">
                return v, nil</span>
        case gitRepo:<span class="cov8" title="1">
                return v.makeLocalPath("."), nil</span>
        case skylark.String:<span class="cov8" title="1">
                return tf.localPathFromString(string(v))</span>
        default:<span class="cov0" title="0">
                return localPath{}, fmt.Errorf(" Expected local path. Actual type: %T", v)</span>
        }
}

func (t *Tiltfile) localPathFromString(path string) (localPath, error) <span class="cov8" title="1">{
        absPath := t.absPath(path)
        _, err := os.Stat(absPath)
        if err != nil </span><span class="cov8" title="1">{
                return localPath{}, fmt.Errorf("Reading path %s: %v", path, err)
        }</span>

        <span class="cov8" title="1">absDirPath := filepath.Dir(absPath)
        _, err = os.Stat(filepath.Join(absDirPath, ".git"))
        if err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                return localPath{}, fmt.Errorf("Reading path %s: %v", path, err)
        }</span>

        <span class="cov8" title="1">hasGitDir := !os.IsNotExist(err)
        repo := gitRepo{}

        if hasGitDir </span><span class="cov8" title="1">{
                repo, err = t.newGitRepo(absDirPath)
                if err != nil </span><span class="cov0" title="0">{
                        return localPath{}, err
                }</span>
        }

        <span class="cov8" title="1">return localPath{
                path: absPath,
                repo: repo,
        }, nil</span>
}

var _ skylark.Value = localPath{}

func (l localPath) String() string <span class="cov8" title="1">{
        return l.path
}</span>

func (localPath) Type() string <span class="cov0" title="0">{
        return "localPath"
}</span>

func (localPath) Freeze() {<span class="cov0" title="0">}</span>

func (localPath) Hash() (uint32, error) <span class="cov0" title="0">{
        return 0, errors.New("unhashable type: localPath")
}</span>

func (p localPath) Truth() skylark.Bool <span class="cov8" title="1">{
        return p != localPath{}
}</span>

func badTypeErr(b *skylark.Builtin, ex interface{}, v skylark.Value) error <span class="cov0" title="0">{
        return fmt.Errorf("%v expects a %T; got %T (%v)", b.Name(), ex, v, v)
}</span>
</pre>
		
		<pre class="file" id="file73" style="display: none">package tiltfile

import (
        "errors"

        "github.com/google/skylark"
)

const buildContextKey = "buildContext"
const readFilesKey = "readFiles"
const reposKey = "repos"

func getAndClearBuildContext(t *skylark.Thread) (*dockerImage, error) <span class="cov8" title="1">{
        obj := t.Local(buildContextKey)
        if obj == nil </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">buildContext, ok := obj.(*dockerImage)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("internal error: buildContext thread local was not of type *dockerImage")
        }</span>
        <span class="cov8" title="1">t.SetLocal(buildContextKey, nil)
        return buildContext, nil</span>
}

func getAndClearReadFiles(t *skylark.Thread) ([]string, error) <span class="cov8" title="1">{
        readFiles, err := getReadFiles(t)
        t.SetLocal(readFilesKey, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return readFiles, nil</span>
}

func getReadFiles(t *skylark.Thread) ([]string, error) <span class="cov8" title="1">{
        obj := t.Local(readFilesKey)
        if obj == nil </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">readFiles, ok := obj.([]string)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("internal error: readFiles thread local was not of type []string")
        }</span>
        <span class="cov8" title="1">return readFiles, nil</span>
}

func (t *Tiltfile) recordReadFile(thread *skylark.Thread, path string) error <span class="cov8" title="1">{
        path = t.absPath(path)
        readFiles, err := getReadFiles(thread)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">thread.SetLocal(readFilesKey, append(readFiles, path))
        return nil</span>
}
</pre>
		
		<pre class="file" id="file74" style="display: none">package tiltfile

import (
        "fmt"
        "io"
        "io/ioutil"
        "os/exec"
        "path/filepath"
        "sort"

        "github.com/pkg/errors"

        "github.com/docker/distribution/reference"
        "github.com/google/skylark"
        "github.com/google/skylark/resolve"
        "github.com/windmilleng/tilt/internal/kustomize"
        "github.com/windmilleng/tilt/internal/model"
        "github.com/windmilleng/tilt/internal/ospath"
)

const FileName = "Tiltfile"

type Tiltfile struct {
        globals skylark.StringDict
        thread  *skylark.Thread

        // The filename we're executing. Must be absolute.
        filename string
}

func init() <span class="cov8" title="1">{
        resolve.AllowLambda = true
        resolve.AllowNestedDef = true
}</span>

func (t *Tiltfile) makeSkylarkDockerImage(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) <span class="cov8" title="1">{
        var dockerfileName skylark.Value
        var entrypoint, dockerRef string
        err := skylark.UnpackArgs(fn.Name(), args, kwargs,
                "docker_file_name", &amp;dockerfileName,
                "docker_file_tag", &amp;dockerRef,
                "entrypoint?", &amp;entrypoint,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">dockerfileLocalPath, err := t.localPathFromSkylarkValue(dockerfileName)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("Argument 0 (docker_file_name): %v", err)
        }</span>

        <span class="cov8" title="1">ref, err := reference.ParseNormalizedNamed(dockerRef)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("Parsing %q: %v", dockerRef, err)
        }</span>

        <span class="cov8" title="1">existingBC := thread.Local(buildContextKey)

        if existingBC != nil </span><span class="cov8" title="1">{
                return skylark.None, errors.New("tried to start a build context while another build context was already open")
        }</span>

        <span class="cov8" title="1">buildContext := &amp;dockerImage{
                baseDockerfilePath: dockerfileLocalPath,
                ref:                ref,
                entrypoint:         entrypoint,
                tiltFilename:       t.filename,
        }
        err = t.recordReadFile(thread, dockerfileLocalPath.path)
        if err != nil </span><span class="cov0" title="0">{
                return skylark.None, err
        }</span>
        <span class="cov8" title="1">thread.SetLocal(buildContextKey, buildContext)
        return skylark.None, nil</span>
}

func (t *Tiltfile) makeStaticBuild(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) <span class="cov8" title="1">{
        var dockerRef string
        var dockerfilePath, buildPath skylark.Value
        err := skylark.UnpackArgs(fn.Name(), args, kwargs,
                "dockerfile", &amp;dockerfilePath,
                "ref", &amp;dockerRef,
                "context?", &amp;buildPath,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">ref, err := reference.ParseNormalizedNamed(dockerRef)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Parsing %q: %v", dockerRef, err)
        }</span>

        <span class="cov8" title="1">dockerfileLocalPath, err := t.localPathFromSkylarkValue(dockerfilePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Argument 0 (dockerfile): %v", err)
        }</span>

        <span class="cov8" title="1">var buildLocalPath localPath
        if buildPath == nil </span><span class="cov8" title="1">{
                buildLocalPath = localPath{
                        path: filepath.Dir(dockerfileLocalPath.path),
                        repo: dockerfileLocalPath.repo,
                }
        }</span> else<span class="cov8" title="1"> {
                buildLocalPath, err = t.localPathFromSkylarkValue(buildPath)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Argument 2 (context): %v", err)
                }</span>
        }

        <span class="cov8" title="1">buildContext := &amp;dockerImage{
                staticDockerfilePath: dockerfileLocalPath,
                staticBuildPath:      buildLocalPath,
                ref:                  ref,
                tiltFilename:         t.filename,
        }
        err = t.recordReadFile(thread, dockerfileLocalPath.path)
        if err != nil </span><span class="cov0" title="0">{
                return skylark.None, err
        }</span>
        <span class="cov8" title="1">return buildContext, nil</span>
}

func unimplementedSkylarkFunction(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) <span class="cov8" title="1">{
        return skylark.None, errors.New(fmt.Sprintf("%s not implemented", fn.Name()))
}</span>

func makeSkylarkK8Manifest(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) <span class="cov8" title="1">{
        var yaml skylark.String
        var dockerImage *dockerImage
        err := skylark.UnpackArgs(fn.Name(), args, kwargs, "yaml", &amp;yaml, "dockerImage", &amp;dockerImage)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // Name will be initialized later
        <span class="cov8" title="1">return &amp;k8sManifest{
                k8sYaml:     yaml,
                dockerImage: *dockerImage,
        }, nil</span>
}

func (t *Tiltfile) makeSkylarkCompositeManifest(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) <span class="cov8" title="1">{

        var manifestFuncs skylark.Iterable
        err := skylark.UnpackArgs(fn.Name(), args, kwargs,
                "services", &amp;manifestFuncs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var manifests []*k8sManifest

        var v skylark.Value
        i := manifestFuncs.Iterate()
        defer i.Done()
        for i.Next(&amp;v) </span><span class="cov8" title="1">{
                switch v := v.(type) </span>{
                case *skylark.Function:<span class="cov8" title="1">
                        thread.SetLocal(readFilesKey, []string{})
                        r, err := v.Call(thread, nil, nil)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">s, ok := r.(*k8sManifest)
                        if !ok </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("composite_service: function %v returned %v %T; expected k8s_service", v.Name(), r, r)
                        }</span>
                        <span class="cov8" title="1">err = t.recordReadToTiltFile(thread)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov8" title="1">files, err := getAndClearReadFiles(thread)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov8" title="1">s.name = v.Name()
                        s.configFiles = files

                        manifests = append(manifests, s)</span>
                default:<span class="cov0" title="0">
                        return nil, fmt.Errorf("composite_service: unexpected input %v %T", v, v)</span>
                }
        }
        <span class="cov8" title="1">return compManifest{manifests}, nil</span>
}

func (t *Tiltfile) makeSkylarkGitRepo(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) <span class="cov8" title="1">{
        var path string
        err := skylark.UnpackArgs(fn.Name(), args, kwargs, "path", &amp;path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">repo, err := t.newGitRepo(path)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return repo, nil</span>
}

func runLocalCmd(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) <span class="cov8" title="1">{
        var command string
        err := skylark.UnpackArgs(fn.Name(), args, kwargs, "command", &amp;command)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">out, err := execLocalCmd(command)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return skylark.String(out), nil</span>
}

func execLocalCmd(cmd string) (string, error) <span class="cov8" title="1">{
        out, err := exec.Command("sh", "-c", cmd).Output()
        if err != nil </span><span class="cov8" title="1">{
                errorMessage := fmt.Sprintf("command '%v' failed.\nerror: '%v'\nstdout: '%v'", cmd, err, string(out))
                exitError, ok := err.(*exec.ExitError)
                if ok </span><span class="cov8" title="1">{
                        errorMessage += fmt.Sprintf("\nstderr: '%v'", string(exitError.Stderr))
                }</span>
                <span class="cov8" title="1">return "", errors.New(errorMessage)</span>
        }

        <span class="cov8" title="1">return string(out), nil</span>
}

// When running the Tilt demo, the current working directory is arbitrary.
// So we want to resolve paths relative to the dir where the Tiltfile lives,
// not relative to the working directory.
func (t *Tiltfile) absPath(path string) string <span class="cov8" title="1">{
        if filepath.IsAbs(path) </span><span class="cov8" title="1">{
                return path
        }</span>
        <span class="cov8" title="1">return filepath.Join(t.absWorkingDir(), path)</span>
}

func (t *Tiltfile) absWorkingDir() string <span class="cov8" title="1">{
        return filepath.Dir(t.filename)
}</span>

func (t *Tiltfile) readFile(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) <span class="cov8" title="1">{
        var path string
        err := skylark.UnpackArgs(fn.Name(), args, kwargs, "path", &amp;path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">path = t.absPath(path)
        dat, err := ioutil.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">err = t.recordReadFile(thread, path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return skylark.String(dat), nil</span>
}

func stopBuild(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) <span class="cov8" title="1">{
        buildContext, err := getAndClearBuildContext(thread)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span> else<span class="cov8" title="1"> if buildContext == nil </span><span class="cov8" title="1">{
                return nil, errors.New(noActiveBuildError)
        }</span>
        <span class="cov8" title="1">return buildContext, nil</span>
}

func (t *Tiltfile) callKustomize(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) <span class="cov8" title="1">{
        var path skylark.Value
        err := skylark.UnpackArgs(fn.Name(), args, kwargs, "path", &amp;path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">kustomizePath, err := t.localPathFromSkylarkValue(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Argument 0 (path): %v", err)
        }</span>

        <span class="cov8" title="1">cmd := fmt.Sprintf("kustomize build %s", path)
        yaml, err := execLocalCmd(cmd)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">deps, err := kustomize.Deps(kustomizePath.String())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("internal error: %v", err)
        }</span>
        <span class="cov8" title="1">for _, d := range deps </span><span class="cov8" title="1">{
                err := t.recordReadFile(thread, d)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">return skylark.String(yaml), nil</span>
}

func Load(filename string, out io.Writer) (*Tiltfile, error) <span class="cov8" title="1">{
        thread := &amp;skylark.Thread{
                Print: func(_ *skylark.Thread, msg string) </span><span class="cov8" title="1">{
                        _, _ = fmt.Fprintln(out, msg)
                }</span>,
        }

        <span class="cov8" title="1">filename, err := ospath.RealAbs(filename)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">tiltfile := &amp;Tiltfile{
                filename: filename,
                thread:   thread,
        }

        predeclared := skylark.StringDict{
                "start_fast_build":  skylark.NewBuiltin("start_fast_build", tiltfile.makeSkylarkDockerImage),
                "start_slow_build":  skylark.NewBuiltin("start_slow_build", unimplementedSkylarkFunction),
                "static_build":      skylark.NewBuiltin("static_build", tiltfile.makeStaticBuild),
                "k8s_service":       skylark.NewBuiltin("k8s_service", makeSkylarkK8Manifest),
                "local_git_repo":    skylark.NewBuiltin("local_git_repo", tiltfile.makeSkylarkGitRepo),
                "local":             skylark.NewBuiltin("local", runLocalCmd),
                "composite_service": skylark.NewBuiltin("composite_service", tiltfile.makeSkylarkCompositeManifest),
                "read_file":         skylark.NewBuiltin("read_file", tiltfile.readFile),
                "stop_build":        skylark.NewBuiltin("stop_build", stopBuild),
                "add":               skylark.NewBuiltin("add", addMount),
                "run":               skylark.NewBuiltin("run", tiltfile.runDockerImageCmd),
                "kustomize":         skylark.NewBuiltin("kustomize", tiltfile.callKustomize),
        }

        globals, err := skylark.ExecFile(thread, filename, nil, predeclared)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">tiltfile.globals = globals
        return tiltfile, nil</span>
}

func (t Tiltfile) GetManifestConfigs(names ...string) ([]model.Manifest, error) <span class="cov8" title="1">{
        var manifests []model.Manifest
        for _, manifestName := range names </span><span class="cov8" title="1">{
                curManifests, err := t.getManifestConfigsHelper(manifestName)
                if err != nil </span><span class="cov8" title="1">{
                        return manifests, err
                }</span>

                <span class="cov8" title="1">manifests = append(manifests, curManifests...)</span>
        }

        <span class="cov8" title="1">return manifests, nil</span>
}

func (tiltfile Tiltfile) getManifestConfigsHelper(manifestName string) ([]model.Manifest, error) <span class="cov8" title="1">{
        f, ok := tiltfile.globals[manifestName]

        if !ok </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("%v does not define a global named '%v'", tiltfile.filename, manifestName)
        }</span>

        <span class="cov8" title="1">manifestFunction, ok := f.(*skylark.Function)

        if !ok </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("'%v' is a '%v', not a function. service definitions must be functions", manifestName, f.Type())
        }</span>

        <span class="cov8" title="1">if manifestFunction.NumParams() != 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("func '%v' is defined to take more than 0 arguments. service definitions must take 0 arguments", manifestName)
        }</span>

        <span class="cov8" title="1">thread := tiltfile.thread
        thread.SetLocal(readFilesKey, []string{})

        err := tiltfile.recordReadToTiltFile(thread)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">val, err := manifestFunction.Call(tiltfile.thread, nil, nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("error running '%v': %v", manifestName, err.Error())
        }</span>

        <span class="cov8" title="1">files, err := getAndClearReadFiles(thread)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">switch manifest := val.(type) </span>{
        case compManifest:<span class="cov8" title="1">
                var manifests []model.Manifest

                for _, cMan := range manifest.cManifest </span><span class="cov8" title="1">{
                        m, err := skylarkManifestToDomain(cMan)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov8" title="1">manifests = append(manifests, m)</span>
                }
                <span class="cov8" title="1">return manifests, nil</span>
        case *k8sManifest:<span class="cov8" title="1">
                manifest.configFiles = files

                s, err := skylarkManifestToDomain(manifest)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">s.Name = model.ManifestName(manifestName)
                return []model.Manifest{s}, nil</span>

        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("'%v' returned a '%v', but it needs to return a k8s_service or composite_service", manifestName, val.Type())</span>
        }
}

func skylarkManifestToDomain(manifest *k8sManifest) (model.Manifest, error) <span class="cov8" title="1">{
        k8sYaml, ok := skylark.AsString(manifest.k8sYaml)
        if !ok </span><span class="cov0" title="0">{
                return model.Manifest{}, fmt.Errorf("internal error: k8sService.k8sYaml was not a string in '%v'", manifest)
        }</span>

        <span class="cov8" title="1">var err error
        image := manifest.dockerImage
        baseDockerfileBytes := []byte{}
        staticDockerfileBytes := []byte{}
        if image.staticDockerfilePath.Truth() </span><span class="cov8" title="1">{
                staticDockerfileBytes, err = ioutil.ReadFile(image.staticDockerfilePath.path)
                if err != nil </span><span class="cov0" title="0">{
                        return model.Manifest{}, fmt.Errorf("failed to open dockerfile '%v': %v", image.staticDockerfilePath.path, err)
                }</span>
        } else<span class="cov8" title="1"> {
                baseDockerfileBytes, err = ioutil.ReadFile(image.baseDockerfilePath.path)
                if err != nil </span><span class="cov0" title="0">{
                        return model.Manifest{}, fmt.Errorf("failed to open dockerfile '%v': %v", image.baseDockerfilePath.path, err)
                }</span>
        }

        <span class="cov8" title="1">return model.Manifest{
                K8sYaml:        k8sYaml,
                BaseDockerfile: string(baseDockerfileBytes),
                Mounts:         skylarkMountsToDomain(image.mounts),
                Steps:          image.steps,
                Entrypoint:     model.ToShellCmd(image.entrypoint),
                DockerRef:      image.ref,
                Name:           model.ManifestName(manifest.name),
                TiltFilename:   image.tiltFilename,
                ConfigFiles:    SkylarkConfigFilesToDomain(manifest.configFiles),

                StaticDockerfile: string(staticDockerfileBytes),
                StaticBuildPath:  string(image.staticBuildPath.path),

                Repos:        SkylarkReposToDomain(image),
                PortForwards: manifest.portForwards,
        }, nil</span>

}

func SkylarkConfigFilesToDomain(cf []string) []string <span class="cov8" title="1">{
        ss := sort.StringSlice(cf)
        ss.Sort()

        return ss
}</span>

func SkylarkReposToDomain(image dockerImage) []model.LocalGithubRepo <span class="cov8" title="1">{
        dRepos := []model.LocalGithubRepo{}
        repoSet := make(map[string]bool, 0)

        maybeAddRepo := func(repo gitRepo) </span><span class="cov8" title="1">{
                if !repo.Truth() </span><span class="cov8" title="1">{
                        return
                }</span>

                <span class="cov8" title="1">if repoSet[repo.basePath] </span><span class="cov8" title="1">{
                        return
                }</span>

                <span class="cov8" title="1">repoSet[repo.basePath] = true
                dRepos = append(dRepos, model.LocalGithubRepo{
                        LocalPath:            repo.basePath,
                        DockerignoreContents: repo.dockerignoreContents,
                        GitignoreContents:    repo.gitignoreContents,
                })</span>
        }

        <span class="cov8" title="1">for _, m := range image.mounts </span><span class="cov8" title="1">{
                maybeAddRepo(m.repo)
        }</span>
        <span class="cov8" title="1">maybeAddRepo(image.baseDockerfilePath.repo)
        maybeAddRepo(image.staticDockerfilePath.repo)
        maybeAddRepo(image.staticBuildPath.repo)

        return dRepos</span>
}

func skylarkMountsToDomain(sMounts []mount) []model.Mount <span class="cov8" title="1">{
        dMounts := make([]model.Mount, len(sMounts))
        for i, m := range sMounts </span><span class="cov8" title="1">{
                dMounts[i] = model.Mount{
                        LocalPath:     m.src.path,
                        ContainerPath: m.mountPoint,
                }
        }</span>
        <span class="cov8" title="1">return dMounts</span>
}

func (t *Tiltfile) recordReadToTiltFile(thread *skylark.Thread) error <span class="cov8" title="1">{
        err := t.recordReadFile(thread, FileName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file75" style="display: none">package tracer

import (
        "context"
        "fmt"
        "log"
        "strings"

        "github.com/windmilleng/tilt/internal/logger"

        "github.com/pkg/errors"

        "github.com/opentracing/opentracing-go"
        zipkin "github.com/openzipkin/zipkin-go-opentracing"
)

const windmillTracerHostPort = "opentracing.windmill.build:9411"

type zipkinLogger struct {
        ctx context.Context
}

func (zl zipkinLogger) Log(keyvals ...interface{}) error <span class="cov0" title="0">{
        logger.Get(zl.ctx).Debugf("%v", keyvals)
        return nil
}</span>

var _ zipkin.Logger = zipkinLogger{}

func Init(ctx context.Context) (func() error, error) <span class="cov0" title="0">{
        collector, err := zipkin.NewHTTPCollector(fmt.Sprintf("http://%s/api/v1/spans", windmillTracerHostPort), zipkin.HTTPLogger(zipkinLogger{ctx}))

        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "unable to create zipkin collector")
        }</span>

        <span class="cov0" title="0">recorder := zipkin.NewRecorder(collector, true, "0.0.0.0:0", "tilt")
        tracer, err := zipkin.NewTracer(recorder)

        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "unable to create tracer")
        }</span>

        <span class="cov0" title="0">opentracing.SetGlobalTracer(tracer)

        return collector.Close, nil</span>

}

func TraceID(ctx context.Context) (string, error) <span class="cov0" title="0">{
        spanContext := opentracing.SpanFromContext(ctx)
        if spanContext == nil </span><span class="cov0" title="0">{
                return "", errors.New("cannot get traceid - there is no span context")
        }</span>
        <span class="cov0" title="0">zipkinSpanContext, ok := spanContext.Context().(zipkin.SpanContext)
        if !ok </span><span class="cov0" title="0">{
                return "", errors.New("cannot get traceid - span context was not a zipkin span context")
        }</span>
        <span class="cov0" title="0">return zipkinSpanContext.TraceID.ToHex(), nil</span>
}

// TagStrToMap converts a user-passed string of tags of the form `key1=val1,key2=val2` to a map.
func TagStrToMap(tagStr string) map[string]string <span class="cov8" title="1">{
        if tagStr == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">res := make(map[string]string)
        pairs := strings.Split(tagStr, ",")
        for _, p := range pairs </span><span class="cov8" title="1">{
                elems := strings.Split(strings.TrimSpace(p), "=")
                if len(elems) != 2 </span><span class="cov8" title="1">{
                        log.Printf("got malformed trace tag: %s", p)
                        continue</span>
                }
                <span class="cov8" title="1">res[elems[0]] = elems[1]</span>
        }
        <span class="cov8" title="1">return res</span>
}
</pre>
		
		<pre class="file" id="file76" style="display: none">package watch

import (
        "os"
        "strconv"
)

const CheckLimitKey = "WM_CHECK_LIMIT"

var limitChecksEnabled = true

// Allows limit checks to be disabled for testing.
func SetLimitChecksEnabled(enabled bool) <span class="cov8" title="1">{
        limitChecksEnabled = enabled
}</span>

func LimitChecksEnabled() bool <span class="cov0" title="0">{
        env, ok := os.LookupEnv(CheckLimitKey)
        if ok </span><span class="cov0" title="0">{
                enabled, err := strconv.ParseBool(env)
                if err == nil </span><span class="cov0" title="0">{
                        return enabled
                }</span>
        }

        <span class="cov0" title="0">return limitChecksEnabled</span>
}
</pre>
		
		<pre class="file" id="file77" style="display: none">package watch

import (
        "os"
        "path/filepath"
        "strings"
)

func pathIsChildOf(path string, parent string) bool <span class="cov8" title="1">{
        relPath, err := filepath.Rel(parent, path)
        if err != nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov8" title="1">if relPath == "." </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov8" title="1">if filepath.IsAbs(relPath) || strings.HasPrefix(relPath, ".."+string(os.PathSeparator)) </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file78" style="display: none">package watch

import (
        "io/ioutil"
        "os"
        "path/filepath"
)

// TempDir holds a temp directory and allows easy access to new temp directories.
type TempDir struct {
        dir string
}

// NewDir creates a new TempDir in the default location (typically $TMPDIR)
func NewDir(prefix string) (*TempDir, error) <span class="cov8" title="1">{
        return NewDirAtRoot("", prefix)
}</span>

// NewDir creates a new TempDir at the given root.
func NewDirAtRoot(root, prefix string) (*TempDir, error) <span class="cov8" title="1">{
        tmpDir, err := ioutil.TempDir(root, prefix)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">realTmpDir, err := filepath.EvalSymlinks(tmpDir)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;TempDir{dir: realTmpDir}, nil</span>
}

// NewDirAtSlashTmp creates a new TempDir at /tmp
func NewDirAtSlashTmp(prefix string) (*TempDir, error) <span class="cov0" title="0">{
        fullyResolvedPath, err := filepath.EvalSymlinks("/tmp")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return NewDirAtRoot(fullyResolvedPath, prefix)</span>
}

// d.NewDir creates a new TempDir under d
func (d *TempDir) NewDir(prefix string) (*TempDir, error) <span class="cov8" title="1">{
        d2, err := ioutil.TempDir(d.dir, prefix)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;TempDir{d2}, nil</span>
}

func (d *TempDir) NewDeterministicDir(name string) (*TempDir, error) <span class="cov0" title="0">{
        d2 := filepath.Join(d.dir, name)
        err := os.Mkdir(d2, 0700)
        if os.IsExist(err) </span><span class="cov0" title="0">{
                return nil, err
        }</span> else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;TempDir{d2}, nil</span>
}

func (d *TempDir) TearDown() error <span class="cov8" title="1">{
        return os.RemoveAll(d.dir)
}</span>

func (d *TempDir) Path() string <span class="cov8" title="1">{
        return d.dir
}</span>

// Possible extensions:
// temp file
// named directories or files (e.g., we know we want one git repo for our object, but it should be temporary)
</pre>
		
		<pre class="file" id="file79" style="display: none">package watch

import (
        "path/filepath"
        "sync"
        "time"

        "github.com/windmilleng/fsevents"
)

type darwinNotify struct {
        stream *fsevents.EventStream
        events chan FileEvent
        errors chan error
        stop   chan struct{}

        // TODO(nick): This mutex is needed for the case where we add paths after we
        // start watching. But because fsevents supports recursive watches, we don't
        // actually need this feature. We should change the api contract of wmNotify
        // so that, for recursive watches, we can guarantee that the path list doesn't
        // change.
        sm *sync.Mutex

        pathsWereWatching map[string]interface{}
        sawAnyHistoryDone bool
}

func (d *darwinNotify) loop() <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-d.stop:<span class="cov8" title="1">
                        return</span>
                case events, ok := &lt;-d.stream.Events:<span class="cov8" title="1">
                        if !ok </span><span class="cov0" title="0">{
                                return
                        }</span>

                        <span class="cov8" title="1">for _, e := range events </span><span class="cov8" title="1">{
                                e.Path = filepath.Join("/", e.Path)

                                if e.Flags&amp;fsevents.HistoryDone == fsevents.HistoryDone </span><span class="cov8" title="1">{
                                        d.sm.Lock()
                                        d.sawAnyHistoryDone = true
                                        d.sm.Unlock()
                                        continue</span>
                                }

                                // We wait until we've seen the HistoryDone event for this watcher before processing any events
                                // so that we skip all of the "spurious" events that precede it.
                                <span class="cov8" title="1">if !d.sawAnyHistoryDone </span><span class="cov8" title="1">{
                                        continue</span>
                                }

                                <span class="cov8" title="1">_, isPathWereWatching := d.pathsWereWatching[e.Path]
                                if e.Flags&amp;fsevents.ItemIsDir == fsevents.ItemIsDir &amp;&amp; e.Flags&amp;fsevents.ItemCreated == fsevents.ItemCreated &amp;&amp; isPathWereWatching </span><span class="cov8" title="1">{
                                        // This is the first create for the path that we're watching. We always get exactly one of these
                                        // even after we get the HistoryDone event. Skip it.
                                        continue</span>
                                }

                                <span class="cov8" title="1">d.events &lt;- FileEvent{
                                        Path: e.Path,
                                }</span>
                        }
                }
        }
}

func (d *darwinNotify) Add(name string) error <span class="cov8" title="1">{
        d.sm.Lock()
        defer d.sm.Unlock()

        es := d.stream

        // Check if this is a subdirectory of any of the paths
        // we're already watching.
        for _, parent := range es.Paths </span><span class="cov8" title="1">{
                isChild := pathIsChildOf(name, parent)
                if isChild </span><span class="cov8" title="1">{
                        return nil
                }</span>
        }

        <span class="cov8" title="1">es.Paths = append(es.Paths, name)

        if d.pathsWereWatching == nil </span><span class="cov8" title="1">{
                d.pathsWereWatching = make(map[string]interface{})
        }</span>
        <span class="cov8" title="1">d.pathsWereWatching[name] = struct{}{}

        if len(es.Paths) == 1 </span><span class="cov8" title="1">{
                es.Start()
                go d.loop()
        }</span> else<span class="cov8" title="1"> {
                es.Restart()
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (d *darwinNotify) Close() error <span class="cov8" title="1">{
        d.sm.Lock()
        defer d.sm.Unlock()

        d.stream.Stop()
        close(d.errors)
        close(d.stop)

        return nil
}</span>

func (d *darwinNotify) Events() chan FileEvent <span class="cov8" title="1">{
        return d.events
}</span>

func (d *darwinNotify) Errors() chan error <span class="cov8" title="1">{
        return d.errors
}</span>

func NewWatcher() (Notify, error) <span class="cov8" title="1">{
        dw := &amp;darwinNotify{
                stream: &amp;fsevents.EventStream{
                        Latency: 1 * time.Millisecond,
                        Flags:   fsevents.FileEvents,
                        // NOTE(dmiller): this corresponds to the `sinceWhen` parameter in FSEventStreamCreate
                        // https://developer.apple.com/documentation/coreservices/1443980-fseventstreamcreate
                        EventID: fsevents.LatestEventID(),
                },
                sm:     &amp;sync.Mutex{},
                events: make(chan FileEvent),
                errors: make(chan error),
                stop:   make(chan struct{}),
        }

        return dw, nil
}</span>

var _ Notify = &amp;darwinNotify{}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
